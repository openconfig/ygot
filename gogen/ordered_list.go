// Copyright 2023 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gogen

import (
	"bytes"
)

// generatedOrderedMapStruct contains the necessary information to generate an
// ordered map GoStruct.
type generatedOrderedMapStruct struct {
	// StructName is the name of the ordered map struct.
	StructName string
	// KeyName is the name of the key of the ordered map.
	KeyName string
	// ListElementName is the name of the list element that form the values
	// of the ordered map.
	ListElementName string
	// Keys of the list that is being generated (length = 1 if the list is
	// single keyed).
	Keys []goStructField
}

var (
	goOrderedMapTemplate = mustMakeTemplate("orderedMap", `
type {{ .StructName }} struct {
	keys []{{ .KeyName }}
	valueMap map[{{ .KeyName }}]*{{ .ListElementName }}
}

// IsYANGGoStruct ensures that {{ .StructName }} implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*{{ .StructName }}) IsYANGGoStruct() {}

// init initializes any uninitialized values.
func (o *{{ .StructName }}) init() {
	if o.valueMap == nil {
		o.valueMap = map[{{ .KeyName }}]*{{ .ListElementName }}{}
	}
}

// Keys returns a copy of the list's keys.
func (o *{{ .StructName }}) Keys() []{{ .KeyName }} {
	return append([]{{ .KeyName }}{}, o.keys...)
}

// Values returns the current set of the list's values in order.
func (o *{{ .StructName }}) Values() []*{{ .ListElementName }} {
	var values []*{{ .ListElementName }}
	for _, key := range o.keys {
		values = append(values, o.valueMap[key])
	}
	return values
}

// Len returns a size of {{ .StructName }}
func (o *{{ .StructName }}) Len() int {
	return len(o.keys)
}

// Get returns the value corresponding to the key. If the key is not found, nil
// is returned.
func (o *{{ .StructName }}) Get(key {{ .KeyName }}) *{{ .ListElementName }} {
	val, _ := o.valueMap[key]
	return val
}

// Delete deletes an element.
func (o *{{ .StructName }}) Delete(key {{ .KeyName }}) bool {
	if _, ok := o.valueMap[key]; !ok {
		return false
	}
	for i, k := range o.keys {
		if k == key {
			o.keys = append(o.keys[:i], o.keys[i+1:]...)
			delete(o.valueMap, key)
			return true
		}
	}
	return false
}

// Append appends a {{ .ListElementName }}, returning an error if the key
// already exists in the ordered list or if the key is unspecified.
func (o *{{ .StructName }}) Append(v *{{ .ListElementName }}) error {
	if v == nil {
		return fmt.Errorf("nil {{ .ListElementName }}")
	}
	{{ if gt (len .Keys) 1 -}}
	{{- range $key := .Keys }}
	{{- if $key.IsScalarField -}}
	if v.{{ $key.Name }} == nil {
		return fmt.Errorf("invalid nil key for {{ $key.Name }}")
	}
	{{ end -}}
	{{- end -}}
	key := {{ .KeyName }}{
		{{- range $key := .Keys }}
		{{- if $key.IsScalarField }}
		{{ $key.Name }}: *v.{{ $key.Name }},
		{{- else }}
		{{ $key.Name }}: v.{{ $key.Name }},
		{{- end -}}
		{{ end }}
	}
	{{- else -}}
	{{- range $key := .Keys -}}
		{{- if $key.IsScalarField -}}
	if v.{{ $key.Name }} == nil {
		return fmt.Errorf("invalid nil key received for {{ $key.Name }}")
	}

	key := *v.{{ $key.Name }}
		{{- else -}}
	key := v.{{ $key.Name }}
		{{- end -}}
	{{- end -}}
	{{- end }}

	if _, ok := o.valueMap[key]; ok {
		return fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	o.init()
	o.valueMap[key] = v
	return nil
}

// AppendNew creates and appends a new {{ .ListElementName }}, returning the
// newly-initialized v. It returns an error if the v already exists.
func (o *{{ .StructName }}) AppendNew(
  {{- $length := len .Keys -}}
  {{- range $i, $key := .Keys -}}
	{{ $key.Name }} {{ $key.Type -}}
	{{- if ne (inc $i) $length -}}, {{ end -}}
  {{- end -}}
  ) (*{{ .ListElementName }}, error) {
	{{ if gt (len .Keys) 1 -}}
	key := {{ .KeyName }}{
		{{- range $key := .Keys }}
		{{ $key.Name }}: {{ $key.Name }},
		{{- end }}
	}
	{{- else -}}
	{{- range $key := .Keys -}}
	key := {{ $key.Name }}
	{{- end -}}
	{{- end }}

	if _, ok := o.valueMap[key]; ok {
		return nil, fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	newElement := &{{ .ListElementName }}{
		{{- range $key := .Keys }}
		{{- if $key.IsScalarField }}
		{{ $key.Name }}: &{{ $key.Name }},
		{{- else }}
		{{ $key.Name }}: {{ $key.Name }},
		{{- end -}}
		{{- end }}
	}
	o.init()
	o.valueMap[key] = newElement
	return newElement, nil
}
`)
)

func generateOrderedMapStruct(buf *bytes.Buffer, method *generatedOrderedMapStruct) error {
	return goOrderedMapTemplate.Execute(buf, method)
}
