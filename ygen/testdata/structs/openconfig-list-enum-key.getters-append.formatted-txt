/*
Package ocstructs is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by codegen-tests
using the following YANG input files:
	- testdata/structs/openconfig-list-enum-key.yang
Imported modules were sourced from:
*/
package ocstructs

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// Device represents the /device YANG schema element.
type Device struct {
	Top	*OpenconfigListEnumKey_Top	`path:"top" module:"openconfig-list-enum-key"`
}

// IsYANGGoStruct ensures that Device implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Device) IsYANGGoStruct() {}

// GetOrCreateTop retrieves the value of the Top field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateTop() *OpenconfigListEnumKey_Top {
	if t.Top != nil {
		return t.Top
	}
	t.Top = &OpenconfigListEnumKey_Top{}
	return t.Top
}

// GetTop returns the value of the Top struct pointer
// from Device. If the receiver or the field Top is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetTop() *OpenconfigListEnumKey_Top {
	if t != nil && t.Top != nil {
		return t.Top
	}
	return nil
}

// OpenconfigListEnumKey_Top represents the /openconfig-list-enum-key/top YANG schema element.
type OpenconfigListEnumKey_Top struct {
	MultiKey	*OpenconfigListEnumKey_Top_MultiKey	`path:"multi-key" module:"openconfig-list-enum-key"`
	SingleKey	*OpenconfigListEnumKey_Top_SingleKey	`path:"single-key" module:"openconfig-list-enum-key"`
}

// IsYANGGoStruct ensures that OpenconfigListEnumKey_Top implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigListEnumKey_Top) IsYANGGoStruct() {}

// GetOrCreateMultiKey retrieves the value of the MultiKey field
// or returns the existing field if it already exists.
func (t *OpenconfigListEnumKey_Top) GetOrCreateMultiKey() *OpenconfigListEnumKey_Top_MultiKey {
	if t.MultiKey != nil {
		return t.MultiKey
	}
	t.MultiKey = &OpenconfigListEnumKey_Top_MultiKey{}
	return t.MultiKey
}

// GetOrCreateSingleKey retrieves the value of the SingleKey field
// or returns the existing field if it already exists.
func (t *OpenconfigListEnumKey_Top) GetOrCreateSingleKey() *OpenconfigListEnumKey_Top_SingleKey {
	if t.SingleKey != nil {
		return t.SingleKey
	}
	t.SingleKey = &OpenconfigListEnumKey_Top_SingleKey{}
	return t.SingleKey
}

// GetMultiKey returns the value of the MultiKey struct pointer
// from OpenconfigListEnumKey_Top. If the receiver or the field MultiKey is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpenconfigListEnumKey_Top) GetMultiKey() *OpenconfigListEnumKey_Top_MultiKey {
	if t != nil && t.MultiKey != nil {
		return t.MultiKey
	}
	return nil
}

// GetSingleKey returns the value of the SingleKey struct pointer
// from OpenconfigListEnumKey_Top. If the receiver or the field SingleKey is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpenconfigListEnumKey_Top) GetSingleKey() *OpenconfigListEnumKey_Top_SingleKey {
	if t != nil && t.SingleKey != nil {
		return t.SingleKey
	}
	return nil
}

// OpenconfigListEnumKey_Top_MultiKey represents the /openconfig-list-enum-key/top/multi-key YANG schema element.
type OpenconfigListEnumKey_Top_MultiKey struct {
	Ekm	map[OpenconfigListEnumKey_Top_MultiKey_Ekm_Key]*OpenconfigListEnumKey_Top_MultiKey_Ekm	`path:"ekm" module:"openconfig-list-enum-key"`
}

// IsYANGGoStruct ensures that OpenconfigListEnumKey_Top_MultiKey implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigListEnumKey_Top_MultiKey) IsYANGGoStruct() {}

// OpenconfigListEnumKey_Top_MultiKey_Ekm_Key represents the key for list Ekm of element /openconfig-list-enum-key/top/multi-key.
type OpenconfigListEnumKey_Top_MultiKey_Ekm_Key struct {
	K1	E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1	`path:"k1"`
	K2	E_OpenconfigListEnumKey_FooIdentity	`path:"k2"`
}

// NewEkm creates a new entry in the Ekm list of the
// OpenconfigListEnumKey_Top_MultiKey struct. The keys of the list are populated from the input
// arguments.
func (t *OpenconfigListEnumKey_Top_MultiKey) NewEkm(K1 E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1, K2 E_OpenconfigListEnumKey_FooIdentity) (*OpenconfigListEnumKey_Top_MultiKey_Ekm, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ekm == nil {
		t.Ekm = make(map[OpenconfigListEnumKey_Top_MultiKey_Ekm_Key]*OpenconfigListEnumKey_Top_MultiKey_Ekm)
	}

	key := OpenconfigListEnumKey_Top_MultiKey_Ekm_Key{
		K1: K1,
		K2: K2,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ekm[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ekm", key)
	}

	t.Ekm[key] = &OpenconfigListEnumKey_Top_MultiKey_Ekm{
		K1: K1,
		K2: K2,
	}

	return t.Ekm[key], nil
}

// GetOrCreateEkm retrieves the value with the specified keys from
// the receiver OpenconfigListEnumKey_Top_MultiKey. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *OpenconfigListEnumKey_Top_MultiKey) GetOrCreateEkm(K1 E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1, K2 E_OpenconfigListEnumKey_FooIdentity) (*OpenconfigListEnumKey_Top_MultiKey_Ekm){

	key := OpenconfigListEnumKey_Top_MultiKey_Ekm_Key{
		K1: K1,
		K2: K2,
	}

	if v, ok := t.Ekm[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEkm(K1, K2)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEkm got unexpected error: %v", err))
	}
	return v
}

// GetEkm retrieves the value with the specified key from
// the Ekm map field of OpenconfigListEnumKey_Top_MultiKey. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *OpenconfigListEnumKey_Top_MultiKey) GetEkm(K1 E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1, K2 E_OpenconfigListEnumKey_FooIdentity) (*OpenconfigListEnumKey_Top_MultiKey_Ekm){

	if t == nil {
		return nil
	}

  key := OpenconfigListEnumKey_Top_MultiKey_Ekm_Key{
		K1: K1,
		K2: K2,
	}

  if lm, ok := t.Ekm[key]; ok {
    return lm
  }
  return nil
}

// DeleteEkm deletes the value with the specified keys from
// the receiver OpenconfigListEnumKey_Top_MultiKey. If there is no such element, the function
// is a no-op.
func (t *OpenconfigListEnumKey_Top_MultiKey) DeleteEkm(K1 E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1, K2 E_OpenconfigListEnumKey_FooIdentity) {
	key := OpenconfigListEnumKey_Top_MultiKey_Ekm_Key{
		K1: K1,
		K2: K2,
	}

	delete(t.Ekm, key)
}

// AppendEkm appends the supplied OpenconfigListEnumKey_Top_MultiKey_Ekm struct to the
// list Ekm of OpenconfigListEnumKey_Top_MultiKey. If the key value(s) specified in
// the supplied OpenconfigListEnumKey_Top_MultiKey_Ekm already exist in the list, an error is
// returned.
func (t *OpenconfigListEnumKey_Top_MultiKey) AppendEkm(v *OpenconfigListEnumKey_Top_MultiKey_Ekm) error {
	key := OpenconfigListEnumKey_Top_MultiKey_Ekm_Key{K1: v.K1,K2: v.K2,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ekm == nil {
		t.Ekm = make(map[OpenconfigListEnumKey_Top_MultiKey_Ekm_Key]*OpenconfigListEnumKey_Top_MultiKey_Ekm)
	}

	if _, ok := t.Ekm[key]; ok {
		return fmt.Errorf("duplicate key for list Ekm %v", key)
	}

	t.Ekm[key] = v
	return nil
}

// OpenconfigListEnumKey_Top_MultiKey_Ekm represents the /openconfig-list-enum-key/top/multi-key/ekm YANG schema element.
type OpenconfigListEnumKey_Top_MultiKey_Ekm struct {
	Config	*OpenconfigListEnumKey_Top_MultiKey_Ekm_Config	`path:"config" module:"openconfig-list-enum-key"`
	K1	E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1	`path:"k1" module:"openconfig-list-enum-key"`
	K2	E_OpenconfigListEnumKey_FooIdentity	`path:"k2" module:"openconfig-list-enum-key"`
	State	*OpenconfigListEnumKey_Top_MultiKey_Ekm_State	`path:"state" module:"openconfig-list-enum-key"`
}

// IsYANGGoStruct ensures that OpenconfigListEnumKey_Top_MultiKey_Ekm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigListEnumKey_Top_MultiKey_Ekm) IsYANGGoStruct() {}

// GetOrCreateConfig retrieves the value of the Config field
// or returns the existing field if it already exists.
func (t *OpenconfigListEnumKey_Top_MultiKey_Ekm) GetOrCreateConfig() *OpenconfigListEnumKey_Top_MultiKey_Ekm_Config {
	if t.Config != nil {
		return t.Config
	}
	t.Config = &OpenconfigListEnumKey_Top_MultiKey_Ekm_Config{}
	return t.Config
}

// GetOrCreateState retrieves the value of the State field
// or returns the existing field if it already exists.
func (t *OpenconfigListEnumKey_Top_MultiKey_Ekm) GetOrCreateState() *OpenconfigListEnumKey_Top_MultiKey_Ekm_State {
	if t.State != nil {
		return t.State
	}
	t.State = &OpenconfigListEnumKey_Top_MultiKey_Ekm_State{}
	return t.State
}

// GetConfig returns the value of the Config struct pointer
// from OpenconfigListEnumKey_Top_MultiKey_Ekm. If the receiver or the field Config is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpenconfigListEnumKey_Top_MultiKey_Ekm) GetConfig() *OpenconfigListEnumKey_Top_MultiKey_Ekm_Config {
	if t != nil && t.Config != nil {
		return t.Config
	}
	return nil
}

// GetState returns the value of the State struct pointer
// from OpenconfigListEnumKey_Top_MultiKey_Ekm. If the receiver or the field State is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpenconfigListEnumKey_Top_MultiKey_Ekm) GetState() *OpenconfigListEnumKey_Top_MultiKey_Ekm_State {
	if t != nil && t.State != nil {
		return t.State
	}
	return nil
}

// ΛListKeyMap returns the keys of the OpenconfigListEnumKey_Top_MultiKey_Ekm struct, which is a YANG list entry.
func (t *OpenconfigListEnumKey_Top_MultiKey_Ekm) ΛListKeyMap() (map[string]interface{}, error) {


	return map[string]interface{}{
		"k1": t.K1,
		"k2": t.K2,
	}, nil
}

// OpenconfigListEnumKey_Top_MultiKey_Ekm_Config represents the /openconfig-list-enum-key/top/multi-key/ekm/config YANG schema element.
type OpenconfigListEnumKey_Top_MultiKey_Ekm_Config struct {
	K1	E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1	`path:"k1" module:"openconfig-list-enum-key"`
	K2	E_OpenconfigListEnumKey_FooIdentity	`path:"k2" module:"openconfig-list-enum-key"`
}

// IsYANGGoStruct ensures that OpenconfigListEnumKey_Top_MultiKey_Ekm_Config implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigListEnumKey_Top_MultiKey_Ekm_Config) IsYANGGoStruct() {}

// OpenconfigListEnumKey_Top_MultiKey_Ekm_State represents the /openconfig-list-enum-key/top/multi-key/ekm/state YANG schema element.
type OpenconfigListEnumKey_Top_MultiKey_Ekm_State struct {
	K1	E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1	`path:"k1" module:"openconfig-list-enum-key"`
	K2	E_OpenconfigListEnumKey_FooIdentity	`path:"k2" module:"openconfig-list-enum-key"`
}

// IsYANGGoStruct ensures that OpenconfigListEnumKey_Top_MultiKey_Ekm_State implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigListEnumKey_Top_MultiKey_Ekm_State) IsYANGGoStruct() {}

// OpenconfigListEnumKey_Top_SingleKey represents the /openconfig-list-enum-key/top/single-key YANG schema element.
type OpenconfigListEnumKey_Top_SingleKey struct {
	Eks	map[E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K]*OpenconfigListEnumKey_Top_SingleKey_Eks	`path:"eks" module:"openconfig-list-enum-key"`
}

// IsYANGGoStruct ensures that OpenconfigListEnumKey_Top_SingleKey implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigListEnumKey_Top_SingleKey) IsYANGGoStruct() {}

// NewEks creates a new entry in the Eks list of the
// OpenconfigListEnumKey_Top_SingleKey struct. The keys of the list are populated from the input
// arguments.
func (t *OpenconfigListEnumKey_Top_SingleKey) NewEks(K E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K) (*OpenconfigListEnumKey_Top_SingleKey_Eks, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Eks == nil {
		t.Eks = make(map[E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K]*OpenconfigListEnumKey_Top_SingleKey_Eks)
	}

	key := K

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Eks[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Eks", key)
	}

	t.Eks[key] = &OpenconfigListEnumKey_Top_SingleKey_Eks{
		K: K,
	}

	return t.Eks[key], nil
}

// GetOrCreateEks retrieves the value with the specified keys from
// the receiver OpenconfigListEnumKey_Top_SingleKey. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *OpenconfigListEnumKey_Top_SingleKey) GetOrCreateEks(K E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K) (*OpenconfigListEnumKey_Top_SingleKey_Eks){

	key := K

	if v, ok := t.Eks[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEks(K)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEks got unexpected error: %v", err))
	}
	return v
}

// GetEks retrieves the value with the specified key from
// the Eks map field of OpenconfigListEnumKey_Top_SingleKey. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *OpenconfigListEnumKey_Top_SingleKey) GetEks(K E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K) (*OpenconfigListEnumKey_Top_SingleKey_Eks){

	if t == nil {
		return nil
	}

  key := K

  if lm, ok := t.Eks[key]; ok {
    return lm
  }
  return nil
}

// DeleteEks deletes the value with the specified keys from
// the receiver OpenconfigListEnumKey_Top_SingleKey. If there is no such element, the function
// is a no-op.
func (t *OpenconfigListEnumKey_Top_SingleKey) DeleteEks(K E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K) {
	key := K

	delete(t.Eks, key)
}

// AppendEks appends the supplied OpenconfigListEnumKey_Top_SingleKey_Eks struct to the
// list Eks of OpenconfigListEnumKey_Top_SingleKey. If the key value(s) specified in
// the supplied OpenconfigListEnumKey_Top_SingleKey_Eks already exist in the list, an error is
// returned.
func (t *OpenconfigListEnumKey_Top_SingleKey) AppendEks(v *OpenconfigListEnumKey_Top_SingleKey_Eks) error {
	key := v.K

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Eks == nil {
		t.Eks = make(map[E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K]*OpenconfigListEnumKey_Top_SingleKey_Eks)
	}

	if _, ok := t.Eks[key]; ok {
		return fmt.Errorf("duplicate key for list Eks %v", key)
	}

	t.Eks[key] = v
	return nil
}

// OpenconfigListEnumKey_Top_SingleKey_Eks represents the /openconfig-list-enum-key/top/single-key/eks YANG schema element.
type OpenconfigListEnumKey_Top_SingleKey_Eks struct {
	Config	*OpenconfigListEnumKey_Top_SingleKey_Eks_Config	`path:"config" module:"openconfig-list-enum-key"`
	K	E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K	`path:"k" module:"openconfig-list-enum-key"`
	State	*OpenconfigListEnumKey_Top_SingleKey_Eks_State	`path:"state" module:"openconfig-list-enum-key"`
}

// IsYANGGoStruct ensures that OpenconfigListEnumKey_Top_SingleKey_Eks implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigListEnumKey_Top_SingleKey_Eks) IsYANGGoStruct() {}

// GetOrCreateConfig retrieves the value of the Config field
// or returns the existing field if it already exists.
func (t *OpenconfigListEnumKey_Top_SingleKey_Eks) GetOrCreateConfig() *OpenconfigListEnumKey_Top_SingleKey_Eks_Config {
	if t.Config != nil {
		return t.Config
	}
	t.Config = &OpenconfigListEnumKey_Top_SingleKey_Eks_Config{}
	return t.Config
}

// GetOrCreateState retrieves the value of the State field
// or returns the existing field if it already exists.
func (t *OpenconfigListEnumKey_Top_SingleKey_Eks) GetOrCreateState() *OpenconfigListEnumKey_Top_SingleKey_Eks_State {
	if t.State != nil {
		return t.State
	}
	t.State = &OpenconfigListEnumKey_Top_SingleKey_Eks_State{}
	return t.State
}

// GetConfig returns the value of the Config struct pointer
// from OpenconfigListEnumKey_Top_SingleKey_Eks. If the receiver or the field Config is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpenconfigListEnumKey_Top_SingleKey_Eks) GetConfig() *OpenconfigListEnumKey_Top_SingleKey_Eks_Config {
	if t != nil && t.Config != nil {
		return t.Config
	}
	return nil
}

// GetState returns the value of the State struct pointer
// from OpenconfigListEnumKey_Top_SingleKey_Eks. If the receiver or the field State is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpenconfigListEnumKey_Top_SingleKey_Eks) GetState() *OpenconfigListEnumKey_Top_SingleKey_Eks_State {
	if t != nil && t.State != nil {
		return t.State
	}
	return nil
}

// ΛListKeyMap returns the keys of the OpenconfigListEnumKey_Top_SingleKey_Eks struct, which is a YANG list entry.
func (t *OpenconfigListEnumKey_Top_SingleKey_Eks) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"k": t.K,
	}, nil
}

// OpenconfigListEnumKey_Top_SingleKey_Eks_Config represents the /openconfig-list-enum-key/top/single-key/eks/config YANG schema element.
type OpenconfigListEnumKey_Top_SingleKey_Eks_Config struct {
	K	E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K	`path:"k" module:"openconfig-list-enum-key"`
}

// IsYANGGoStruct ensures that OpenconfigListEnumKey_Top_SingleKey_Eks_Config implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigListEnumKey_Top_SingleKey_Eks_Config) IsYANGGoStruct() {}

// OpenconfigListEnumKey_Top_SingleKey_Eks_State represents the /openconfig-list-enum-key/top/single-key/eks/state YANG schema element.
type OpenconfigListEnumKey_Top_SingleKey_Eks_State struct {
	K	E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K	`path:"k" module:"openconfig-list-enum-key"`
}

// IsYANGGoStruct ensures that OpenconfigListEnumKey_Top_SingleKey_Eks_State implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigListEnumKey_Top_SingleKey_Eks_State) IsYANGGoStruct() {}

// E_OpenconfigListEnumKey_FooIdentity is a derived int64 type which is used to represent
// the enumerated node OpenconfigListEnumKey_FooIdentity. An additional value named
// OpenconfigListEnumKey_FooIdentity_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_OpenconfigListEnumKey_FooIdentity int64

// IsYANGGoEnum ensures that OpenconfigListEnumKey_FooIdentity implements the yang.GoEnum
// interface. This ensures that OpenconfigListEnumKey_FooIdentity can be identified as a
// mapped type for a YANG enumeration.
func (E_OpenconfigListEnumKey_FooIdentity) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  OpenconfigListEnumKey_FooIdentity.
func (E_OpenconfigListEnumKey_FooIdentity) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

const (
	// OpenconfigListEnumKey_FooIdentity_UNSET corresponds to the value UNSET of OpenconfigListEnumKey_FooIdentity
	OpenconfigListEnumKey_FooIdentity_UNSET E_OpenconfigListEnumKey_FooIdentity = 0
	// OpenconfigListEnumKey_FooIdentity_BAR corresponds to the value BAR of OpenconfigListEnumKey_FooIdentity
	OpenconfigListEnumKey_FooIdentity_BAR E_OpenconfigListEnumKey_FooIdentity = 1
	// OpenconfigListEnumKey_FooIdentity_BAZ corresponds to the value BAZ of OpenconfigListEnumKey_FooIdentity
	OpenconfigListEnumKey_FooIdentity_BAZ E_OpenconfigListEnumKey_FooIdentity = 2
)

// E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1 is a derived int64 type which is used to represent
// the enumerated node OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1. An additional value named
// OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1 int64

// IsYANGGoEnum ensures that OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1 implements the yang.GoEnum
// interface. This ensures that OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1 can be identified as a
// mapped type for a YANG enumeration.
func (E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1.
func (E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

const (
	// OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1_UNSET corresponds to the value UNSET of OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1
	OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1_UNSET E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1 = 0
	// OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1_A corresponds to the value A of OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1
	OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1_A E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1 = 1
	// OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1_B corresponds to the value B of OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1
	OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1_B E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1 = 2
)

// E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K is a derived int64 type which is used to represent
// the enumerated node OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K. An additional value named
// OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K int64

// IsYANGGoEnum ensures that OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K implements the yang.GoEnum
// interface. This ensures that OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K can be identified as a
// mapped type for a YANG enumeration.
func (E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K.
func (E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

const (
	// OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K_UNSET corresponds to the value UNSET of OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K
	OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K_UNSET E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K = 0
	// OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K_A corresponds to the value A of OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K
	OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K_A E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K = 1
	// OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K_B corresponds to the value B of OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K
	OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K_B E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K = 2
)

// ΛEnum is a map, keyed by the name of the type defined for each enum in the
// generated Go code, which provides a mapping between the constant int64 value
// of each value of the enumeration, and the string that is used to represent it
// in the YANG schema. The map is named ΛEnum in order to avoid clash with any
// valid YANG identifier.
var ΛEnum = map[string]map[int64]ygot.EnumDefinition{
	"E_OpenconfigListEnumKey_FooIdentity": {
		1: {Name: "BAR", DefiningModule: "openconfig-list-enum-key"},
		2: {Name: "BAZ", DefiningModule: "openconfig-list-enum-key"},
	},
	"E_OpenconfigListEnumKey_Top_MultiKey_Ekm_Config_K1": {
		1: {Name: "A"},
		2: {Name: "B"},
	},
	"E_OpenconfigListEnumKey_Top_SingleKey_Eks_Config_K": {
		1: {Name: "A"},
		2: {Name: "B"},
	},
}
