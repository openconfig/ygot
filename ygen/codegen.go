// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package ygen contains a library to generate Go structs from a YANG model.
// The Goyang parsing library is used to parse YANG. The output can consider
// OpenConfig-specific conventions such that the schema is compressed.
package ygen

import (
	"bytes"
	"errors"
	"fmt"
	"sort"
	"strings"

	log "github.com/golang/glog"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/genutil"
	"github.com/openconfig/ygot/util"
	"github.com/openconfig/ygot/ygot"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
)

// YANGCodeGenerator is a structure that is used to pass arguments as to
// how the output Go code should be generated.
type YANGCodeGenerator struct {
	// Config stores the configuration parameters used for code generation.
	Config GeneratorConfig
}

// GeneratorConfig stores the configuration options used for code generation.
type GeneratorConfig struct {
	// PackageName is the name that should be used for the generating package.
	PackageName string
	// Caller is the name of the binary calling the generator library, it is
	// included in the header of output files for debugging purposes. If a
	// string is not specified, the location of the library is utilised.
	Caller string
	// GenerateJSONSchema stores a boolean which defines whether to generate
	// the JSON corresponding to the YANG schema parsed to generate the
	// output code.
	GenerateJSONSchema bool
	// StoreRawSchema the raw JSON schema should be returned by the code
	// generation function, such that it can be handled by an external
	// library.
	StoreRawSchema bool
	// ParseOptions contains parsing options for a given set of schema files.
	ParseOptions ParseOpts
	// TransformationOptions contains options for how the generated code
	// may be transformed from a simple 1:1 mapping with respect to the
	// given YANG schema.
	TransformationOptions TransformationOpts
	// GoOptions stores a struct which stores Go code generation specific
	// options for the code generaton.
	GoOptions GoOpts
	// ProtoOptions stores a struct which contains Protobuf specific options.
	ProtoOptions ProtoOpts
}

// DirectoryGenConfig contains the configuration necessary to generate a set of
// Directory objects for a given schema. The set of Directory objects is the
// intermediate representation generated by ygen, which can be useful for
// external code generation libraries which can make use of it.
type DirectoryGenConfig struct {
	// ParseOptions contains parsing options for a given set of schema files.
	ParseOptions ParseOpts
	// TransformationOptions contains options for how the generated code
	// may be transformed from a simple 1:1 mapping with respect to the
	// given YANG schema.
	TransformationOptions TransformationOpts

	EnumPrefix string
}

// ParseOpts contains parsing configuration for a given schema.
type ParseOpts struct {
	// ExcludeModules specifies any modules that are included within the set of
	// modules that should have code generated for them that should be ignored during
	// code generation. This is due to the fact that some schemas (e.g., OpenConfig
	// interfaces) currently result in overlapping entities (e.g., /interfaces).
	ExcludeModules []string
	// YANGParseOptions provides the options that should be handed to the
	// github.com/openconfig/goyang/pkg/yang library. These specify how the
	// input YANG files should be parsed.
	YANGParseOptions yang.Options
	// SkipEnumDeduplication specifies whether leaves of type 'enumeration' that
	// are used in multiple places in the schema should share a common type within
	// the generated code that is output by ygen. By default (false), a common type
	// is used.
	//
	// This behaviour is useful in scenarios where there is no difference between
	// two types, and the leaf is mirrored in a logical way (e.g., the OpenConfig
	// config/state split). For example:
	//
	// grouping foo-config {
	//	leaf enabled {
	//		type enumeration {
	//			enum A;
	//			enum B;
	//			enum C;
	//		}
	//	 }
	// }
	//
	//  container config { uses foo-config; }
	//  container state { uses foo-config; }
	//
	// will result in a single enumeration type (ModuleName_Config_Enabled) being
	// output when de-duplication is enabled.
	//
	// When it is disabled, two different enumerations (ModuleName_(State|Config)_Enabled)
	// will be output in the generated code.
	SkipEnumDeduplication bool
}

// TransformationOpts specifies transformations to the generated code with
// respect to the input schema.
type TransformationOpts struct {
	// CompressBehaviour specifies how the set of direct children of any
	// entry should determined. Specifically, whether compression is
	// enabled, and whether state fields in the schema should be excluded.
	CompressBehaviour genutil.CompressBehaviour
	// GenerateFakeRoot specifies whether an entity that represents the
	// root of the YANG schema tree should be generated in the generated
	// code.
	GenerateFakeRoot bool
	// FakeRootName specifies the name of the struct that should be generated
	// representing the root.
	FakeRootName string
	// ExcludeState specifies whether config false values should be
	// included in the generated code output. When set, all values that are
	// not writeable (i.e., config false) within the YANG schema and their
	// children are excluded from the generated code.
	ExcludeState bool
	// ShortenEnumLeafNames removes the module name from the name of
	// enumeration leaves.
	ShortenEnumLeafNames bool
}

// GoOpts stores Go specific options for the code generation library.
type GoOpts struct {
	// SchemaVarName is the name for the variable which stores the compressed
	// JSON schema in the generated Go code. JSON schema output is only
	// produced if the GenerateJSONSchema YANGCodeGenerator field is set to
	// true.
	SchemaVarName string
	// GoyangImportPath specifies the path that should be used in the generated
	// code for importing the goyang/pkg/yang package.
	GoyangImportPath string
	// YgotImportPath specifies the path to the ygot library that should be used
	// in the generated code.
	YgotImportPath string
	// YtypesImportPath specifies the path to ytypes library that should be used
	// in the generated code.
	YtypesImportPath string
	// GenerateRenameMethod specifies whether methods for renaming list entries
	// should be generated in the output Go code.
	GenerateRenameMethod bool
	// AddAnnotationFields specifies whether annotation fields should be added to
	// the generated structs. When set to true, a metadata field is added for each
	// struct, and for each field of each struct. Metadata field's names are
	// prefixed by the string specified in the AnnotationPrefix argument.
	AddAnnotationFields bool
	// AnnotationPrefix specifies the string which is prefixed to the name of
	// annotation fields. It defaults to Î›.
	AnnotationPrefix string
	// GenerateGetters specifies whether GetOrCreate* methods should be created
	// for struct pointer (YANG container) and map (YANG list) fields of generated
	// structs.
	GenerateGetters bool
	// GenerateDeleteMethod specifies whether Delete* methods should be created for
	// map (YANG list) fields of generated structs.
	GenerateDeleteMethod bool
	// GenerateAppendList specifies whether Append* methods should be created for
	// list fields of a struct. These methods take an input list member type, extract
	// the key and append the supplied value to the list.
	GenerateAppendMethod bool
	// GenerateLeafGetters specifies whether Get* methods should be created for
	// leaf fields of a struct. Care should be taken with this option since a Get
	// method returns the *Go* zero value for a particular entity if the field is
	// unset. This means that it is not possible for a caller of method to know
	// whether a field has been explicitly set to the zero value (i.e., an integer
	// field is set to 0), or whether the field was actually unset.
	GenerateLeafGetters bool
	// GNMIProtoPath specifies the path to the generated gNMI protobuf, which
	// is used to store the catalogue entries for generated modules.
	GNMIProtoPath string
	// IncludeModelData specifies whether gNMI ModelData messages should be generated
	// in the output code.
	IncludeModelData bool
}

// ProtoOpts stores Protobuf specific options for the code generation library.
type ProtoOpts struct {
	// BaseImportPath stores the root URL or path for imports that are
	// relative within the imported protobufs.
	BaseImportPath string
	// EnumPackageName stores the package name that should be used
	// for the package that defines enumerated types that are used
	// in multiple parts of the schema (identityrefs, and enumerations)
	// that fall within type definitions.
	EnumPackageName string
	// YwrapperPath is the path to the ywrapper.proto file that stores
	// the definition of the wrapper messages used to ensure that unset
	// fields can be distinguished from those that are set to their
	// default value. The path excluds the filename.
	YwrapperPath string
	// YextPath is the path to the yext.proto file that stores the
	// definition of the extension messages that are used to annotat the
	// generated protobuf messages.
	YextPath string
	// AnnotateSchemaPaths specifies whether the extensions defined in
	// yext.proto should be used to annotate schema paths into the output
	// protobuf file. See
	// https://github.com/openconfig/ygot/blob/master/docs/yang-to-protobuf-transformations-spec.md#annotation-of-schema-paths
	AnnotateSchemaPaths bool
	// AnnotateEnumNames specifies whether the extensions defined in
	// yext.proto should be used to annotate enum values with their
	// original YANG names in the output protobuf file.
	// See https://github.com/openconfig/ygot/blob/master/docs/yang-to-protobuf-transformations-spec.md#annotation-of-enums
	AnnotateEnumNames bool
	// NestedMessages indicates whether nested messages should be
	// output for the protobuf schema. If false, a separate package
	// is generated per package.
	NestedMessages bool
}

// NewYANGCodeGenerator returns a new instance of the YANGCodeGenerator
// struct to the calling function.
func NewYANGCodeGenerator(c *GeneratorConfig) *YANGCodeGenerator {
	cg := &YANGCodeGenerator{}

	if c != nil {
		cg.Config = *c
	}

	return cg
}

// yangEnum represents an enumerated type in YANG that is to be output in the
// Go code. The enumerated type may be a YANG 'identity' or enumeration.
type yangEnum struct {
	name  string      // name is the name of the enumeration or identity.
	entry *yang.Entry // entry is the yang.Entry corresponding to the enumerated value.
}

// GeneratedGoCode contains generated code snippets that can be processed by the calling
// application. The generated code is divided into two types of objects - both represented
// as a slice of strings: Structs contains a set of Go structures that have been generated,
// and Enums contains the code for generated enumerated types (corresponding to identities,
// or enumerated values within the YANG models for which code is being generated). Additionally
// the header with package comment of the generated code is returned in Header, along with the
// a slice of strings containing the packages that are required for the generated Go code to
// be compiled is returned.
//
// For schemas that contain enumerated types (identities, or enumerations), a code snippet is
// returned as the EnumMap field that allows the string values from the YANG schema to be resolved.
// The keys of the map are strings corresponding to the name of the generated type, with the
// map values being maps of the int64 identifier for each value of the enumeration to the name of
// the element, as used in the YANG schema.
type GeneratedGoCode struct {
	Structs      []GoStructCodeSnippet // Structs is the generated set of structs representing containers or lists in the input YANG models.
	Enums        []string              // Enums is the generated set of enum definitions corresponding to identities and enumerations in the input YANG models.
	CommonHeader string                // CommonHeader is the header that should be used for all output Go files.
	OneOffHeader string                // OneOffHeader defines the header that should be included in only one output Go file - such as package init statements.
	EnumMap      string                // EnumMap is a Go map that allows the YANG string values of enumerated types to be resolved.
	// JSONSchemaCode contains code defining a variable storing a serialised JSON schema for the
	// generated Go structs. When deserialised it consists of a map[string]*yang.Entry. The
	// entries are the root level yang.Entry definitions along with their corresponding
	// hierarchy (i.e., the yang.Entry for /foo contains /foo/... - all of foo's descendents).
	// Each yang.Entry which corresponds to a generated Go struct has two extra fields defined:
	//  - schemapath - the path to this entry within the schema. This is provided since the Path() method of
	//                 the deserialised yang.Entry does not return the path since the Parent pointer is not
	//                 populated.
	//  - structname - the name of the struct that was generated for the schema element.
	JSONSchemaCode string
	// RawJSONSchema stores the JSON document which is serialised and stored in JSONSchemaCode.
	// It is populated only if the StoreRawSchema YANGCodeGenerator boolean is set to true.
	RawJSONSchema []byte
	// EnumTypeMap is a Go map that allows YANG schemapaths to be mapped to reflect.Type values.
	EnumTypeMap string
}

// GeneratedProto3 stores a set of generated Protobuf packages.
type GeneratedProto3 struct {
	// Packages stores a map, keyed by the Protobuf package name, and containing the contents of the protobuf3
	// messages defined within the package. The calling application can write out the defined packages to the
	// files expected by the protoc tool.
	Packages map[string]Proto3Package
}

// Proto3Package stores the code for a generated protobuf3 package.
type Proto3Package struct {
	FilePath []string // FilePath is the path to the file that this package should be written to.
	Header   string   // Header is the header text to be used in the package.
	Messages []string // Messages is a slice of strings containing the set of messages that are within the generated package.
	Enums    []string // Enums is a slice of string containing the generated set of enumerations within the package.
}

const (
	// rootElementNodeName is the synthesised node name that is used for an
	// element that represents the root. Such an element is generated only
	// when the GenerateFakeRoot bool is set to true within the
	// YANGCodeGenerator instance used as a receiver.
	rootElementNodeName = "!fakeroot!"
	// defaultRootName is the default name for the root structure if GenerateFakeRoot is
	// set to true.
	defaultRootName = "device"
)

// generatedLanguage represents a language supported in this package.
type generatedLanguage int64

const (
	// golang indicates that Go code is being generated.
	golang generatedLanguage = iota
	// protobuf indicates that Protobuf messages are being generated.
	protobuf
)

// IsFakeRoot checks whether a given entry is the generated fake root.
func IsFakeRoot(e *yang.Entry) bool {
	return e != nil && e.Node != nil && e.Node.NName() == rootElementNodeName
}

func (cg *YANGCodeGenerator) GenerateGoCode(yangFiles, includePaths []string) (*GeneratedGoCode, util.Errors) {
	d := &DirectoryGenConfig{
		ParseOptions:          cg.Config.ParseOptions,
		TransformationOptions: cg.Config.TransformationOptions,
		EnumPrefix:            goEnumPrefix,
	}
	defns, errs := d.GetDefinitions(yangFiles, includePaths)
	if len(errs) != 0 {
		return nil, errs
	}
	// Code generation begins
	var codegenErr util.Errors
	commonHeader, oneoffHeader, err := writeGoHeader(yangFiles, includePaths, cg.Config, defns.RootName(), defns.ModelData)
	if err != nil {
		return nil, util.AppendErr(codegenErr, err)
	}

	// Alphabetically order directories to produce deterministic output.
	orderedDirNames, dirNameMap, err := GetOrderedDirectories(defns.Directories)
	if err != nil {
		return nil, util.AppendErr(codegenErr, err)
	}

	usedEnumeratedTypes := map[string]bool{}
	definedUnionTypes := map[string]map[string]*goUnionInterface{}
	generatedUnions := map[string]bool{}
	enumTypeMap := map[string][]string{}
	structSnippets := []GoStructCodeSnippet{}

	isBuiltInType := func(fType string) bool {
		_, ok := validGoBuiltinTypes[fType]
		return ok
	}

	// Range through the directories to find the enumerated and union types that we
	// need. We have to do this without writing the code out, since we require some
	// knowledge of these types to do code generation along with the values.
	for _, directoryName := range orderedDirNames {
		thisDir := dirNameMap[directoryName]
		// We need to find all the enumerated types that are in use within the schema
		// such that we do not output types that are not used (which would potentially create a lot
		// of extraneous code for included modules that we aren't generating for), and to create
		// the map of types that might exist within the generated code for unmarshalling.
		fieldTypes := defns.LeafTypes[thisDir.Entry.Path()]

		fns := []string{}
		for n := range thisDir.Fields {
			fns = append(fns, n)
		}
		sort.Strings(fns)

		for _, fn := range fns {
			f := thisDir.Fields[fn]
			fType, ok := fieldTypes[f.Name]
			if !ok {
				codegenErr = util.AppendErr(codegenErr, fmt.Errorf("cannot find field %s in directory %s", f.Name, directoryName))
				continue
			}
			schemaPath := util.SchemaTreePathNoModule(f)
			switch {
			case fType == nil:
				// This is a directory, so we continue.
				continue
			case fType.IsEnumeratedValue:
				usedEnumeratedTypes[fType.NativeType] = true
				enumTypeMap[schemaPath] = []string{fType.NativeType}
			case len(fType.UnionTypes) > 1:
				if v := definedUnionTypes[directoryName][fType.NativeType]; v != nil {
					continue
				}

				unionIntf := &goUnionInterface{
					Name:           fType.NativeType,
					Types:          map[string]string{},
					LeafPath:       f.Path(),
					ParentReceiver: thisDir.Name,
				}

				for ut := range fType.UnionTypes {
					tn := yang.CamelCase(ut)
					if ut == "interface{}" {
						tn = "Interface"
					}
					unionIntf.Types[tn] = ut
					unionIntf.TypeNames = append(unionIntf.TypeNames, ut)

					if !isBuiltInType(ut) {
						// Types that are in unions once they have been resolved are always
						// enumerated types.
						usedEnumeratedTypes[ut] = true
						if enumTypeMap[schemaPath] == nil {
							enumTypeMap[schemaPath] = []string{}
						}
						enumTypeMap[schemaPath] = append(enumTypeMap[schemaPath], ut)
					}
				}

				sort.Strings(unionIntf.TypeNames)
				if definedUnionTypes[directoryName] == nil {
					definedUnionTypes[directoryName] = map[string]*goUnionInterface{}
				}
				definedUnionTypes[directoryName][fType.NativeType] = unionIntf
			}
		}

		structOut, errs := writeGoStruct(thisDir, defns, cg.Config.GoOptions, cg.Config.GenerateJSONSchema)
		if errs != nil {
			codegenErr = util.AppendErrs(codegenErr, errs)
			continue
		}

		// write the union types out
		var b bytes.Buffer
		tn := []string{}
		for k := range definedUnionTypes[directoryName] {
			tn = append(tn, k)
		}
		sort.Strings(tn)
		for _, n := range tn {
			if !generatedUnions[n] {
				if err := generateUnionCode(&b, definedUnionTypes[directoryName][n]); err != nil {
					codegenErr = util.AppendErr(codegenErr, err)
					continue
				}
				generatedUnions[n] = true
			}
			if err := generateUnionHelper(&b, definedUnionTypes[directoryName][n]); err != nil {
				codegenErr = util.AppendErr(codegenErr, err)
				continue
			}
		}
		structOut.Interfaces = b.String()

		structSnippets = append(structSnippets, structOut)
	}

	genum, err := writeGoEnumeratedTypes(defns.Enums, usedEnumeratedTypes)

	var rawSchema []byte
	var jsonSchema string
	var enumTypeMapCode string
	if cg.Config.GenerateJSONSchema {
		var err error
		// TODO(robjs): Move building the schema tree internally to generating directory definitions, since this will
		// allow a cleaner split of not returning yang.Entry fields to the downstream caller.
		rawSchema, err = defns.SchemaTree()
		if err != nil {
			util.AppendErr(codegenErr, fmt.Errorf("error marshalling JSON schema: %v", err))
		}

		if rawSchema != nil {
			if jsonSchema, err = writeGoSchema(rawSchema, cg.Config.GoOptions.SchemaVarName); err != nil {
				util.AppendErr(codegenErr, err)
			}
		}

		if enumTypeMapCode, err = generateEnumTypeMap(enumTypeMap); err != nil {
			util.AppendErr(codegenErr, err)
		}
	}

	// Return any errors that were encountered during code generation.
	if len(codegenErr) != 0 {
		return nil, codegenErr
	}

	return &GeneratedGoCode{
		CommonHeader:   commonHeader,
		OneOffHeader:   oneoffHeader,
		Structs:        structSnippets,
		Enums:          genum.enums,
		EnumMap:        genum.valMap,
		JSONSchemaCode: jsonSchema,
		RawJSONSchema:  rawSchema,
		EnumTypeMap:    enumTypeMapCode,
	}, nil

}

type enumGeneratedCode struct {
	enums  []string
	valMap string
}

func writeGoEnumeratedTypes(enums map[string]*EnumeratedType, usedEnums map[string]bool) (*enumGeneratedCode, error) {
	orderedEnumNames := []string{}
	for _, e := range enums {
		orderedEnumNames = append(orderedEnumNames, e.Name)
	}
	sort.Strings(orderedEnumNames)

	enumValMap := map[string]map[int64]ygot.EnumDefinition{}
	enumSnippets := []string{}

	for _, en := range orderedEnumNames {
		e := enums[en]
		if _, ok := usedEnums[fmt.Sprintf("%s%s", goEnumPrefix, e.Name)]; !ok {
			// Don't output enumerated types that are not used in the code that we have
			// such that we don't create generated code for a large array of types that
			// just happen to be in modules that were included by other modules.
			continue
		}
		enumOut, err := writeGoEnum(e)
		if err != nil {
			return nil, err
		}
		enumSnippets = append(enumSnippets, enumOut)
		enumValMap[e.Name] = e.YANGValues
	}

	// Write the map of string -> int -> YANG enum name string out.
	vmap, err := writeGoEnumMap(enumValMap)
	if err != nil {
		return nil, err
	}

	return &enumGeneratedCode{
		enums:  enumSnippets,
		valMap: vmap,
	}, nil
}

type EnumeratedType struct {
	Name       string
	CodeValues map[int64]string
	YANGValues map[int64]ygot.EnumDefinition
}

type Definitions struct {
	transformationOpts TransformationOpts
	Directories        map[string]*Directory
	LeafTypes          map[string]map[string]*MappedType
	Enums              map[string]*EnumeratedType
	ModelData          []*gpb.ModelData
	MappedPaths        map[string][][]string
	ParsedModules      []*yang.Entry
}

func (d *Definitions) SchemaTree() ([]byte, error) {
	rawSchema, err := buildJSONTree(d.ParsedModules, d.Directories, d.RootEntry(), d.transformationOpts.CompressBehaviour.CompressEnabled())
	if err != nil {
		return nil, err
	}
	return rawSchema, nil
}

func (d *Definitions) RootDirectory() *Directory {
	if !d.transformationOpts.GenerateFakeRoot {
		return nil
	}
	v := d.Directories[fmt.Sprintf("/%s", resolveRootName(d.transformationOpts.FakeRootName, defaultRootName, d.transformationOpts.GenerateFakeRoot))]
	return v
}

func (d *Definitions) RootEntry() *yang.Entry {
	rd := d.RootDirectory()
	if rd == nil {
		return nil
	}
	return rd.Entry
}

func (d *Definitions) RootName() string {
	rd := d.RootDirectory()
	if rd == nil {
		return ""
	}
	return rd.Name
}

// GetDirectoriesAndLeafTypes parses YANG files and returns two path-keyed
// maps. The first contains Directory entries that is the intermediate
// representation used by ygen for subsequent code generation, and the second
// contains the *MappedType for each field of the same corresponding Directory
// entries, with non-leafs having a nil value. This representation may be
// useful to external code generation libraries that make use of such
// information, e.g. if their output code depends on a ygen-generated type.
// yangFiles is a slice of strings containing the path to a set of YANG files
// which contain YANG modules, includePaths is slice of strings which specifies
// the set of paths that are to be searched for associated models (e.g.,
// modules that are included by the specified set of modules, or submodules of
// those modules). Any errors encountered during code generation are returned.
func (dcg *DirectoryGenConfig) GetDirectoriesAndLeafTypes(yangFiles, includePaths []string) (map[string]*Directory, map[string]map[string]*MappedType, util.Errors) {
	g, errs := dcg.GetDefinitions(yangFiles, includePaths)
	return g.Directories, g.LeafTypes, errs
}

func (dcg *DirectoryGenConfig) GetDefinitions(yangFiles, includePaths []string) (*Definitions, util.Errors) {
	cg := &GeneratorConfig{ParseOptions: dcg.ParseOptions, TransformationOptions: dcg.TransformationOptions}
	// Extract the entities to be mapped into structs and enumerations in the output
	// Go code. Extract the schematree from the modules provided such that it can be
	// used to reference entities within the tree.
	mdef, errs := mappedDefinitions(yangFiles, includePaths, cg)
	if errs != nil {
		return nil, errs
	}

	dirsToProcess := map[string]*yang.Entry(mdef.directoryEntries)

	enumSet, genEnums, errs := findEnumSet(mdef.enumEntries, cg.TransformationOptions.CompressBehaviour.CompressEnabled(), false, cg.ParseOptions.SkipEnumDeduplication, cg.TransformationOptions.ShortenEnumLeafNames, dcg.EnumPrefix)
	if errs != nil {
		return nil, errs
	}

	// TODO(robjs): refactor this state type to be generic across generated languages.
	// Store the returned schematree and enumSet within the state for this code generation.
	gogen := newGoGenState(mdef.schematree, enumSet)
	directoryMap, errs := gogen.buildDirectoryDefinitions(dirsToProcess, cg.TransformationOptions.CompressBehaviour, cg.TransformationOptions.GenerateFakeRoot, cg.ParseOptions.SkipEnumDeduplication, cg.TransformationOptions.ShortenEnumLeafNames)
	if errs != nil {
		return nil, errs
	}

	// Alphabetically order directories to produce deterministic output.
	orderedDirNames, dirNameMap, err := GetOrderedDirectories(directoryMap)
	if err != nil {
		return nil, util.AppendErr(errs, err)
	}

	nodeYANGPath := make(map[string][][]string)
	addMapPaths := func(parent *Directory, fieldName string) error {
		// TODO(robjs): make the call here handle absolute paths.
		np, err := findMapPaths(parent, fieldName, dcg.TransformationOptions.CompressBehaviour.CompressEnabled(), false)
		if err != nil {
			return fmt.Errorf("cannot find YANG paths to map %s field %s to, %v", parent.Entry.Path(), fieldName, err)
		}
		nodeYANGPath[parent.Fields[fieldName].Path()] = np
		return nil
	}
	// Populate map of leaf types for returning, and a combined map of paths
	// that fields map to within the YANG schema.
	leafTypeMap := make(map[string]map[string]*MappedType, len(directoryMap))

	for _, directoryName := range orderedDirNames {
		dir := dirNameMap[directoryName]
		path := dir.Entry.Path()

		leafTypeMap[path] = make(map[string]*MappedType, len(dir.Fields))
		// Alphabetically order fields to produce deterministic output.
		for _, fieldName := range GetOrderedFieldNames(dir) {
			field := dir.Fields[fieldName]

			// Populate the paths that we are going to map this field to in the YANG schema
			// to allow for path annotation.
			if err := addMapPaths(dir, fieldName); err != nil {
				errs = append(errs, err)
				continue
			}

			if isLeaf := field.IsLeaf() || field.IsLeafList(); isLeaf {
				mtype, err := gogen.yangTypeToGoType(resolveTypeArgs{yangType: field.Type, contextEntry: field}, dcg.TransformationOptions.CompressBehaviour.CompressEnabled(), cg.ParseOptions.SkipEnumDeduplication, cg.TransformationOptions.ShortenEnumLeafNames)
				if err != nil {
					errs = util.AppendErr(errs, err)
					continue
				}
				leafTypeMap[path][fieldName] = mtype
			} else {
				leafTypeMap[path][fieldName] = nil
			}
		}
	}

	enumDefinitionMap := make(map[string]*EnumeratedType, len(genEnums))
	// Populate map of enumerated types to return.
	for _, enum := range genEnums {
		// TODO(robjs): refactor this code to allow a generic function to be supplied
		// here.
		e, err := enumDefinition(enum, safeGoEnumeratedValueName)
		if err != nil {
			errs = append(errs, err)
		}
		enumDefinitionMap[e.Name] = e
	}

	if errs != nil {
		return nil, errs
	}

	return &Definitions{
		transformationOpts: dcg.TransformationOptions,
		Directories:        directoryMap,
		LeafTypes:          leafTypeMap,
		Enums:              enumDefinitionMap,
		ModelData:          mdef.modelData,
		MappedPaths:        nodeYANGPath,
		ParsedModules:      mdef.modules,
	}, nil
}

func enumDefinition(enum *yangEnum, safeNameFn func(string) string) (*EnumeratedType, error) {
	// initialised to be UNSET, such that it is possible to determine that the enumerated value
	// was not modified.
	values := map[int64]string{
		0: "UNSET",
	}

	// origValues stores the original set of value names, these are not maintained to be
	// Go-safe, and are rather used to map back to the original schema values if required.
	// 0 is not populated within this map, such that the values can be used to check whether
	// there was a valid entry in the original schema. The value is stored as a ygot
	// EnumDefinition, which stores the name, and in the case of identity values, the
	// module within which the identity was defined.
	origValues := map[int64]ygot.EnumDefinition{}

	switch {
	case enum.entry.Type.IdentityBase != nil:
		// The inputEnum corresponds to an identityref - hence the values are defined
		// based on the values that the identity has. Since there is no explicit ordering
		// in an identity, then we go through and put the values in alphabetical order in
		// order to avoid reordering during code generation of the same entity.
		valNames := []string{}
		valLookup := map[string]*yang.Identity{}
		for _, v := range enum.entry.Type.IdentityBase.Values {
			valNames = append(valNames, v.Name)
			valLookup[v.Name] = v
		}
		sort.Strings(valNames)

		for i, v := range valNames {
			values[int64(i)+1] = safeNameFn(v)
			origValues[int64(i)+1] = ygot.EnumDefinition{
				Name:           v,
				DefiningModule: genutil.ParentModuleName(valLookup[v]),
			}
		}
	default:
		// The remaining enumerated types are all represented as an Enum type within the
		// Goyang entry construct. The values are accessed in a map keyed by an int64
		// and with a value of the name of the enumerated value - retrieved via ValueMap().
		for i, value := range enum.entry.Type.Enum.ValueMap() {
			values[i+1] = safeNameFn(value)
			origValues[i+1] = ygot.EnumDefinition{Name: value}
		}
	}

	return &EnumeratedType{
		Name:       enum.name,
		CodeValues: values,
		YANGValues: origValues,
	}, nil
}

// GenerateProto3 generates Protobuf 3 code for the input set of YANG files.
// The YANG schemas for which protobufs are to be created is supplied as the
// yangFiles argument, with included modules being searched for in includePaths.
// It returns a GeneratedProto3 struct containing the messages that are to be
// output, along with any associated values (e.g., enumerations).
func (cg *YANGCodeGenerator) GenerateProto3(yangFiles, includePaths []string) (*GeneratedProto3, util.Errors) {

	basePackageName := cg.Config.PackageName
	if basePackageName == "" {
		basePackageName = DefaultBasePackageName
	}
	enumPackageName := cg.Config.ProtoOptions.EnumPackageName
	if enumPackageName == "" {
		enumPackageName = DefaultEnumPackageName
	}
	ywrapperPath := cg.Config.ProtoOptions.YwrapperPath
	if ywrapperPath == "" {
		ywrapperPath = DefaultYwrapperPath
	}
	yextPath := cg.Config.ProtoOptions.YextPath
	if yextPath == "" {
		yextPath = DefaultYextPath
	}

	mdef, errs := mappedDefinitions(yangFiles, includePaths, &cg.Config)
	if errs != nil {
		return nil, errs
	}
	enumSet, penums, errs := findEnumSet(mdef.enumEntries, cg.Config.TransformationOptions.CompressBehaviour.CompressEnabled(), true, cg.Config.ParseOptions.SkipEnumDeduplication, cg.Config.TransformationOptions.ShortenEnumLeafNames, fmt.Sprintf("%s.%s.", basePackageName, enumPackageName))
	if errs != nil {
		return nil, errs
	}
	protogen := newProtoGenState(mdef.schematree, enumSet)

	protoEnums, errs := writeProtoEnums(penums, cg.Config.ProtoOptions.AnnotateEnumNames)
	if errs != nil {
		return nil, errs
	}

	protoMsgs, errs := protogen.buildDirectoryDefinitions(mdef.directoryEntries, cg.Config.TransformationOptions.CompressBehaviour)
	if errs != nil {
		return nil, errs
	}

	genProto := &GeneratedProto3{
		Packages: map[string]Proto3Package{},
	}

	// yerr stores errors encountered during code generation.
	var yerr util.Errors

	// pkgImports lists the imports that are required for the package that is being
	// written out.
	pkgImports := map[string]map[string]interface{}{}

	// Ensure that the slice of messages returned is in a deterministic order by
	// sorting the message paths. We use the path rather than the name as the
	// proto message name may not be unique.
	msgPaths := []string{}
	msgMap := map[string]*Directory{}
	for _, m := range protoMsgs {
		k := strings.Join(m.Path, "/")
		msgPaths = append(msgPaths, k)
		msgMap[k] = m
	}
	sort.Strings(msgPaths)

	// Only create the enums package if there are enums that are within the schema.
	if len(protoEnums) > 0 {
		// Sort the set of enumerations so that they are deterministically output.
		sort.Strings(protoEnums)
		fp := []string{basePackageName, enumPackageName, fmt.Sprintf("%s.proto", enumPackageName)}
		genProto.Packages[fmt.Sprintf("%s.%s", basePackageName, enumPackageName)] = Proto3Package{
			FilePath: fp,
			Enums:    protoEnums,
		}
	}

	for _, n := range msgPaths {
		m := msgMap[n]

		genMsg, errs := writeProto3Msg(m, protoMsgs, protogen, &protoMsgConfig{
			compressPaths:       cg.Config.TransformationOptions.CompressBehaviour.CompressEnabled(),
			basePackageName:     basePackageName,
			enumPackageName:     enumPackageName,
			baseImportPath:      cg.Config.ProtoOptions.BaseImportPath,
			annotateSchemaPaths: cg.Config.ProtoOptions.AnnotateSchemaPaths,
			annotateEnumNames:   cg.Config.ProtoOptions.AnnotateEnumNames,
			nestedMessages:      cg.Config.ProtoOptions.NestedMessages,
		})

		if errs != nil {
			yerr = util.AppendErrs(yerr, errs)
			continue
		}

		// Check whether any messages were required for this schema element, writeProto3Msg can
		// return nil if nested messages were being produced, and the message was encapsulated
		// in another message.
		if genMsg == nil {
			continue
		}

		if genMsg.PackageName == "" {
			genMsg.PackageName = basePackageName
		} else {
			genMsg.PackageName = fmt.Sprintf("%s.%s", basePackageName, genMsg.PackageName)
		}

		if pkgImports[genMsg.PackageName] == nil {
			pkgImports[genMsg.PackageName] = map[string]interface{}{}
		}
		addNewKeys(pkgImports[genMsg.PackageName], genMsg.RequiredImports)

		// If the package does not already exist within the generated proto3
		// output, then create it within the package map. This allows different
		// entries in the msgNames set to fall within the same package.
		tp, ok := genProto.Packages[genMsg.PackageName]
		if !ok {
			genProto.Packages[genMsg.PackageName] = Proto3Package{
				FilePath: protoPackageToFilePath(genMsg.PackageName),
				Messages: []string{},
			}
			tp = genProto.Packages[genMsg.PackageName]
		}
		tp.Messages = append(tp.Messages, genMsg.MessageCode)
		genProto.Packages[genMsg.PackageName] = tp
	}

	for n, pkg := range genProto.Packages {
		h, err := writeProto3Header(proto3Header{
			PackageName:            n,
			Imports:                stringKeys(pkgImports[n]),
			SourceYANGFiles:        yangFiles,
			SourceYANGIncludePaths: includePaths,
			CompressPaths:          cg.Config.TransformationOptions.CompressBehaviour.CompressEnabled(),
			CallerName:             cg.Config.Caller,
			YwrapperPath:           ywrapperPath,
			YextPath:               yextPath,
		})
		if err != nil {
			yerr = util.AppendErrs(yerr, errs)
			continue
		}
		pkg.Header = h
		genProto.Packages[n] = pkg
	}

	if yerr != nil {
		return nil, yerr
	}

	return genProto, nil
}

// processModules takes a list of the filenames of YANG modules (yangFiles),
// and a list of paths in which included modules or submodules may be found,
// and returns a processed set of yang.Entry pointers which correspond to the
// generated code for the modules. If errors are returned during the Goyang
// processing of the modules, these errors are returned.
func processModules(yangFiles, includePaths []string, options yang.Options) ([]*yang.Entry, util.Errors) {
	// Append the includePaths to the Goyang path variable, this ensures
	// that where a YANG module uses an 'include' statement to reference
	// another module, then Goyang can find this module to process.
	for _, path := range includePaths {
		yang.AddPath(path)
	}

	// Propagate the options for the YANG library through to the parsing
	// code - this allows the calling binary to specify characteristics
	// of the YANG in a manner that we are transparent to.
	yang.ParseOptions = options

	// Initialise the set of YANG modules within the Goyang parsing package.
	moduleSet := yang.NewModules()

	var errs util.Errors
	for _, name := range yangFiles {
		errs = util.AppendErr(errs, moduleSet.Read(name))
	}

	if errs != nil {
		return nil, errs
	}

	if errs := moduleSet.Process(); errs != nil {
		return nil, errs
	}

	// Deduplicate the modules that are to be processed.
	var modNames []string
	mods := make(map[string]*yang.Module)
	for _, m := range moduleSet.Modules {
		if mods[m.Name] == nil {
			mods[m.Name] = m
			modNames = append(modNames, m.Name)
		}
	}

	// Process the ASTs that have been generated for the modules using the Goyang ToEntry
	// routines.
	entries := []*yang.Entry{}
	for _, modName := range modNames {
		entries = append(entries, yang.ToEntry(mods[modName]))
	}
	return entries, nil
}

// mappedYANGDefinitions stores the entities extracted from a YANG schema that are to be mapped to
// entities within the generated code, or can be used to look up entities within the YANG schema.
type mappedYANGDefinitions struct {
	// directoryEntries is the set of entities that are to be mapped to directories (e.g.,
	// Go structs, proto messages) in the generated code. The map is keyed by the string
	// path to the directory in the YANG schema.
	directoryEntries map[string]*yang.Entry
	// enumEntries is the set of entities that contain an enumerated type within the input
	// YANG and are to be mapped to enumerated types in the output code. This consists of
	// leaves that are of type enumeration, identityref, or unions that contain either of
	// these types. The map is keyed by the string path to the entry in the YANG schema.
	enumEntries map[string]*yang.Entry
	// schematree is a copy of the YANG schema tree, containing only leaf
	// entries, such that schema paths can be referenced.
	schematree *schemaTree
	// modules is the set of parsed YANG modules that are being processed as part of the
	// code generatio, expressed as a slice of yang.Entry pointers.
	modules []*yang.Entry
	// modelData stores the details of the set of modules that were parsed to produce
	// the code. It is optionally returned in the generated code.
	modelData []*gpb.ModelData
}

// mappedDefinitions finds the set of directory and enumeration entities
// that are mapped to objects within output code in a language agnostic manner.
// It takes:
//	- yangFiles: an input set of YANG schema files and the paths that
//	- includePaths: the set of paths that are to be searched for included or
//	  imported YANG modules.
//	- cfg: the current generator's configuration.
// It returns a mappedYANGDefinitions struct populated with the directory, enum
// entries in the input schemas as well as the calculated schema tree.
func mappedDefinitions(yangFiles, includePaths []string, cfg *GeneratorConfig) (*mappedYANGDefinitions, util.Errors) {
	modules, errs := processModules(yangFiles, includePaths, cfg.ParseOptions.YANGParseOptions)
	if errs != nil {
		return nil, errs
	}

	// Build a map of excluded modules to simplify lookup.
	excluded := map[string]bool{}
	for _, e := range cfg.ParseOptions.ExcludeModules {
		excluded[e] = true
	}

	// Extract the entities that are eligible to have code generated for
	// them from the modules that are provided as an argument.
	dirs := map[string]*yang.Entry{}
	enums := map[string]*yang.Entry{}
	var rootElems, treeElems []*yang.Entry
	for _, module := range modules {
		errs = append(errs, findMappableEntities(module, dirs, enums, cfg.ParseOptions.ExcludeModules, cfg.TransformationOptions.CompressBehaviour.CompressEnabled(), modules)...)
		if module == nil {
			errs = append(errs, errors.New("found a nil module in the returned module set"))
			continue
		}

		for _, e := range module.Dir {
			if !excluded[module.Name] {
				rootElems = append(rootElems, e)
			}
			treeElems = append(treeElems, e)
		}
	}
	if errs != nil {
		return nil, errs
	}

	// Build the schematree for the modules provided - we build for all of the
	// root elements, since we might need to reference a part of the schema that
	// we are not outputting for leafref lookups.
	st, err := buildSchemaTree(treeElems)
	if err != nil {
		return nil, []error{err}
	}

	// If we were asked to generate a fake root entity, then go and find the top-level entities that
	// we were asked for.
	if cfg.TransformationOptions.GenerateFakeRoot {
		if err := createFakeRoot(dirs, rootElems, cfg.TransformationOptions.FakeRootName, cfg.TransformationOptions.CompressBehaviour.CompressEnabled()); err != nil {
			return nil, []error{err}
		}
	}

	// For all non-excluded modules, we store these to be
	// used as the schema tree.
	ms := []*yang.Entry{}
	for _, m := range modules {
		if _, ok := excluded[m.Name]; !ok {
			ms = append(ms, m)
		}
	}

	modelData, err := util.FindModelData(modules)
	if err != nil {
		return nil, util.NewErrs(fmt.Errorf("cannot extract model data, %v", err))
	}

	return &mappedYANGDefinitions{
		directoryEntries: dirs,
		enumEntries:      enums,
		schematree:       st,
		modules:          ms,
		modelData:        modelData,
	}, nil
}

// mappableLeaf determines whether the yang.Entry e is leaf with an
// enumerated value, such that the referenced enumerated type (enumeration or
// identity) should have code generated for it. If it is an enumerated type
// the leaf is returned.
func mappableLeaf(e *yang.Entry) *yang.Entry {
	if e.Type == nil {
		// If the type of the leaf is nil, then this is not a valid
		// leaf within the schema - since goyang must populate the
		// entry Type.
		// TODO(robjs): Add this as an error case that can be handled by
		// the caller directly.
		log.Warningf("got unexpected nil value type for leaf %s (%s), entry: %v", e.Name, e.Path(), e)
		return nil
	}

	var types []*yang.YangType
	switch {
	case util.IsEnumeratedType(e.Type):
		// Handle the case that this leaf is an enumeration or identityref itself.
		// This also handles cases where the leaf is a typedef that is an enumeration
		// or identityref, since the util.IsEnumeratedType check does not use the name of the
		// type.
		types = append(types, e.Type)
	case util.IsUnionType(e.Type):
		// Check for leaves that include a union that itself
		// includes an identityref or enumerated value.
		types = append(types, util.EnumeratedUnionTypes(e.Type.Type)...)
	}

	if types != nil {
		return e
	}
	return nil
}

// findMappableEntities finds the descendants of a yang.Entry (e) that should be mapped in
// the generated code. The descendants that represent directories are appended to the dirs
// map (keyed by the schema path). Those that represent enumerated types (identityref, enumeration,
// unions containing these types, or typedefs containing these types) are appended to the
// enums map, which is again keyed by schema path. If any child of the entry is in a module
// defined in excludeModules, it is skipped. If compressPaths is set to true, then names are
// mapped with path compression enabled. The set of modules that the current code generation
// is processing is specified by the modules slice. This function returns slice of errors
// encountered during processing.
func findMappableEntities(e *yang.Entry, dirs map[string]*yang.Entry, enums map[string]*yang.Entry, excludeModules []string, compressPaths bool, modules []*yang.Entry) util.Errors {
	// Skip entities who are defined within a module that we have been instructed
	// not to generate code for.
	for _, s := range excludeModules {
		for _, m := range modules {
			if m.Name == s && m.Namespace().Name == e.Namespace().Name {
				return nil
			}
		}
	}

	var errs util.Errors
	for _, ch := range util.Children(e) {
		switch {
		case ch.IsLeaf(), ch.IsLeafList():
			// Leaves are not mapped as directories so do not map them unless we find
			// something that will be an enumeration - so that we can deal with this
			// as a top-level code entity.
			if e := mappableLeaf(ch); e != nil {
				enums[ch.Path()] = e
			}
		case util.IsConfigState(ch) && compressPaths:
			// If this is a config or state container and we are compressing paths
			// then we do not want to map this container - but we do want to map its
			// children.
			errs = util.AppendErrs(errs, findMappableEntities(ch, dirs, enums, excludeModules, compressPaths, modules))
		case util.HasOnlyChild(ch) && util.Children(ch)[0].IsList() && compressPaths:
			// This is a surrounding container for a list, and we are compressing
			// paths, so we don't want to map it but again we do want to map its
			// children.
			errs = util.AppendErrs(errs, findMappableEntities(ch, dirs, enums, excludeModules, compressPaths, modules))
		case util.IsChoiceOrCase(ch):
			// Don't map for a choice or case node itself, and rather skip over it.
			// However, we must walk each branch to find the first container that
			// exists there (if one does) to provide a mapping.
			nonchoice := util.FindFirstNonChoiceOrCase(ch)
			for _, gch := range nonchoice {
				// The first entry that is not a choice or case could be a leaf
				// so we need to check whether it is an enumerated leaf that
				// should have code generated for it.
				if gch.IsLeaf() || gch.IsLeafList() {
					if e := mappableLeaf(gch); e != nil {
						enums[e.Path()] = e
					}
					continue
				}

				if gch.IsContainer() || gch.IsList() {
					dirs[fmt.Sprintf("%s/%s", ch.Parent.Path(), gch.Name)] = gch
				}
				errs = util.AppendErrs(errs, findMappableEntities(gch, dirs, enums, excludeModules, compressPaths, modules))
			}
		case ch.IsContainer(), ch.IsList():
			dirs[ch.Path()] = ch
			// Recurse down the tree.
			errs = util.AppendErrs(errs, findMappableEntities(ch, dirs, enums, excludeModules, compressPaths, modules))
		case ch.Kind == yang.AnyDataEntry:
			continue
		default:
			errs = util.AppendErr(errs, fmt.Errorf("unknown type of entry %v in findMappableEntities for %s", e.Kind, e.Path()))
		}
	}
	return errs
}

// findRootEntries finds the entities that are at the root of the YANG schema tree,
// and returns them.
func findRootEntries(structs map[string]*yang.Entry, compressPaths bool) map[string]*yang.Entry {
	rootEntries := map[string]*yang.Entry{}
	for n, s := range structs {
		pp := strings.Split(s.Path(), "/")
		switch len(pp) {
		case 3:
			// Find all containers and lists that have a path of
			// the form /module/entity-name regardless of whether
			// when compression is enabled. In the case that we
			// are compressing, then all invalid elements have
			// already been compressed out of the schema by this
			// stage.
			if s.IsContainer() || s.IsList() {
				rootEntries[n] = s
			}
		case 4:
			// If schema path compression is enabled then we need
			// to find entities that might be one level deeper in the
			// tree, for example, the /interfaces/interface list.
			// Since we never expect a top-level 'state' or 'config'
			// container, then it is only such lists that must be
			// identified.
			if compressPaths && s.IsList() {
				rootEntries[n] = s
			}
		}
	}
	return rootEntries
}

// MakeFakeRoot creates and returns a fakeroot *yang.Entry with rootName as its
// name. It has an empty, but initialized Dir.
func MakeFakeRoot(rootName string) *yang.Entry {
	return &yang.Entry{
		Name: rootName,
		Kind: yang.DirectoryEntry,
		Dir:  map[string]*yang.Entry{},
		// Create a fake node that corresponds to the fake root, this
		// ensures that we can match the element elsewhere.
		Node: &yang.Value{
			Name: rootElementNodeName,
		},
	}
}

// createFakeRoot extracts the entities that are at the root of the YANG schema tree,
// which otherwise would have no parent in the generated structs, and appends them to
// a synthesised root element. Such entries are extracted from the supplied structs
// if they are lists or containers, or from the rootElems supplied if they are leaves
// or leaf-lists. In the case that the code generation is compressing the
// YANG schema, list entries that are two levels deep (e.g., /interfaces/interface) are
// also appended to the synthesised root entity (i.e., in this case the root element
// has a map entry named 'Interface', and the corresponding NewInterface() method.
// Takes the directories that are identified at the root (dirs), the elements found
// at the root (rootElems, such that non-directories can be mapped), and a string
// indicating the root name.
func createFakeRoot(structs map[string]*yang.Entry, rootElems []*yang.Entry, rootName string, compressPaths bool) error {
	if rootName == "" {
		rootName = defaultRootName
	}

	fakeRoot := MakeFakeRoot(rootName)

	for _, s := range findRootEntries(structs, compressPaths) {
		if e, ok := fakeRoot.Dir[s.Name]; ok {
			return fmt.Errorf("duplicate entry %s at the root: exists: %v, new: %v", s.Name, e.Path(), s.Path())
		}
		fakeRoot.Dir[s.Name] = s
	}

	for _, l := range rootElems {
		if l.IsLeaf() || l.IsLeafList() {
			fakeRoot.Dir[l.Name] = l
		}
	}

	// Append the synthesised root entry to the list of structs for which
	// code should be generated.
	structs["/"] = fakeRoot
	return nil
}
