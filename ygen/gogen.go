// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ygen

import (
	"bytes"
	"fmt"
	"reflect"
	"sort"
	"strings"
	"text/template"

	log "github.com/golang/glog"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
)

const (
	// defaultSchemaVarName is the default variable name that should
	// be used for the output JSON schema when stored. It can be overridden
	// by specifying a name within the GoOptions field of the YANGCodeGenerator
	// instance used for code generation.
	defaultSchemaVarName string = "ySchema"
	// defaultPackageName specifies the default name that should be
	// used for the generated Go package.
	defaultPackageName string = "ocstructs"
	// DefaultYgotImportPath is the default import path used for the ygot library
	// in the generated code.
	DefaultYgotImportPath string = "github.com/openconfig/ygot/ygot"
	// DefaultYtypesImportPath is the default import path used for the ytypes library
	// in the generated code.
	DefaultYtypesImportPath string = "github.com/openconfig/ygot/ytypes"
	// DefaultGoyangImportPath is the default path for the goyang/pkg/yang library that
	// is used in the generated code.
	DefaultGoyangImportPath string = "github.com/openconfig/goyang/pkg/yang"
)

// The methods in this file take the structs that have been generated by
// processing the goyang output, and generate the Go code snippets that
// will be output to the caller of the library.
//
// These functions break down into two different sets:
//	1) Those that generate output for containers or lists, which are both
//	   Go structs.
//	2) Those that generate output for enumerated entities.
//
// For structs, some additional output is also generated. For example, if a struct
// storing the characteristics of a YANG container A is input, then the resulting
// goStructCodeSnippet struct will contain the definition of the Go struct
// used to create an instance of A in the structDef string. The listKeys string
// contains any structs that are used as the key to a multi-key list. The methods
// string contains any functions that are generated with A as the receiver.
//
// As a worked example, if we have the following YANG input:
//
//	container A {
//		list B {
//			key "one two";
//			leaf one { type string; }
//			leaf two { type int8; }
//		}
//	}
//
// The resulting generated Go code consists of:
//
//	type A struct {
//		B map[A_B_Key]*A_B
//	}
//
// Where A_B is the struct that will be created for the list A/B, and A_B_Key is
// a struct created specifically to key the map for list B, based on it having
// multiple keys.
//
// The functions generated provide a method to create a new instance of B, or
// append an A_B struct to the map B whilst populating the relevant key fields
// of the list, or autocreating the key struct from the fields of the input
// structure. i.e., they are of the form:
//
// func (*A) NewB(string, int8) (*A_B, error) {
//	// Create a new instance of B, and its key, and append it to the map
//	// field of A.
// }
//
// func (*A) AppendB(*A_B) error {
//	// Append the instance of B that was handed to the function to the map
//	// field of A.
// }
//
// Each enumerated node within the YANG schema (an identity, enumeration leaf
// or typedef containin an enumeration) is output to a Go enumeration. This is
// formed by defining a new type, based on int64 - with constants defined for
// the values of the enumeration. Value 0 is always assigned to be UNSET, such
// that it is possible to determine that the enumerated value was not modified,
// with each subsequent value being assigned the next numeric value.
//
// If the name of an enumerated value is not Go safe - e.g., VALUE-ONE - it is
// converted to a Go-safe name using safeGoEnumeratedName, this function
// replaces characters that cannot be used within Go identifiers with
// underscores (where such characters are allowed in YANG identifiers).
//
// For example, a YANG identity defined in module "test-module" as:
//	identity BASE-IDENTITY;
//	identity VALUE-ONE { base "BASE-IDENTITY"; }
//	identity VALUE-TWO { base "BASE-IDENTITY"; }
//	identity VALUE-THREE { base "BASE-IDENTITY"; }
//
// is output to the following code:
//
//	type TestModule_BaseIdentity int64
//	const (
//		TestModule_BaseIdentity_UNSET = 0
//		TestModule_BaseIdentity_VALUE_ONE = 1
//		TestModule_BaseIdentity_VALUE_TWO = 2
//		TestModule_BaseIdentity_VALUE_THREE = 3
//	)
//
// Calling code can then set any identityref with a base of BASE-IDENTITY
// by setting a value to one of these constants.

// goStructCodeSnippet is used to store the generated code snippets associated with
// a particular Go struct entity (generated from a container or list).
type goStructCodeSnippet struct {
	// structDef stores the code snippet that represents the struct that is
	// the input when code generation is performed.
	structDef string
	// listKeys stores code snippets that are associated with structs that are
	// generated to represent the keys of multi-key lists. In the case that the
	// Go struct for which the code is being generated does not contain a list
	// with multiple keys, this string is empty.
	listKeys string
	// methods contains code snippsets that represent functions that have the
	// input struct as a receiver, that help the user create new entries within
	// lists, without needing to populate the keys of the list.
	methods string
	// interfaces contains code snippets that represent interfaces that are
	// used within the generated struct. Used when there are interfaces that
	// represent multi-type unions generated.
	interfaces string
	// enumMap contains a map, keyed by a schema path (represented as a string)
	// to the underlying type names selected for that leaf. A slice of strings
	// is used for the type to handle cases where there is more than one enumerated
	// type returned for a leaf.
	enumTypeMap map[string][]string
}

// goEnumCodeSnippet is used to store the generated code snippets associated with
// a particular Go enumerated entity (generated from an identity, typedef referencing
// an enumerated value or leaf of type enumeration).
type goEnumCodeSnippet struct {
	// constDef stores the code snippet for the definition of the derived int64
	// type, and set of constants corresponding to the enumerated values of the
	// target YANG node.
	constDef string
	// valToString is a map of the int64 value used in the constant definition for
	// the enumeration to its definition. The definition consists of the string
	// name of the enumerated value in the YANG schema. In the case of identities
	// it also stores the module within which the identity was defined. This map
	// allows mapping of the enumerated value back to its original name.
	valToString map[int64]ygot.EnumDefinition
	// name is the name of the enumerated value, used for mapping purposes.
	name string
}

// goStructField contains a definition of a field within a Go struct.
type goStructField struct {
	Name string // Name is the field's name.
	Type string // Type is the Go type of the field.
	// IsScalarField represents whether the element is a leaf, rather than a
	// leaf-list or container. It is set to false explicitly where there are
	// scalar types that are not mapped to pointers (particularly, enumerated
	// types.
	IsScalarField bool
	Tags          string // Tags specifies the tags that should be used to annotate the field.
}

// goUnionInterface contains a definition of an interface that should
// be generated for a multi-type union in YANG.
type goUnionInterface struct {
	Name           string            // Name is the name of the interface
	Types          map[string]string // Types is a map keyed by the camelcase type name, with values of the Go types in the union.
	LeafPath       string            // LeafPath stores the path for the leaf for which the multi-type union is being generated.
	ParentReceiver string            // ParentReceiver is the name of the struct that is a parent of this union field. It is used to allow methods to be created which simplify handling the union in the calling code.
	TypeNames      []string          // TypeNames is an list of Go type names within the union.
}

// generatedGoStruct is used to repesent a Go structure to be handed to a template for output.
type generatedGoStruct struct {
	StructName string           // StructName is the name of the struct being output.
	YANGPath   string           // YANGPath is the schema path of the struct being output.
	Fields     []*goStructField // Fields is the slice of fields of the struct, described as goStructField structs.
}

// generatedGoMultiKeyListStruct is used to represent a struct used as a key of a YANG list that has multiple
// key elements.
type generatedGoMultiKeyListStruct struct {
	KeyStructName string          // KeyStructName is the name of the struct being output.
	Keys          []goStructField // Keys is a slice of goStructFields that are contained in the key struct.
	ParentPath    string          // ParentPath is the path to the list's parent in the YANG schema.
	ListName      string          // ListName is the name of the list itself in the YANG schema.
}

// generatedGoListMethod contains the fields required for generating the methods
// that are associated with a list entry within a struct representing a YANG entity.
type generatedGoListMethod struct {
	ListName  string          // ListName is the name of the list for which the method is being generated within its parent struct.
	ListType  string          // ListType is the type (struct name) of the element representing the list.
	Keys      []goStructField // Keys of the list that is being generated (length = 1 if the list is single keyed).
	KeyStruct string          // KeyStruct is the name of the struct used as a key for a multi-keyed list.
	Receiver  string          // Receiver is the name of the parent struct of the list, which is the receiver for the generated method.
}

// generatedGoKeyHelper contains the fields required for generating a method
// associated with a struct that is within a list in the YANG schema.
type generatedGoKeyHelper struct {
	// Receiver is the name of the type which acts as a receiver for a generated method.
	Receiver string
	// Keys specifies the keys of the list, as a map from YANG to Go identifier.
	Keys []*yangFieldMap
}

// yangFieldMap maps a YANG identifier to its Go identifier.
type yangFieldMap struct {
	// YANGName is the field's name in the YANG schema.
	YANGName string
	// GoName is the field's name in the Go struct.
	GoName string
	// IsPtr indicates that the key field is a pointer.
	IsPtr bool
}

// generatedGoEnumeration is used to represent a Go enumerated value to be handed
// to a template for output.
type generatedGoEnumeration struct {
	// EnumerationPrefix is the prefix that should be used to any value for
	// the generated output. For example, if EnumerationPrefix is set to
	// OpenconfigBGP_AfiSafi then the enumerated "AFI-SAFIs" will be named
	// OpenconfigBGP_AfiSafi_IPV4, etc., where "IPV4" is the name of one of
	// the enumerated values. The generated type that is referred to is the
	// EnumerationPrefix with a further prefix of E_ such that it can be
	// distinguished from a value of the enumeration in documentation.
	EnumerationPrefix string
	// Values is a map of numeric index to string which represents the valus of the
	// enumerated type. The numeric value may be explicitly assigned by the schema,
	// or populated by goyang during the parsing of the module.
	Values map[int64]string
}

var (
	// goHeaderTemplate is populated and output at the top of the generated code package
	goHeaderTemplate = `
{{- /**/ -}}
/*
Package {{ .PackageName }} is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was {{ .CompressEnabled }}
in this case).

This package was generated by {{ .GeneratingBinary }}
using the following YANG input files:
{{- range $inputFile := .YANGFiles }}
	- {{ $inputFile }}
{{- end }}
Imported modules were sourced from:
{{- range $importPath := .IncludePaths }}
	- {{ $importPath }}
{{- end }}
*/
package {{ .PackageName }}

import (
	"encoding/json"
	"fmt"
	"reflect"

	"{{ .GoOptions.YgotImportPath }}"

{{- if .GenerateSchema }}
	"{{ .GoOptions.GoyangImportPath }}"
	"{{ .GoOptions.YtypesImportPath }}"
{{- end }}
)

// {{ .BinaryTypeName }} is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type {{ .BinaryTypeName }} []byte

// {{ .EmptyTypeName }} is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type {{ .EmptyTypeName }} bool

{{- if .GenerateSchema }}

var (
	SchemaTree map[string]*yang.Entry
)

func init() {
	var err error
	if SchemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		panic("schema error: " +  err.Error())
	}
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled.
func Unmarshal(data []byte, destStruct ygot.GoStruct) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn )
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree)
}

{{- end }}
`
	// goStructTemplate takes an input generatedGoStruct, which contains a definition of
	// a container or list YANG schema node, and generates the Go code from it. The
	// Fields slice in the generatedGoStruct contains the child schema nodes of the
	// YANG schema node, along with the mapped Go type that is to be used to represent
	// them. The logic populating the generatedGoStruct handles non-scalar child schema
	// nodes: leaf-lists are mapped into slices; lists are mapped into a map or slice of
	// structs; and containers are mapped into structs.
	goStructTemplate = `
// {{ .StructName }} represents the {{ .YANGPath }} YANG schema element.
type {{ .StructName }} struct {
{{- range $idx, $field := .Fields }}
	{{- if $field.IsScalarField }}
	{{ $field.Name }}	*{{ $field.Type }}	` + "`" + `{{ $field.Tags }}` + "`" + `
	{{- else }}
	{{ $field.Name }}	{{ $field.Type }}	` + "`" + `{{ $field.Tags }}` + "`" + `
	{{- end }}
{{- end }}
}

// IsYANGGoStruct ensures that {{ .StructName }} implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*{{ .StructName }}) IsYANGGoStruct() {}
`

	// goStructValidatorTemplate takes an input generatedGoStruct, which contains
	// a definition of a YANG schema node, and generates the Go validation code
	// from it.
	goStructValidatorTemplate = `
// Validate validates s against the YANG schema corresponding to its type.
func (s *{{.StructName}}) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["{{.StructName}}"], s, opts...); err != nil {
		return err
	}
	return nil
}
`
	// goListKeyTemplate takes an input generatedGoMultiKeyListStruct, which is used to
	// describe the key of a list that has multiple keys, and generates a Go
	// struct definition that can be used to represent that key. For example, if a
	// YANG container or list contains a list, L:
	//
	//	container A {
	//		list L {
	//			key "key-one key-two";
	//			leaf key-one { type string; }
	//			leaf key-two { type uint32; }
	//		}
	//	}
	//
	// A struct is generated to represent the key of list L, of the following form:
	//
	//	type A_L_Key struct {
	//		KeyOne	string
	//		KeyTwo	uint32
	//	}
	//
	// This struct is then used as the key of the map representing the list L, in
	// the generated struct representing the container A.
	//
	// TODO(robjs): Currently, based on OpenConfig conventions, and IETF
	// YANG conventions, the key of the list is generated when parsing the
	// parent container of the list, however, currently, this results in
	// lists that are at the root not having a structure generated for the
	// key. Since both IETF, vendors and OpenConfig adopts the approach of
	// having a surrounding container, this is left as a known limitation.
	// It is intended to be addressed when handling a 'root' entity in the
	// generated code.
	goListKeyTemplate = `
// {{ .KeyStructName }} represents the key for list {{ .ListName }} of element {{ .ParentPath }}.
type {{ .KeyStructName }} struct {
{{- range $idx, $key := .Keys }}
	{{ $key.Name }}	{{ $key.Type }}	` + "`{{ $key.Tags }}`" + `
{{- end }}
}
`

	// goEnumDefinitionTemplate takes an input generatedGoEnumeration struct
	// and outputs the Go code that is associated with the enumerated type to be
	// generated.
	goEnumDefinitionTemplate = `
// E_{{ .EnumerationPrefix }} is a derived int64 type which is used to represent
// the enumerated node {{ .EnumerationPrefix }}. An additional value named
// {{ .EnumerationPrefix }}_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_{{ .EnumerationPrefix }} int64

// IsYANGGoEnum ensures that {{ .EnumerationPrefix }} implements the yang.GoEnum
// interface. This ensures that {{ .EnumerationPrefix }} can be identified as a
// mapped type for a YANG enumeration.
func (E_{{ .EnumerationPrefix }}) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  {{ .EnumerationPrefix }}.
func (E_{{ .EnumerationPrefix }}) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

{{ $enumName := .EnumerationPrefix -}}
const (
	{{- range $i, $val := .Values }}
	// {{ $enumName }}_{{ $val }} corresponds to the value {{ $val }} of {{ $enumName }}
	{{ $enumName }}_{{ $val }} E_{{ $enumName }} = {{ $i }}
	{{- end }}
)
`
	// goNewListMemberTemplate takes an input generatedGoListMethod struct and
	// outputs a method, using the specified receiver, that creates a new instance
	// of a struct within a keyed YANG list, and populates the map key, and the
	// key fields of the list's struct according to the input arguments of the
	// function.
	goNewListMemberTemplate = `
// New{{ .ListName }} creates a new entry in the {{ .ListName }} list of the
// {{ .Receiver}} struct. The keys of the list are populated from the input
// arguments.
func (t *{{ .Receiver }}) New{{ .ListName }}(
  {{- $length := len .Keys -}}
  {{- range $i, $key := .Keys -}}
	{{ $key.Name }} {{ $key.Type -}}
	{{- if ne (inc $i) $length -}}, {{ end -}}
  {{- end -}}
  ) (*{{ .ListType }}, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.{{ .ListName }} == nil {
		{{- if ne .KeyStruct "" }}
		t.{{ .ListName }} = make(map[{{ .KeyStruct }}]*{{ .ListType }})
		{{- else }}
			{{- $listName := .ListName -}}
			{{- $listType := .ListType -}}
			{{- range $key := .Keys }}
		t.{{ $listName }} = make(map[{{ $key.Type }}]*{{ $listType }})
			{{- end }}
		{{- end }}
	}

	{{ if ne .KeyStruct "" -}}
	key := {{ .KeyStruct }}{
		{{- range $key := .Keys }}
		{{ $key.Name }}: {{ $key.Name }},
		{{- end }}
	}
	{{- else -}}
	{{- range $key := .Keys -}}
	key := {{ $key.Name }}
	{{- end -}}
	{{- end }}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.{{ .ListName }}[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list {{ .ListName }}", key)
	}

	t.{{ .ListName }}[key] = &{{ .ListType }}{
		{{- range $key := .Keys }}
		{{- if $key.IsScalarField }}
		{{ $key.Name }}: &{{ $key.Name }},
		{{- else }}
		{{ $key.Name }}: {{ $key.Name }},
		{{- end -}}
		{{- end }}
	}

	return t.{{ .ListName }}[key], nil
}
`

	// goKeyMapTemplate defines the template for a function that is generated for a YANG
	// list type. It returns a map[string]interface{} keyed by the YANG leaf identifier of each
	// key leaf, and containing their values within the struct.
	goKeyMapTemplate = `
// ΛListKeyMap returns the keys of the {{ .Receiver }} struct, which is a YANG list entry.
func (t *{{ .Receiver }}) ΛListKeyMap() (map[string]interface{}, error) {
{{- range $key := .Keys -}}{{ if $key.IsPtr }}
	if t.{{ $key.GoName }} == nil {
		return nil, fmt.Errorf("nil value for key {{ $key.GoName }}")
	}
	{{- end }}
{{ end }}
	return map[string]interface{}{
		{{- range $key := .Keys }}
		"{{ $key.YANGName }}": {{ if $key.IsPtr -}}
		*
		{{- end -}} t.{{ $key.GoName }},
		{{- end }}
	}, nil
}
`

	// goEnumMapTemplate provides a template to output a constant map which
	// can be used to resolve the string value of any enumeration within the
	// schema.
	goEnumMapTemplate = `
// ΛEnum is a map, keyed by the name of the type defined for each enum in the
// generated Go code, which provides a mapping between the constant int64 value
// of each value of the enumeration, and the string that is used to represent it
// in the YANG schema. The map is named ΛEnum in order to avoid clash with any
// valid YANG identifier.
var ΛEnum = map[string]map[int64]ygot.EnumDefinition{
	{{- range $enumName, $enumValues := . }}
	"E_{{ $enumName }}": {
		{{- range $value, $valDef := $enumValues }}
		{{ $value }}: {Name: "{{ $valDef.Name }}"
			{{- if ne $valDef.DefiningModule "" -}}
				, DefiningModule: "{{ $valDef.DefiningModule }}"
			{{- end -}}
		},
		{{- end }}
	},
	{{- end }}
}
`

	// goEnumTypeMapTemplate provides a template to output a constant map which
	// can be used to resolve a schemapath to the set of enumerated types that
	// are valid for the leaf or leaf-list defined at the path specified.
	goEnumTypeMapTemplate = `
// ΛEnumTypes is a map, keyed by a YANG schema path, of the enumerated types that
// correspond with the leaf. The type is represented as a reflect.Type. The naming
// of the map ensures that there are no clashes with valid YANG identifiers.
var ΛEnumTypes = map[string][]reflect.Type{
  {{- range $schemapath, $types := . }}
	"{{ $schemapath }}": []reflect.Type{
		{{- range $i, $t := $types }}
		reflect.TypeOf(({{ $t }})(0)),
		{{- end }}
	},
	{{- end }}
}
`

	// goEnumTypeMapAccessTemplate provides a template to output an accessor
	// function with a generated struct as receiver, it returns the enum type
	// map associated with the generated code.
	goEnumTypeMapAccessTemplate = `
// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *{{ .StructName }}) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }
`

	// schemaVarTemplate provides a template to output a constant byte
	// slice which contains the serialised schema of the YANG modules for
	// which code generation was performed.
	schemaVarTemplate = `
var (
	// {{ .VarName }} is a byte slice contain a gzip compressed representation of the
	// YANG schema from which the Go code was generated. When uncompressed the
	// contents of the byte slice is a JSON document containing an object, keyed
	// on the name of the generated struct, and containing the JSON marshalled
	// contents of a goyang yang.Entry struct, which defines the schema for the
	// fields within the struct.
	{{ .VarName }} = []byte{
{{- range $i, $line := .Schema }}
		{{ $line }}
{{- end }}
	}
)
`

	// unionInterfaceTemplate defines a template that outputs an interface
	// definition that corresponds to a multi-type union in YANG.
	unionInterfaceTemplate = `
// {{ .Name }} is an interface that is implemented by valid types for the union
// for the leaf {{ .LeafPath }} within the YANG schema.
type {{ .Name }} interface {
	Is_{{ .Name }}()
}
{{ $intfName := .Name -}}
{{- $path := .LeafPath -}}
{{- range $typeName, $type := .Types }}
// {{ $intfName }}_{{ $typeName }} is used when {{ $path }}
// is to be set to a {{ $type }} value.
type {{ $intfName }}_{{ $typeName }} struct {
	{{ $typeName }}	{{ $type }}
}

// Is_{{ $intfName }} ensures that {{ $intfName }}_{{ $typeName }}
// implements the {{ $intfName }} interface.
func (*{{ $intfName }}_{{ $typeName }}) Is_{{ $intfName }}() {}
{{ end }}
// To_{{ .Name }} takes an input interface{} and attempts to convert it to a struct
// which implements the {{ .Name }} union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *{{ .ParentReceiver }}) To_{{ .Name }}(i interface{}) ({{ .Name }}, error) {
	switch v := i.(type) {
	{{ range $typeName, $type := .Types -}}
	case {{ $type }}:
		return &{{ $intfName }}_{{ $typeName }}{v}, nil
	{{ end -}}
	default:
		return nil, fmt.Errorf("cannot convert %v to {{ .Name }}, unknown union type, got: %T, want any of [
		{{- $length := len .TypeNames -}}
		{{- range $i, $type := .TypeNames -}}
			{{ $type }}
			{{- if ne (inc $i) $length -}}, {{ end -}}
		{{- end -}}
		]", i, i)
	}
}
`

	// The set of built templates that are to be referenced during code generation.
	goTemplates = map[string]*template.Template{
		"header":              makeTemplate("header", goHeaderTemplate),
		"struct":              makeTemplate("struct", goStructTemplate),
		"structValidator":     makeTemplate("structValidator", goStructValidatorTemplate),
		"listkey":             makeTemplate("listkey", goListKeyTemplate),
		"newListEntry":        makeTemplate("newListEntry", goNewListMemberTemplate),
		"enumDefinition":      makeTemplate("enumDefinition", goEnumDefinitionTemplate),
		"enumMap":             makeTemplate("enumMap", goEnumMapTemplate),
		"schemaVar":           makeTemplate("schemaVar", schemaVarTemplate),
		"unionIntf":           makeTemplate("unionIntf", unionInterfaceTemplate),
		"keyHelper":           makeTemplate("keyHelper", goKeyMapTemplate),
		"enumTypeMap":         makeTemplate("enumTypeMap", goEnumTypeMapTemplate),
		"enumTypeMapAccessor": makeTemplate("enumTypeMapAccessor", goEnumTypeMapAccessTemplate),
	}

	// templateHelperFunctions specifies a set of functions that are supplied as
	// helpers to the templates that are used within this file.
	templateHelperFunctions = template.FuncMap{
		// inc provides a means to add 1 to a number, and is used within templates
		// to check whether the index of an element within a loop is the last one,
		// such that special handling can be provided for it (e.g., not following
		// it with a comma in a list of arguments).
		"inc": func(i int) int {
			return i + 1
		},
		"toUpper": strings.ToUpper,
		"indentLines": func(s string) string {
			var b bytes.Buffer
			p := strings.Split(s, "\n")
			b.WriteRune('\n')
			for i, l := range p {
				if l == "" {
					continue
				}
				b.WriteString(fmt.Sprintf("  %s", l))
				if i != len(p)-1 {
					b.WriteRune('\n')
				}
			}
			return b.String()
		},
	}
)

// makeTemplate generates a template.Template for a particular named source
// template; with a common set of helper functions.
func makeTemplate(name, src string) *template.Template {
	return template.Must(template.New(name).Funcs(templateHelperFunctions).Parse(src))
}

// writeGoHeader outputs the package header, including the package name and
// comments that is to be included with the generated code. The input set of
// files (yangFiles) are output to indicate the modules for which code
// generation was targeted, along with the includePaths indicating where
// imported modules were sourced from. If the cfg.GoOptions.YgotImport path
// is not set, then it is set to the value of DefaultYgotImportPath. In a similar manner
// an unset cfg.GoOptions.GoyangImportPath results in the goyang path being set to
// DefaultYgotImportPath, and an unset cfg.GoOptions.YtypesImportPath results in the
// path for ytypes being set to DefaultYtypesImportPath.
func writeGoHeader(yangFiles, includePaths []string, cfg GeneratorConfig) (string, error) {
	// Determine the running binary's name.
	if cfg.Caller == "" {
		cfg.Caller = callerName()
	}

	if cfg.PackageName == "" {
		cfg.PackageName = defaultPackageName
	}

	if cfg.GoOptions.YgotImportPath == "" {
		cfg.GoOptions.YgotImportPath = DefaultYgotImportPath
	}
	if cfg.GoOptions.GoyangImportPath == "" {
		cfg.GoOptions.GoyangImportPath = DefaultGoyangImportPath
	}
	if cfg.GoOptions.YtypesImportPath == "" {
		cfg.GoOptions.YtypesImportPath = DefaultYtypesImportPath
	}

	// Build input to the header template which stores parameters which are included
	// in the header of generated code.
	s := struct {
		PackageName      string   // PackgeName is the name of the package to be generated.
		YANGFiles        []string // YANGFiles contains the list of input YANG source files for code generation.
		IncludePaths     []string // IncludePaths contains the list of paths that included modules were searched for in.
		CompressEnabled  bool     // CompressEnabled indicates whether CompressOCPaths was set.
		GeneratingBinary string   // GeneratingBinary is the name of the binary generating the code.
		GenerateSchema   bool     // GenerateSchema stores whether the generator requested that the schema was to be stored with the output code.
		GoOptions        GoOpts   // GoOptions stores additional Go-specific options for the output code, including package paths.
		BinaryTypeName   string   // BinaryTypeName is the name of the type used for YANG binary types.
		EmptyTypeName    string   // EmptyTypeName is the name of the type used for YANG empty types.
	}{
		PackageName:      cfg.PackageName,
		YANGFiles:        yangFiles,
		IncludePaths:     includePaths,
		CompressEnabled:  cfg.CompressOCPaths,
		GeneratingBinary: cfg.Caller,
		GenerateSchema:   cfg.GenerateJSONSchema,
		GoOptions:        cfg.GoOptions,
		BinaryTypeName:   ygot.BinaryTypeName,
		EmptyTypeName:    ygot.EmptyTypeName,
	}

	var buf bytes.Buffer
	if err := goTemplates["header"].Execute(&buf, s); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// writeGoStruct generates code snippets for targetStruct. The parameter goStructElements
// contains other yangDirectory structs for which code is being generated, that may be referenced
// during the generation of the code corresponding to targetStruct (e.g., to determine a
// child container's struct name). writeGoStruct returns a goStructCodeSnippet which contains
//	1. The generated struct for targetStruct (structDef)
//	2. Additional generated structs that are keys for any multi-key lists that are children
//	   of targetStruct (listKeys).
//	3. Methods with the struct corresponding to targetStruct as a receiver, e.g., for each
//	   list a NewListMember() method is generated.
func writeGoStruct(targetStruct *yangDirectory, goStructElements map[string]*yangDirectory, state *genState, compressOCPaths, generateJSONSchema bool) (goStructCodeSnippet, []error) {
	var errs []error

	// structDef is used to store the attributes of the structure for which code is being
	// generated.
	structDef := generatedGoStruct{
		StructName: targetStruct.name,
		YANGPath:   slicePathToString(targetStruct.path),
	}
	// associatedListKeyStructs is a slice containing the key structures for any multi-keyed
	// lists that are fields of the struct.
	associatedListKeyStructs := []*generatedGoMultiKeyListStruct{}

	// associatedListMethods is a slice of pointers to generatedGoListMethod structs
	// which describe methods that use the target struct as a receiver. These structs
	// represent the methods that are used as helpers such as those methods that allow
	// a new member to be created within the list (populating the keys), and an
	// existing list member to be appended to the list.
	var associatedListMethods []*generatedGoListMethod

	// Sort the list of fields into alphabetical order to ensure determinstic output of code,
	// and minimise diffs.
	var fieldNames []string
	for fn := range targetStruct.fields {
		fieldNames = append(fieldNames, fn)
	}
	sort.Strings(fieldNames)

	// The names that have already been used within the struct, used to ensure that we do not
	// generate two elements that have the same name.
	definedStructFieldNames := map[string]bool{}

	// definedNameMap defines a map, keyed by YANG identifier to the Go struct field name.
	definedNameMap := map[string]*yangFieldMap{}

	// enumTypeMap stores a map of schemapath to type name for enumerated types.
	enumTypeMap := map[string][]string{}

	// genUnions stores the set of multi-type YANG unions that must have
	// code generated for them.
	genUnions := []goUnionInterface{}

	for _, fName := range fieldNames {
		// Iterate through the fields of the struct that we are generating code for.
		// For each field, calculate the name of the field (ensuring that it is unique), and
		// the corresponding type. fieldDef is used to store the definition of the field (name
		// and type) that are calculated.
		var fieldDef *goStructField

		field := targetStruct.fields[fName]

		// Make the name of the field into CamelCase. The definedStructFieldNames map is used as the
		// context, such that the name generated is unique within this structure.
		fieldName := makeNameUnique(entryCamelCaseName(field), definedStructFieldNames)
		definedNameMap[fName] = &yangFieldMap{YANGName: fName, GoName: fieldName}

		switch {
		case field.IsList():
			// If the field within the struct is a list, then generate code for this list. This
			// includes extracting any new types that are required to represent the key of a
			// list that has multiple keys.
			fieldType, multiKeyListKey, listMethods, listErr := yangListFieldToGoType(field, fieldName, targetStruct, goStructElements, state)
			if listErr != nil {
				errs = append(errs, listErr)
			}

			fieldDef = &goStructField{
				Name: fieldName,
				Type: fieldType,
			}

			if listMethods != nil {
				associatedListMethods = append(associatedListMethods, listMethods)
			}

			if multiKeyListKey != nil {
				// If the list had multiple keys, add the struct that represented the list
				// type to the slice of those that should have code generated for them.
				associatedListKeyStructs = append(associatedListKeyStructs, multiKeyListKey)
			}

		case field.IsContainer():
			// This is a YANG container, so it is represented in code using a pointer to the struct type that
			// is defined for the entity. findMappableEntities has already determined which fields are to
			// be output, so no filtering of the set of fields is required here.
			structName, ok := state.uniqueDirectoryNames[field.Path()]
			if !ok {
				errs = append(errs, fmt.Errorf("could not resolve %s into a defined struct", field.Path()))
				continue
			}

			fieldDef = &goStructField{
				Name: fieldName,
				Type: fmt.Sprintf("*%s", structName),
			}
		case field.IsLeaf() || field.IsLeafList():
			// This is a leaf or leaf-list, so we map it into the Go type that corresponds to the
			// YANG type that the leaf represents.
			mtype, err := state.yangTypeToGoType(resolveTypeArgs{yangType: field.Type, contextEntry: field}, compressOCPaths)
			if err != nil {
				errs = append(errs, err)
				continue
			}

			// Set the default type to the mapped Go type, and note that it is a scalar field. This is
			// used to determine fields that should be converted to pointers when outputting structs.
			// This is done to allow checks against nil.
			scalarField := true
			fType := mtype.nativeType
			schemapath := entrySchemaPath(field)

			if len(mtype.unionTypes) > 1 {
				// If this is a union that has more than one subtype, then we need
				// to ensure that we do not map this as a pointer type (since its
				// field type is an interface), and generate the relevant interface.
				scalarField = false

				if _, ok := state.generatedUnions[mtype.nativeType]; !ok {
					// If the union type has not already been generated, then create it.
					// This is to handle cases whereby we can have two types that are
					// mapped to the same unique name -- such as in the case that we
					// have a leafref that points to a leaf that is a union.
					intf := goUnionInterface{
						Name:           mtype.nativeType,
						Types:          map[string]string{},
						LeafPath:       field.Path(),
						ParentReceiver: targetStruct.name,
					}

					for t := range mtype.unionTypes {
						// If the type within the union is not a builtin type then we store
						// it within the enumMap, since it is an enumerated type.
						if _, builtin := validGoBuiltinTypes[t]; !builtin {
							enumTypeMap[schemapath] = append(enumTypeMap[schemapath], t)
						}

						tn := yang.CamelCase(t)
						// Ensure that we sanitise the type name to be used in the
						// output struct.
						if t == "interface{}" {
							tn = "Interface"
						}
						intf.Types[tn] = t
						intf.TypeNames = append(intf.TypeNames, t)
					}
					// Sort the names of the types into determinstic order.
					sort.Strings(intf.TypeNames)
					genUnions = append(genUnions, intf)
					state.generatedUnions[mtype.nativeType] = true
				}
			}

			switch {
			case field.ListAttr != nil:
				// If the field's ListAttr is set, then this indicates that this
				// element is a leaf-list. We represent a leaf-list in the output
				// code using a slice of the type that the element was mapped to.
				fType = fmt.Sprintf("[]%s", fType)
				scalarField = false
			case mtype.isEnumeratedValue == true, mtype.nativeType == "interface{}", mtype.nativeType == ygot.BinaryTypeName, mtype.nativeType == ygot.EmptyTypeName:
				// If the value is an enumerated value, then we did not represent it
				// as a pointer within the struct, so mark it as a scalar field such
				// that the template does not attempt to prefix it with an asterisk.
				// A similar rule exists if the value has not been mapped to a type
				// and is instead represented as the empty interface, or if the
				// native type is a byte slice.
				scalarField = false
			}

			definedNameMap[fName].IsPtr = scalarField
			if mtype.isEnumeratedValue {
				// Any enumerated type is stored in the enumMap to allow for type
				// resolution from a schema path.
				enumTypeMap[schemapath] = append(enumTypeMap[schemapath], mtype.nativeType)
			}

			fieldDef = &goStructField{
				Name:          fieldName,
				Type:          fType,
				IsScalarField: scalarField,
			}
		default:
			errs = append(errs, fmt.Errorf("unknown entity type for mapping to Go: %s, Kind: %v", field.Path(), field.Kind))
			continue
		}

		// Find the schema paths that the field corresponds to, such that these can
		// be used as annotations (tags) within the generated struct. Go paths are
		// always relative.
		schemaMapPaths, err := findMapPaths(targetStruct, field, compressOCPaths, false)
		if err != nil {
			errs = append(errs, err)
			continue
		}
		var tagBuf bytes.Buffer
		tagBuf.WriteString(`path:"`)
		for i, p := range schemaMapPaths {
			tagBuf.WriteString(slicePathToString(p))
			if i != len(schemaMapPaths)-1 {
				tagBuf.WriteRune('|')
			}
		}
		tagBuf.WriteByte('"')

		// Append a tag indicating the module that instantiates this field.
		im, err := field.InstantiatingModule()
		if err != nil {
			// This is a non-fatal error, since it can only occur in testing. All YANG modules
			// must have a specified namespace.
			log.Infof("field %s has a nil module, error discarded", field.Path())
		} else {
			tagBuf.WriteString(fmt.Sprintf(` module:"%s"`, im))
		}

		fieldDef.Tags = tagBuf.String()

		// Append the generated field definition to the set of fields of the struct.
		structDef.Fields = append(structDef.Fields, fieldDef)
	}

	// structBuf is used to store the code associated with the struct defined for
	// the target YANG entity.
	var structBuf bytes.Buffer
	if err := goTemplates["struct"].Execute(&structBuf, structDef); err != nil {
		errs = append(errs, err)
	}

	// listkeyBuf is a buffer which stores the code associated with structs that
	// are associated with the structs generated to act as list keys.
	var listkeyBuf bytes.Buffer
	for _, listKey := range associatedListKeyStructs {
		if err := goTemplates["listkey"].Execute(&listkeyBuf, listKey); err != nil {
			errs = append(errs, err)
		}
	}

	// methodBuf is used to store the code generated for methods that have the
	// target entity's generated struct as a receiver.
	var methodBuf bytes.Buffer
	for _, method := range associatedListMethods {
		if err := goTemplates["newListEntry"].Execute(&methodBuf, method); err != nil {
			errs = append(errs, err)
		}
	}

	if err := generateGetListKey(&methodBuf, targetStruct, definedNameMap); err != nil {
		errs = append(errs, err)
	}

	// interfaceBuf is used to store the code generated for interfaces that
	// are used for multi-type unions within the struct.
	var interfaceBuf bytes.Buffer
	for _, intf := range genUnions {
		if err := goTemplates["unionIntf"].Execute(&interfaceBuf, intf); err != nil {
			errs = append(errs, err)
		}
	}

	if generateJSONSchema {
		if err := generateValidator(&methodBuf, structDef); err != nil {
			errs = append(errs, err)
		}

		if err := generateEnumTypeMapAccessor(&methodBuf, structDef); err != nil {
			errs = append(errs, err)
		}
	}

	return goStructCodeSnippet{
		structDef:   structBuf.String(),
		methods:     methodBuf.String(),
		listKeys:    listkeyBuf.String(),
		interfaces:  interfaceBuf.String(),
		enumTypeMap: enumTypeMap,
	}, errs
}

// generateValidator generates a validation function string for structDef and
// appends it to the supplied buffer.
// Assuming structDef represents the following struct:
//
//   struct MyStruct {
//     field1 *string
//   }
//
// the validation function generated for the struct will be:
//
//   func (s *MyStruct) Validate(value interface{}) error {
//     if err := ytypes.Validate(schemaMap["MyStruct"], value); err != nil {
//       return err
//     }
//     return nil
//   }
func generateValidator(buf *bytes.Buffer, structDef generatedGoStruct) error {
	if err := goTemplates["structValidator"].Execute(buf, structDef); err != nil {
		return err
	}

	return nil
}

// generateGetListKey generates a function extracting the keys from a list
// defined in the yangDirectory s, and appends it to the supplier buffer. The
// nameMap stores maps between the key YANG field identifiers and their Go
// identifiers.
//
// If the input yangDirectory is the following list entry:
//
//  list foo {
//    key "bar baz";
//
//    leaf bar { type string; }
//    leaf baz { type uint8; }
//    leaf colour { type string; }
//  }
//
// Which is mapped into the Go struct:
//
//  type Foo {
//    Bar *string `path:"bar"`
//    Baz *uint8  `path:"baz"`
//    Colour *string `path:"colour"`
//  }
//
// The generated method will;
//  - Check pointer keys to ensure they are non-nil.
//  - Return a map[string]interface{} keyed by the name of the key in the YANG schema, with the value
//    specified in the struct.
//
// i.e.: for the above struct:
//
//  func (t *Foo) ΛListKeyMap() (map[string]interface{}, error) {
//	if t.Bar == nil {
//	   return nil, fmt.Errorf("key value for Bar is nil")
//	}
//
//	if t.Baz == nil {
//	   return nil, fmt.Errorf("key value for Baz is nil")
//	}
//
//	return map[string]interface{}{
//	  "bar": *t.Bar,
//	  "baz": *t.Baz,
//	}
//  }
func generateGetListKey(buf *bytes.Buffer, s *yangDirectory, nameMap map[string]*yangFieldMap) error {
	if !s.isList() {
		return nil
	}

	h := generatedGoKeyHelper{
		Receiver: s.name,
	}

	kn := []string{}
	for k := range s.listAttr.keys {
		kn = append(kn, k)
	}
	sort.Strings(kn)

	for _, k := range kn {
		h.Keys = append(h.Keys, nameMap[k])
	}

	if err := goTemplates["keyHelper"].Execute(buf, h); err != nil {
		return err
	}
	return nil
}

// yangListFieldToGoType takes a yang.Entry (listField) and returns a string corresponding to the Go
// type that should be used to represent it within its parent struct (the parent argument). A map, keyed
// by schema path, of the other code entities that have been extracted within the context that the
// listField is being generated are provided to the function as input, such that the struct representing
// the list itself can be cross-referenced.
//
// In all cases, the type of list field is the struct which is defined to reference the list, used as
// the base type. This type is then modified based on how the list is keyed:
//	- If the list is a config false, keyless list - a slice of the list's type is returned.
//	- If the list has a single key, a map, keyed by the single key's type is returned.
//	- If the list has multiple keys, a new struct is defined which represents the set of
//	  leaves that make up the key. The type of the list is then a map, keyed by the new struct
//	  type.
// In the case that the list has multiple keys, the type generated as the key of the list is returned.
// If errors are encountered during the type generation for the list, the error is returned.
func yangListFieldToGoType(listField *yang.Entry, listFieldName string, parent *yangDirectory, goStructElements map[string]*yangDirectory, state *genState) (string, *generatedGoMultiKeyListStruct, *generatedGoListMethod, error) {
	// The list itself, since it is a container, has a struct associated with it. Retrieve
	// this from the set of yangDirectory structs for which code (a Go struct) will be
	//  generated such that additional details can be used in the code generation.
	listElem, ok := goStructElements[listField.Path()]
	if !ok {
		return "", nil, nil, fmt.Errorf("struct for %s did not exist", listField.Path())
	}

	// Find the name of the struct that refers to the list provided as input. The YANGCodeGenerator
	// instance stores this information. It is populated by structName which always runs prior to
	// this function being called (as all mappable entities, which includes lists, have been found.
	// Thus, in the case that this struct does not have a known name, then code cannot be generated
	// for it, and hence we skip the element.
	listName, ok := state.uniqueDirectoryNames[listField.Path()]
	if !ok {
		return "", nil, nil, fmt.Errorf("list element %s did not have a resolved name", listField.Path())
	}

	if listElem.listAttr == nil || len(listElem.listAttr.keys) == 0 {
		// Keyless list therefore represent this as a slice of pointers to
		// the struct that represents the list element itself.
		return fmt.Sprintf("[]*%s", listName), nil, nil, nil
	}

	var listType string
	var multiListKey *generatedGoMultiKeyListStruct
	var listKeys []goStructField
	var listKeyStructName string

	// Key name elements are ordered per Section 7.8.2 of RFC6020. Rely on this
	// fact for determisitic ordering in output code and rendering.
	keyElemNames := strings.Split(listField.Key, " ")

	usedKeyElemNames := make(map[string]bool)
	for _, keName := range keyElemNames {
		keyField := goStructField{
			Name: makeNameUnique(entryCamelCaseName(listField.Dir[keName]), usedKeyElemNames),
			Type: listElem.listAttr.keys[keName].nativeType,
			Tags: fmt.Sprintf(`path:"%s"`, keName),
		}
		// All list key values should be represented as pointers, other than those that
		// are enumerated values, and hence we mark IsScalarField as true for these.
		if !listElem.listAttr.keys[keName].isEnumeratedValue && len(listElem.listAttr.keys[keName].unionTypes) < 2 {
			keyField.IsScalarField = true
		}
		listKeys = append(listKeys, keyField)
	}

	switch {
	case len(listElem.listAttr.keys) == 1:
		// This is a single keyed list, so we can represent it as a map with
		// a simple Go type as the key. Note that a leaf-list can never be
		// a key, so we do not need to handle the case whereby we would have to
		// have a slice which keys the list.
		listType = fmt.Sprintf("map[%s]*%s", listKeys[0].Type, listName)
	default:
		// This is a list with multiple keys, so we need to generate a new structure
		// that represents the list key itself - this struct is described in a
		// generatedGoMultiKeyListStruct struct, which is then expanded by a template to the struct
		// definition.
		listKeyStructName = fmt.Sprintf("%s_%s_Key", parent.name, listFieldName)
		multiListKey = &generatedGoMultiKeyListStruct{
			KeyStructName: listKeyStructName,
			ParentPath:    slicePathToString(parent.path),
			ListName:      listFieldName,
			Keys:          listKeys,
		}
		listType = fmt.Sprintf("map[%s]*%s", listKeyStructName, listName)
	}

	// Generate the specification for the methods that should be generated for this
	// list, such that this can be handed to the relevant templates to generate code.
	listMethodSpec := &generatedGoListMethod{
		ListName:  listFieldName,
		ListType:  listName,
		KeyStruct: listKeyStructName,
		Keys:      listKeys,
		Receiver:  parent.name,
	}

	return listType, multiListKey, listMethodSpec, nil
}

// writeGoEnum takes an input yangEnum, and generates the code corresponding
// to it. If the enum that is input has multiple enumerated types within it
// (i.e., is a union) then the relevant enumerated type is output for each
// included entity. If errors are encountered whilst mapping the enumeration to
// code, they are returned. The enumDefinition template is used to convert a
// constructed generatedGoEnumeration struct to code within the function.
func writeGoEnum(inputEnum *yangEnum) (goEnumCodeSnippet, error) {
	// initialised to be UNSET, such that it is possible to determine that the enumerated value
	// was not modified.
	values := map[int64]string{
		0: "UNSET",
	}

	// origValues stores the original set of value names, these are not maintained to be
	// Go-safe, and are rather used to map back to the original schema values if required.
	// 0 is not populated within this map, such that the values can be used to check whether
	// there was a valid entry in the original schema. The value is stored as a ygot
	// EnumDefinition, which stores the name, and in the case of identity values, the
	// module within which the identity was defined.
	origValues := map[int64]ygot.EnumDefinition{}

	switch {
	case inputEnum.entry.Type.IdentityBase != nil:
		// The inputEnum corresponds to an identityref - hence the values are defined
		// based on the values that the identity has. Since there is no explicit ordering
		// in an identity, then we go through and put the values in alphabetical order in
		// order to avoid reordering during code generation of the same entity.
		valNames := []string{}
		valLookup := map[string]*yang.Identity{}
		for _, v := range inputEnum.entry.Type.IdentityBase.Values {
			valNames = append(valNames, v.Name)
			valLookup[v.Name] = v
		}
		sort.Strings(valNames)

		for i, v := range valNames {
			values[int64(i)+1] = safeGoEnumeratedValueName(v)
			origValues[int64(i)+1] = ygot.EnumDefinition{
				Name: v,
				// Append the defining module by looking at the root node of the
				// identity - i.e., the module that defined it.
				DefiningModule: yang.RootNode(valLookup[v]).Name,
			}
		}
	default:
		// The remaining enumerated types are all represented as an Enum type within the
		// Goyang entry construct. The values are accessed in a map keyed by an int64
		// and with a value of the name of the enumerated value - retrieved via ValueMap().
		for i, value := range inputEnum.entry.Type.Enum.ValueMap() {
			values[i+1] = safeGoEnumeratedValueName(value)
			origValues[i+1] = ygot.EnumDefinition{Name: value}
		}
	}

	// Initialise the input to the template, and generate the output.
	templateInput := generatedGoEnumeration{
		EnumerationPrefix: inputEnum.name,
		Values:            values,
	}

	var buf bytes.Buffer
	err := goTemplates["enumDefinition"].Execute(&buf, templateInput)
	return goEnumCodeSnippet{
		constDef:    buf.String(),
		valToString: origValues,
		name:        inputEnum.name,
	}, err
}

// findMapPaths takes an input yang.Entry and calculates the set of schemapaths that it represents.
// If absolutePaths is set, the paths are absolute otherwise they are relative to the parent. If
// the input entry is a key to a list, and is of type leafref, then the corresponding target leaf's
// path is also returned.
func findMapPaths(parent *yangDirectory, field *yang.Entry, compressOCPaths, absolutePaths bool) ([][]string, error) {
	fieldSlicePath := traverseElementSchemaPath(field)
	var childPath, parentPath []string

	if absolutePaths {
		childPath = append([]string{""}, fieldSlicePath[1:]...)
	} else {
		parentPath = parent.path
		// Append the elements that are not common between the two paths.
		// Since the field is necessarily a child of the parent, then to
		// determine those elements of the field's path that are not contained
		// in the parent's, we walk from index X of the field's path (where X
		// is the number of elements in the path of the parent).
		if len(fieldSlicePath) < len(parentPath) {
			return nil, fmt.Errorf("field %v is not a valid child of %v", fieldSlicePath, parent.path)
		}

		childPath = append(childPath, fieldSlicePath[len(parentPath)-1:]...)
	}

	mapPaths := [][]string{childPath}
	if !compressOCPaths || parent.listAttr == nil {
		return mapPaths, nil
	}

	// Handle specific issue of compression of the schema, where the key
	// of the parent list is a leafref to this leaf.
	for _, k := range parent.listAttr.keyElems {
		// If the key element has the same path as this element, and the
		// corresponding element that is within the parent's container is of
		// type leafref, then within an OpenConfig schema this means that
		// the key leaf was a pointer to this leaf. To this end, we set
		// isKey to true so that the struct field can be mapped to the
		// leafref leaf within the schema as well as the target of the
		// leafref.
		if reflect.DeepEqual(traverseElementSchemaPath(k), fieldSlicePath) && k.Parent.Parent.Dir[k.Name].Type.Kind == yang.Yleafref {
			// The path of the key element is simply the name of the leaf under the
			// list, since the YANG specification enforces that keys are direct
			// children of the list.
			keyPath := []string{fieldSlicePath[len(fieldSlicePath)-1]}
			if absolutePaths {
				// If absolute paths are required, then the 'config' or 'state' container needs to be omitted from
				// the complete path for the secondary mapping.
				keyPath = append([]string{""}, fieldSlicePath[1:len(fieldSlicePath)-2]...)
				keyPath = append(keyPath, fieldSlicePath[len(fieldSlicePath)-1])
			}
			mapPaths = append(mapPaths, keyPath)
			break
		}
	}
	return mapPaths, nil
}

// generateEnumMap outputs a map from the enumMapTemplate. It takes an input of
// a map corresponding to the enumerated types that are defined in the input YANG
// schema, keyed by their generating Go name. The values of the map for each key is
// a map of a int64 value of the enum, and its string name as represented in the
// original YANG schema,
func generateEnumMap(enumValues map[string]map[int64]ygot.EnumDefinition) (string, error) {
	if len(enumValues) == 0 {
		return "", nil
	}

	var buf bytes.Buffer
	if err := goTemplates["enumMap"].Execute(&buf, enumValues); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// generateEnumTypeMap outputs a map using the enumTypeMap template. It takes an
// input of a map, keyed by schema path, to the string names of the enumerated
// types that can correspond to the schema path. The map generated allows a
// schemapath to be mapped into the reflect.Type representing the enum value.
func generateEnumTypeMap(enumTypeMap map[string][]string) (string, error) {
	var buf bytes.Buffer
	if err := goTemplates["enumTypeMap"].Execute(&buf, enumTypeMap); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// generateEnumTypeMapAccessor generates a function which returns the defined
// enumTypeMap for a struct.
func generateEnumTypeMapAccessor(b *bytes.Buffer, s generatedGoStruct) error {
	if err := goTemplates["enumTypeMapAccessor"].Execute(b, s); err != nil {
		return err
	}
	return nil
}

// writeGoSchema generates Go code which serialises the rawSchema byte slice
// provided and stores it in a variable which can be written out to the generated
// Go code file.
func writeGoSchema(js []byte, schemaVarName string) (string, error) {
	jbyte, err := WriteGzippedByteSlice(js)
	if err != nil {
		return "", fmt.Errorf("could not write Byte slice: %v", err)
	}

	vn := defaultSchemaVarName
	if schemaVarName != "" {
		vn = schemaVarName
	}

	in := struct {
		VarName string
		Schema  []string
	}{
		VarName: vn,
		Schema:  BytesToGoByteSlice(jbyte),
	}

	var buf bytes.Buffer
	if err := goTemplates["schemaVar"].Execute(&buf, in); err != nil {
		return "", err
	}

	return buf.String(), nil
}
