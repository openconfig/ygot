// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ygen

import (
	"fmt"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/kylelemons/godebug/pretty"
	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/testutil"
	"github.com/openconfig/ygot/ygot"
)

// wantGoStructOut is used to store the expected output of a writeGoStructs
// call.
type wantGoStructOut struct {
	wantErr    bool   // wantErr indicates whether errors are expected.
	structs    string // structs contains code repesenting a the mapped struct.
	keys       string // keys contains code representing structs used as list keys.
	methods    string // methods contains code corresponding to methods associated with the mapped struct.
	interfaces string // interfaces contains code corresponding to interfaces associated with the mapped struct.
}

// TestGoCodeStructGeneration tests the code generation from a known schema generates
// the correct structures, key types and methods for a YANG container.
func TestGoCodeStructGeneration(t *testing.T) {
	tests := []struct {
		name          string
		inStructToMap *ParsedDirectory
		// inOtherStructMap is the set of other mappable entities that are
		// in the same module as the struct to map
		inOtherStructMap          map[string]*ParsedDirectory
		inIgnoreShadowSchemaPaths bool
		inGoOpts                  GoOpts
		want                      wantGoStructOut
	}{{
		name: "simple single leaf mapping test",
		inStructToMap: &ParsedDirectory{
			Name: "Tstruct",
			Fields: map[string]*NodeDetails{
				"f1": {
					Name: "F1",
					YANGDetails: YANGNodeDetails{
						Name:         "f1",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/tstruct/f1",
						ResolvedPath: "",
					},
					Type: LeafNode,
					LangType: &MappedType{
						NativeType:        "int8",
						UnionTypes:        nil,
						IsEnumeratedValue: false,
						ZeroValue:         "0",
						DefaultValue:      nil,
					},
					MappedPaths:             [][]string{{"f1"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
				"f2": {
					Name: "F2",
					YANGDetails: YANGNodeDetails{
						Name:         "f2",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/tstruct/f2",
						ResolvedPath: "",
					},
					Type: LeafListNode,
					LangType: &MappedType{
						NativeType:        "string",
						UnionTypes:        nil,
						IsEnumeratedValue: false,
						ZeroValue:         `""`,
						DefaultValue:      nil,
					},
					MappedPaths:             [][]string{{"f2"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       [][]string{{"g2"}},
					ShadowMappedPathModules: [][]string{{"exmod2"}},
				},
			},
			Path:            "/root-module/tstruct",
			BelongingModule: "exmod",
		},
		inGoOpts: GoOpts{
			ValidateFunctionName: "ValidateProxyFunction",
		},
		want: wantGoStructOut{
			structs: `
// Tstruct represents the /root-module/tstruct YANG schema element.
type Tstruct struct {
	F1	*int8	` + "`" + `path:"f1" module:"exmod"` + "`" + `
	F2	[]string	` + "`" + `path:"f2" module:"exmod"` + "`" + `
}

// IsYANGGoStruct ensures that Tstruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Tstruct) IsYANGGoStruct() {}
`,
			methods: `
// Validate validates s against the YANG schema corresponding to its type.
func (t *Tstruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Tstruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Tstruct) ValidateProxyFunction(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Tstruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// Tstruct belongs.
func (*Tstruct) ΛBelongingModule() string {
	return "exmod"
}
`,
		},
	}, {
		name: "simple single leaf mapping test outputting shadow paths",
		inStructToMap: &ParsedDirectory{
			Name: "Tstruct",
			Fields: map[string]*NodeDetails{
				"f1": {
					Name: "F1",
					YANGDetails: YANGNodeDetails{
						Name:         "f1",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/tstruct/f1",
						ResolvedPath: "",
					},
					Type: LeafNode,
					LangType: &MappedType{
						NativeType:        "int8",
						UnionTypes:        nil,
						IsEnumeratedValue: false,
						ZeroValue:         "0",
						DefaultValue:      nil,
					},
					MappedPaths:             [][]string{{"f1"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
				"f2": {
					Name: "F2",
					YANGDetails: YANGNodeDetails{
						Name:         "f2",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/tstruct/f2",
						ResolvedPath: "",
					},
					Type: LeafListNode,
					LangType: &MappedType{
						NativeType:        "string",
						UnionTypes:        nil,
						IsEnumeratedValue: false,
						ZeroValue:         `""`,
						DefaultValue:      nil,
					},
					MappedPaths:             [][]string{{"f2"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       [][]string{{"g2"}},
					ShadowMappedPathModules: [][]string{{"exmod2"}},
				},
			},
			Path:            "/root-module/tstruct",
			BelongingModule: "exmod",
		},
		inIgnoreShadowSchemaPaths: true,
		want: wantGoStructOut{
			structs: `
// Tstruct represents the /root-module/tstruct YANG schema element.
type Tstruct struct {
	F1	*int8	` + "`" + `path:"f1" module:"exmod"` + "`" + `
	F2	[]string	` + "`" + `path:"f2" module:"exmod" shadow-path:"g2" shadow-module:"exmod2"` + "`" + `
}

// IsYANGGoStruct ensures that Tstruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Tstruct) IsYANGGoStruct() {}
`,
			methods: `
// Validate validates s against the YANG schema corresponding to its type.
func (t *Tstruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Tstruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Tstruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// Tstruct belongs.
func (*Tstruct) ΛBelongingModule() string {
	return "exmod"
}
`,
		},
	}, {
		name: "struct with a multi-type union",
		inStructToMap: &ParsedDirectory{
			Name: "InputStruct",
			Fields: map[string]*NodeDetails{
				"u1": {
					Name: "U1",
					YANGDetails: YANGNodeDetails{
						Name:         "u1",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/module/input-struct/u1",
						ResolvedPath: "",
					},
					Type: LeafNode,
					LangType: &MappedType{
						NativeType:        "InputStruct_U1_Union",
						UnionTypes:        map[string]int{"string": 0, "int8": 1},
						IsEnumeratedValue: false,
						ZeroValue:         "nil",
						DefaultValue:      nil,
					},
					MappedPaths:             [][]string{{"u1"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/module/input-struct",
			BelongingModule: "exmod",
		},
		want: wantGoStructOut{
			structs: `
// InputStruct represents the /module/input-struct YANG schema element.
type InputStruct struct {
	U1	InputStruct_U1_Union	` + "`" + `path:"u1" module:"exmod"` + "`" + `
}

// IsYANGGoStruct ensures that InputStruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*InputStruct) IsYANGGoStruct() {}
`,
			methods: `
// Validate validates s against the YANG schema corresponding to its type.
func (t *InputStruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["InputStruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *InputStruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// InputStruct belongs.
func (*InputStruct) ΛBelongingModule() string {
	return "exmod"
}
`,
			interfaces: `
// InputStruct_U1_Union is an interface that is implemented by valid types for the union
// for the leaf /module/input-struct/u1 within the YANG schema.
type InputStruct_U1_Union interface {
	Is_InputStruct_U1_Union()
}

// InputStruct_U1_Union_Int8 is used when /module/input-struct/u1
// is to be set to a int8 value.
type InputStruct_U1_Union_Int8 struct {
	Int8	int8
}

// Is_InputStruct_U1_Union ensures that InputStruct_U1_Union_Int8
// implements the InputStruct_U1_Union interface.
func (*InputStruct_U1_Union_Int8) Is_InputStruct_U1_Union() {}

// InputStruct_U1_Union_String is used when /module/input-struct/u1
// is to be set to a string value.
type InputStruct_U1_Union_String struct {
	String	string
}

// Is_InputStruct_U1_Union ensures that InputStruct_U1_Union_String
// implements the InputStruct_U1_Union interface.
func (*InputStruct_U1_Union_String) Is_InputStruct_U1_Union() {}

// To_InputStruct_U1_Union takes an input interface{} and attempts to convert it to a struct
// which implements the InputStruct_U1_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *InputStruct) To_InputStruct_U1_Union(i interface{}) (InputStruct_U1_Union, error) {
	switch v := i.(type) {
	case int8:
		return &InputStruct_U1_Union_Int8{v}, nil
	case string:
		return &InputStruct_U1_Union_String{v}, nil
	default:
		return nil, fmt.Errorf("cannot convert %v to InputStruct_U1_Union, unknown union type, got: %T, want any of [int8, string]", i, i)
	}
}
`,
		},
	}, {
		name: "nested container in struct",
		inStructToMap: &ParsedDirectory{
			Name: "InputStruct",
			Type: Container,
			Fields: map[string]*NodeDetails{
				"c1": {
					Name: "C1",
					YANGDetails: YANGNodeDetails{
						Name:         "c1",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/input-struct/c1",
						ResolvedPath: "",
					},
					Type:                    ContainerNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"c1"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/input-struct",
			BelongingModule: "exmod",
		},
		inOtherStructMap: map[string]*ParsedDirectory{
			"/root-module/input-struct/c1": {
				Name:            "InputStruct_C1",
				Path:            "/root-module/input-struct/c1",
				BelongingModule: "exmod",
			},
		},
		want: wantGoStructOut{
			structs: `
// InputStruct represents the /root-module/input-struct YANG schema element.
type InputStruct struct {
	C1	*InputStruct_C1	` + "`" + `path:"c1" module:"exmod"` + "`" + `
}

// IsYANGGoStruct ensures that InputStruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*InputStruct) IsYANGGoStruct() {}
`,
			methods: `
// Validate validates s against the YANG schema corresponding to its type.
func (t *InputStruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["InputStruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *InputStruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// InputStruct belongs.
func (*InputStruct) ΛBelongingModule() string {
	return "exmod"
}
`,
		},
	}, {
		name: "nested container in struct with presence container",
		inStructToMap: &ParsedDirectory{
			Name: "InputStruct",
			Type: Container,
			Fields: map[string]*NodeDetails{
				"c1": {
					Name: "C1",
					YANGDetails: YANGNodeDetails{
						Name:              "c1",
						Defaults:          nil,
						Module:            "exmod",
						Path:              "/root-module/input-struct/c1",
						ResolvedPath:      "",
						PresenceStatement: ygot.String("instantiated"),
					},
					Type:                    ContainerNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"c1"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/input-struct",
			BelongingModule: "exmod",
		},
		inOtherStructMap: map[string]*ParsedDirectory{
			"/root-module/input-struct/c1": {
				Name:            "InputStruct_C1",
				Path:            "/root-module/input-struct/c1",
				BelongingModule: "exmod",
			},
		},
		inGoOpts: GoOpts{
			AddYangPresence: true,
		},
		want: wantGoStructOut{
			structs: `
// InputStruct represents the /root-module/input-struct YANG schema element.
type InputStruct struct {
	C1	*InputStruct_C1	` + "`" + `path:"c1" module:"exmod" yangPresence:"true"` + "`" + `
}

// IsYANGGoStruct ensures that InputStruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*InputStruct) IsYANGGoStruct() {}
`,
			methods: `
// Validate validates s against the YANG schema corresponding to its type.
func (t *InputStruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["InputStruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *InputStruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// InputStruct belongs.
func (*InputStruct) ΛBelongingModule() string {
	return "exmod"
}
`,
		},
	}, {
		name: "struct with missing struct referenced",
		inStructToMap: &ParsedDirectory{
			Name: "AStruct",
			Fields: map[string]*NodeDetails{
				"elem": {
					Name: "Elem",
					YANGDetails: YANGNodeDetails{
						Name:         "elem",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/a-struct/elem",
						ResolvedPath: "",
					},
					Type:                    ContainerNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"elem"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/a-struct",
			BelongingModule: "exmod",
		},
		want: wantGoStructOut{wantErr: true},
	}, {
		name: "struct with missing list referenced",
		inStructToMap: &ParsedDirectory{
			Name: "BStruct",
			Fields: map[string]*NodeDetails{
				"list": {
					Name: "List",
					YANGDetails: YANGNodeDetails{
						Name:         "list",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/b-struct/list",
						ResolvedPath: "",
					},
					Type:                    ListNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"list"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/b-struct",
			BelongingModule: "exmod",
		},
		want: wantGoStructOut{wantErr: true},
	}, {
		name: "struct with keyless list",
		inStructToMap: &ParsedDirectory{
			Name: "QStruct",
			Fields: map[string]*NodeDetails{
				"a-list": {
					Name: "AList",
					YANGDetails: YANGNodeDetails{
						Name:         "a-list",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/q-struct/a-list",
						ResolvedPath: "",
					},
					Type:                    ListNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"a-list"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/q-struct",
			BelongingModule: "exmod",
		},
		inOtherStructMap: map[string]*ParsedDirectory{
			"/root-module/q-struct/a-list": {
				Name:            "QStruct_AList",
				BelongingModule: "exmod",
			},
		},
		want: wantGoStructOut{
			structs: `
// QStruct represents the /root-module/q-struct YANG schema element.
type QStruct struct {
	AList	[]*QStruct_AList	` + "`" + `path:"a-list" module:"exmod"` + "`" + `
}

// IsYANGGoStruct ensures that QStruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*QStruct) IsYANGGoStruct() {}
`,
			methods: `
// Validate validates s against the YANG schema corresponding to its type.
func (t *QStruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["QStruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *QStruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// QStruct belongs.
func (*QStruct) ΛBelongingModule() string {
	return "exmod"
}
`,
		},
	}, {
		name: "struct with single key list",
		inStructToMap: &ParsedDirectory{
			Name: "Tstruct",
			Type: Container,
			Fields: map[string]*NodeDetails{
				"listWithKey": {
					Name: "ListWithKey",
					YANGDetails: YANGNodeDetails{
						Name:         "list-with-key",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/tstruct/listWithKey",
						ResolvedPath: "",
					},
					Type:                    ListNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"listWithKey"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/tstruct",
			BelongingModule: "exmod",
		},
		inOtherStructMap: map[string]*ParsedDirectory{
			"/root-module/tstruct/listWithKey": {
				Name: "ListWithKey",
				Type: List,
				Fields: map[string]*NodeDetails{
					"keyLeaf": {
						Name: "keyLeaf",
						YANGDetails: YANGNodeDetails{
							Name:         "keyLeaf",
							Defaults:     nil,
							Module:       "exmod",
							Path:         "/root-module/tstruct/listWithKey/keyLeaf",
							ResolvedPath: "",
						},
						Type: LeafNode,
						LangType: &MappedType{
							NativeType: "string",
							UnionTypes: nil,
							ZeroValue:  `""`,
						},
						MappedPaths:             [][]string{{"keyLeaf"}},
						MappedPathModules:       [][]string{{"exmod"}},
						ShadowMappedPaths:       nil,
						ShadowMappedPathModules: nil,
					},
				},
				ListKeys: map[string]*ListKey{
					"keyLeaf": {
						Name: "KeyLeaf",
						LangType: &MappedType{
							NativeType: "string",
							UnionTypes: nil,
							ZeroValue:  `""`,
						},
					},
				},
				ListKeyYANGNames: []string{"keyLeaf"},
				Path:             "/root-module/tstruct/listWithKey",
				BelongingModule:  "exmod",
			},
		},
		inGoOpts: GoOpts{
			GenerateRenameMethod: true,
		},
		want: wantGoStructOut{
			structs: `
// Tstruct represents the /root-module/tstruct YANG schema element.
type Tstruct struct {
	ListWithKey	map[string]*ListWithKey	` + "`" + `path:"listWithKey" module:"exmod"` + "`" + `
}

// IsYANGGoStruct ensures that Tstruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Tstruct) IsYANGGoStruct() {}
`,
			methods: `
// NewListWithKey creates a new entry in the ListWithKey list of the
// Tstruct struct. The keys of the list are populated from the input
// arguments.
func (t *Tstruct) NewListWithKey(KeyLeaf string) (*ListWithKey, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ListWithKey == nil {
		t.ListWithKey = make(map[string]*ListWithKey)
	}

	key := KeyLeaf

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ListWithKey[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ListWithKey", key)
	}

	t.ListWithKey[key] = &ListWithKey{
		KeyLeaf: &KeyLeaf,
	}

	return t.ListWithKey[key], nil
}

// RenameListWithKey renames an entry in the list ListWithKey within
// the Tstruct struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Tstruct) RenameListWithKey(oldK, newK string) error {
	if _, ok := t.ListWithKey[newK]; ok {
		return fmt.Errorf("key %v already exists in ListWithKey", newK)
	}

	e, ok := t.ListWithKey[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ListWithKey", oldK)
	}
	e.KeyLeaf = &newK

	t.ListWithKey[newK] = e
	delete(t.ListWithKey, oldK)
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Tstruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Tstruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Tstruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// Tstruct belongs.
func (*Tstruct) ΛBelongingModule() string {
	return "exmod"
}
`,
		},
	}, {
		name: "missing list definition element",
		inStructToMap: &ParsedDirectory{
			Name: "Tstruct",
			Type: Container,
			Fields: map[string]*NodeDetails{
				"listWithKey": {
					Name: "ListWithKey",
					YANGDetails: YANGNodeDetails{
						Name:         "list-with-key",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/tstruct/listWithKey",
						ResolvedPath: "",
					},
					Type:                    ListNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"listWithKey"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/tstruct",
			BelongingModule: "exmod",
		},
		want: wantGoStructOut{wantErr: true},
	}, {
		name: "unknown kind",
		inStructToMap: &ParsedDirectory{
			Name: "AStruct",
			Fields: map[string]*NodeDetails{
				"anydata": {
					Name: "anydata",
					Type: AnyDataNode,
				},
			},
			BelongingModule: "exmod",
		},
		want: wantGoStructOut{wantErr: true},
	}, {
		name: "unknown field type",
		inStructToMap: &ParsedDirectory{
			Name: "AStruct",
			Fields: map[string]*NodeDetails{
				"idd": {
					Name: "Idd",
					YANGDetails: YANGNodeDetails{
						Name:         "idd",
						Defaults:     nil,
						Module:       "mod",
						Path:         "/mod/container-two/container/idd",
						ResolvedPath: "",
					},
					Type:                    InvalidNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"idd"}},
					MappedPathModules:       [][]string{{"mod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path: "/mod/container-two/container",
		},
		want: wantGoStructOut{wantErr: true},
	}, {
		name: "struct with multi-key list",
		inStructToMap: &ParsedDirectory{
			Name: "Tstruct",
			Type: Container,
			Fields: map[string]*NodeDetails{
				"listWithKey": {
					Name: "ListWithKey",
					YANGDetails: YANGNodeDetails{
						Name:         "list-with-key",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/tstruct/listWithKey",
						ResolvedPath: "",
					},
					Type:                    ListNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"listWithKey"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/tstruct",
			BelongingModule: "exmod",
		},
		inOtherStructMap: map[string]*ParsedDirectory{
			"/root-module/tstruct/listWithKey": {
				Name: "Tstruct_ListWithKey",
				Type: List,
				Fields: map[string]*NodeDetails{
					"keyLeafOne": {
						Name: "keyLeafOne",
						YANGDetails: YANGNodeDetails{
							Name:         "keyLeafOne",
							Defaults:     nil,
							Module:       "exmod",
							Path:         "/root-module/tstruct/listWithKey/keyLeafOne",
							ResolvedPath: "",
						},
						Type: LeafNode,
						LangType: &MappedType{
							NativeType: "string",
							UnionTypes: nil,
							ZeroValue:  `""`,
						},
						MappedPaths:             [][]string{{"keyLeafOne"}},
						MappedPathModules:       [][]string{{"exmod"}},
						ShadowMappedPaths:       nil,
						ShadowMappedPathModules: nil,
					},
					"keyLeafTwo": {
						Name: "keyLeafTwo",
						YANGDetails: YANGNodeDetails{
							Name:         "keyLeafTwo",
							Defaults:     nil,
							Module:       "exmod",
							Path:         "/root-module/tstruct/listWithKey/keyLeafTwo",
							ResolvedPath: "",
						},
						Type: LeafNode,
						LangType: &MappedType{
							NativeType: "int8",
							UnionTypes: nil,
							ZeroValue:  "0",
						},
						MappedPaths:             [][]string{{"keyLeafTwo"}},
						MappedPathModules:       [][]string{{"exmod"}},
						ShadowMappedPaths:       nil,
						ShadowMappedPathModules: nil,
					},
				},
				ListKeys: map[string]*ListKey{
					"keyLeafOne": {
						Name: "KeyLeafOne",
						LangType: &MappedType{
							NativeType: "string",
							UnionTypes: nil,
							ZeroValue:  `""`,
						},
					},
					"keyLeafTwo": {
						Name: "KeyLeafTwo",
						LangType: &MappedType{
							NativeType: "int8",
							UnionTypes: nil,
							ZeroValue:  `""`,
						},
					},
				},
				ListKeyYANGNames: []string{"keyLeafOne", "keyLeafTwo"},
				Path:             "/root-module/tstruct/listWithKey",
				BelongingModule:  "exmod",
			},
		},
		inGoOpts: GoOpts{
			GenerateRenameMethod: true,
		},
		want: wantGoStructOut{
			structs: `
// Tstruct represents the /root-module/tstruct YANG schema element.
type Tstruct struct {
	ListWithKey	map[Tstruct_ListWithKey_Key]*Tstruct_ListWithKey	` + "`" + `path:"listWithKey" module:"exmod"` + "`" + `
}

// IsYANGGoStruct ensures that Tstruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Tstruct) IsYANGGoStruct() {}
`,
			keys: `
// Tstruct_ListWithKey_Key represents the key for list ListWithKey of element /root-module/tstruct.
type Tstruct_ListWithKey_Key struct {
	KeyLeafOne	string	` + "`" + `path:"keyLeafOne"` + "`" + `
	KeyLeafTwo	int8	` + "`" + `path:"keyLeafTwo"` + "`" + `
}
`,
			methods: `
// NewListWithKey creates a new entry in the ListWithKey list of the
// Tstruct struct. The keys of the list are populated from the input
// arguments.
func (t *Tstruct) NewListWithKey(KeyLeafOne string, KeyLeafTwo int8) (*Tstruct_ListWithKey, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ListWithKey == nil {
		t.ListWithKey = make(map[Tstruct_ListWithKey_Key]*Tstruct_ListWithKey)
	}

	key := Tstruct_ListWithKey_Key{
		KeyLeafOne: KeyLeafOne,
		KeyLeafTwo: KeyLeafTwo,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ListWithKey[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ListWithKey", key)
	}

	t.ListWithKey[key] = &Tstruct_ListWithKey{
		KeyLeafOne: &KeyLeafOne,
		KeyLeafTwo: &KeyLeafTwo,
	}

	return t.ListWithKey[key], nil
}

// RenameListWithKey renames an entry in the list ListWithKey within
// the Tstruct struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Tstruct) RenameListWithKey(oldK, newK Tstruct_ListWithKey_Key) error {
	if _, ok := t.ListWithKey[newK]; ok {
		return fmt.Errorf("key %v already exists in ListWithKey", newK)
	}

	e, ok := t.ListWithKey[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ListWithKey", oldK)
	}
	e.KeyLeafOne = &newK.KeyLeafOne
	e.KeyLeafTwo = &newK.KeyLeafTwo

	t.ListWithKey[newK] = e
	delete(t.ListWithKey, oldK)
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Tstruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Tstruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Tstruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// Tstruct belongs.
func (*Tstruct) ΛBelongingModule() string {
	return "exmod"
}
`,
		},
	}, {
		name: "annotated struct",
		inStructToMap: &ParsedDirectory{
			Name: "Tstruct",
			Type: Container,
			Fields: map[string]*NodeDetails{
				"f1": {
					Name: "F1",
					YANGDetails: YANGNodeDetails{
						Name:         "f1",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/tstruct/f1",
						ResolvedPath: "",
					},
					Type: LeafNode,
					LangType: &MappedType{
						NativeType:        "int8",
						UnionTypes:        nil,
						IsEnumeratedValue: false,
						ZeroValue:         "0",
						DefaultValue:      nil,
					},
					MappedPaths:             [][]string{{"f1"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/tstruct",
			BelongingModule: "exmod",
		},
		inGoOpts: GoOpts{
			AddAnnotationFields: true,
			AnnotationPrefix:    "Ω",
		},
		want: wantGoStructOut{
			structs: `
// Tstruct represents the /root-module/tstruct YANG schema element.
type Tstruct struct {
	ΩMetadata	[]ygot.Annotation	` + "`" + `path:"@" ygotAnnotation:"true"` + "`" + `
	F1	*int8	` + "`" + `path:"f1" module:"exmod"` + "`" + `
	ΩF1	[]ygot.Annotation	` + "`" + `path:"@f1" ygotAnnotation:"true"` + "`" + `
}

// IsYANGGoStruct ensures that Tstruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Tstruct) IsYANGGoStruct() {}
`,
			methods: `
// Validate validates s against the YANG schema corresponding to its type.
func (t *Tstruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Tstruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Tstruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// Tstruct belongs.
func (*Tstruct) ΛBelongingModule() string {
	return "exmod"
}
`,
		},
	}, {
		name: "struct with multi-key list - append and getters",
		inStructToMap: &ParsedDirectory{
			Name: "Tstruct",
			Type: Container,
			Fields: map[string]*NodeDetails{
				"listWithKey": {
					Name: "ListWithKey",
					YANGDetails: YANGNodeDetails{
						Name:         "list-with-key",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/tstruct/listWithKey",
						ResolvedPath: "",
					},
					Type:                    ListNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"listWithKey"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/tstruct",
			BelongingModule: "exmod",
		},
		inOtherStructMap: map[string]*ParsedDirectory{
			"/root-module/tstruct/listWithKey": {
				Name: "Tstruct_ListWithKey",
				Type: List,
				Fields: map[string]*NodeDetails{
					"keyLeafOne": {
						Name: "keyLeafOne",
						YANGDetails: YANGNodeDetails{
							Name:         "keyLeafOne",
							Defaults:     nil,
							Module:       "exmod",
							Path:         "/root-module/tstruct/listWithKey/keyLeafOne",
							ResolvedPath: "",
						},
						Type: LeafNode,
						LangType: &MappedType{
							NativeType: "string",
							UnionTypes: nil,
							ZeroValue:  `""`,
						},
						MappedPaths:             [][]string{{"keyLeafOne"}},
						MappedPathModules:       [][]string{{"exmod"}},
						ShadowMappedPaths:       nil,
						ShadowMappedPathModules: nil,
					},
					"keyLeafTwo": {
						Name: "keyLeafTwo",
						YANGDetails: YANGNodeDetails{
							Name:         "keyLeafTwo",
							Defaults:     nil,
							Module:       "exmod",
							Path:         "/root-module/tstruct/listWithKey/keyLeafTwo",
							ResolvedPath: "",
						},
						Type: LeafNode,
						LangType: &MappedType{
							NativeType: "int8",
							UnionTypes: nil,
							ZeroValue:  "0",
						},
						MappedPaths:             [][]string{{"keyLeafTwo"}},
						MappedPathModules:       [][]string{{"exmod"}},
						ShadowMappedPaths:       nil,
						ShadowMappedPathModules: nil,
					},
				},
				ListKeys: map[string]*ListKey{
					"keyLeafOne": {
						Name: "KeyLeafOne",
						LangType: &MappedType{
							NativeType: "string",
							UnionTypes: nil,
							ZeroValue:  `""`,
						},
					},
					"keyLeafTwo": {
						Name: "KeyLeafTwo",
						LangType: &MappedType{
							NativeType: "int8",
							UnionTypes: nil,
							ZeroValue:  `""`,
						},
					},
				},
				ListKeyYANGNames: []string{"keyLeafOne", "keyLeafTwo"},
				Path:             "/root-module/tstruct/listWithKey",
				BelongingModule:  "exmod",
			},
		},
		inGoOpts: GoOpts{
			GenerateAppendMethod: true,
			GenerateGetters:      true,
			GenerateDeleteMethod: true,
		},
		want: wantGoStructOut{
			structs: `
// Tstruct represents the /root-module/tstruct YANG schema element.
type Tstruct struct {
	ListWithKey	map[Tstruct_ListWithKey_Key]*Tstruct_ListWithKey	` + "`" + `path:"listWithKey" module:"exmod"` + "`" + `
}

// IsYANGGoStruct ensures that Tstruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Tstruct) IsYANGGoStruct() {}
`,
			keys: `
// Tstruct_ListWithKey_Key represents the key for list ListWithKey of element /root-module/tstruct.
type Tstruct_ListWithKey_Key struct {
	KeyLeafOne	string	` + "`" + `path:"keyLeafOne"` + "`" + `
	KeyLeafTwo	int8	` + "`" + `path:"keyLeafTwo"` + "`" + `
}
`,
			methods: `
// NewListWithKey creates a new entry in the ListWithKey list of the
// Tstruct struct. The keys of the list are populated from the input
// arguments.
func (t *Tstruct) NewListWithKey(KeyLeafOne string, KeyLeafTwo int8) (*Tstruct_ListWithKey, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ListWithKey == nil {
		t.ListWithKey = make(map[Tstruct_ListWithKey_Key]*Tstruct_ListWithKey)
	}

	key := Tstruct_ListWithKey_Key{
		KeyLeafOne: KeyLeafOne,
		KeyLeafTwo: KeyLeafTwo,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ListWithKey[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ListWithKey", key)
	}

	t.ListWithKey[key] = &Tstruct_ListWithKey{
		KeyLeafOne: &KeyLeafOne,
		KeyLeafTwo: &KeyLeafTwo,
	}

	return t.ListWithKey[key], nil
}

// GetOrCreateListWithKey retrieves the value with the specified keys from
// the receiver Tstruct. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Tstruct) GetOrCreateListWithKey(KeyLeafOne string, KeyLeafTwo int8) (*Tstruct_ListWithKey){

	key := Tstruct_ListWithKey_Key{
		KeyLeafOne: KeyLeafOne,
		KeyLeafTwo: KeyLeafTwo,
	}

	if v, ok := t.ListWithKey[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewListWithKey(KeyLeafOne, KeyLeafTwo)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateListWithKey got unexpected error: %v", err))
	}
	return v
}

// GetListWithKey retrieves the value with the specified key from
// the ListWithKey map field of Tstruct. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Tstruct) GetListWithKey(KeyLeafOne string, KeyLeafTwo int8) (*Tstruct_ListWithKey){

	if t == nil {
		return nil
	}

  key := Tstruct_ListWithKey_Key{
		KeyLeafOne: KeyLeafOne,
		KeyLeafTwo: KeyLeafTwo,
	}

  if lm, ok := t.ListWithKey[key]; ok {
    return lm
  }
  return nil
}

// DeleteListWithKey deletes the value with the specified keys from
// the receiver Tstruct. If there is no such element, the function
// is a no-op.
func (t *Tstruct) DeleteListWithKey(KeyLeafOne string, KeyLeafTwo int8) {
	key := Tstruct_ListWithKey_Key{
		KeyLeafOne: KeyLeafOne,
		KeyLeafTwo: KeyLeafTwo,
	}

	delete(t.ListWithKey, key)
}

// AppendListWithKey appends the supplied Tstruct_ListWithKey struct to the
// list ListWithKey of Tstruct. If the key value(s) specified in
// the supplied Tstruct_ListWithKey already exist in the list, an error is
// returned.
func (t *Tstruct) AppendListWithKey(v *Tstruct_ListWithKey) error {
	if v.KeyLeafOne == nil {
		return fmt.Errorf("invalid nil key for KeyLeafOne")
	}

	if v.KeyLeafTwo == nil {
		return fmt.Errorf("invalid nil key for KeyLeafTwo")
	}

	key := Tstruct_ListWithKey_Key{
		KeyLeafOne: *v.KeyLeafOne,
		KeyLeafTwo: *v.KeyLeafTwo,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ListWithKey == nil {
		t.ListWithKey = make(map[Tstruct_ListWithKey_Key]*Tstruct_ListWithKey)
	}

	if _, ok := t.ListWithKey[key]; ok {
		return fmt.Errorf("duplicate key for list ListWithKey %v", key)
	}

	t.ListWithKey[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Tstruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Tstruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Tstruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// Tstruct belongs.
func (*Tstruct) ΛBelongingModule() string {
	return "exmod"
}
`,
		},
	}, {
		name: "struct with single key list - append and getters",
		inStructToMap: &ParsedDirectory{
			Name: "Tstruct",
			Type: Container,
			Fields: map[string]*NodeDetails{
				"listWithKey": {
					Name: "ListWithKey",
					YANGDetails: YANGNodeDetails{
						Name:         "list-with-key",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/tstruct/listWithKey",
						ResolvedPath: "",
					},
					Type:                    ListNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"listWithKey"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/tstruct",
			BelongingModule: "exmod",
		},
		inOtherStructMap: map[string]*ParsedDirectory{
			"/root-module/tstruct/listWithKey": {
				Name: "Tstruct_ListWithKey",
				Type: List,
				Fields: map[string]*NodeDetails{
					"keyLeaf": {
						Name: "keyLeaf",
						YANGDetails: YANGNodeDetails{
							Name:         "keyLeaf",
							Defaults:     nil,
							Module:       "exmod",
							Path:         "/root-module/tstruct/listWithKey/keyLeaf",
							ResolvedPath: "",
						},
						Type: LeafNode,
						LangType: &MappedType{
							NativeType: "string",
							UnionTypes: nil,
							ZeroValue:  `""`,
						},
						MappedPaths:             [][]string{{"keyLeaf"}},
						MappedPathModules:       [][]string{{"exmod"}},
						ShadowMappedPaths:       nil,
						ShadowMappedPathModules: nil,
					},
				},
				ListKeys: map[string]*ListKey{
					"keyLeaf": {
						Name: "KeyLeaf",
						LangType: &MappedType{
							NativeType: "string",
							UnionTypes: nil,
							ZeroValue:  `""`,
						},
					},
				},
				ListKeyYANGNames: []string{"keyLeaf"},
				Path:             "/root-module/tstruct/listWithKey",
				BelongingModule:  "exmod",
			},
		},
		inGoOpts: GoOpts{
			GenerateAppendMethod:    true,
			GenerateGetters:         true,
			GenerateDeleteMethod:    true,
			GeneratePopulateDefault: true,
		},
		want: wantGoStructOut{
			structs: `
// Tstruct represents the /root-module/tstruct YANG schema element.
type Tstruct struct {
	ListWithKey	map[string]*Tstruct_ListWithKey	` + "`" + `path:"listWithKey" module:"exmod"` + "`" + `
}

// IsYANGGoStruct ensures that Tstruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Tstruct) IsYANGGoStruct() {}
`,
			methods: `
// NewListWithKey creates a new entry in the ListWithKey list of the
// Tstruct struct. The keys of the list are populated from the input
// arguments.
func (t *Tstruct) NewListWithKey(KeyLeaf string) (*Tstruct_ListWithKey, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ListWithKey == nil {
		t.ListWithKey = make(map[string]*Tstruct_ListWithKey)
	}

	key := KeyLeaf

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ListWithKey[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ListWithKey", key)
	}

	t.ListWithKey[key] = &Tstruct_ListWithKey{
		KeyLeaf: &KeyLeaf,
	}

	return t.ListWithKey[key], nil
}

// GetOrCreateListWithKey retrieves the value with the specified keys from
// the receiver Tstruct. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Tstruct) GetOrCreateListWithKey(KeyLeaf string) (*Tstruct_ListWithKey){

	key := KeyLeaf

	if v, ok := t.ListWithKey[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewListWithKey(KeyLeaf)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateListWithKey got unexpected error: %v", err))
	}
	return v
}

// GetListWithKey retrieves the value with the specified key from
// the ListWithKey map field of Tstruct. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Tstruct) GetListWithKey(KeyLeaf string) (*Tstruct_ListWithKey){

	if t == nil {
		return nil
	}

  key := KeyLeaf

  if lm, ok := t.ListWithKey[key]; ok {
    return lm
  }
  return nil
}

// DeleteListWithKey deletes the value with the specified keys from
// the receiver Tstruct. If there is no such element, the function
// is a no-op.
func (t *Tstruct) DeleteListWithKey(KeyLeaf string) {
	key := KeyLeaf

	delete(t.ListWithKey, key)
}

// AppendListWithKey appends the supplied Tstruct_ListWithKey struct to the
// list ListWithKey of Tstruct. If the key value(s) specified in
// the supplied Tstruct_ListWithKey already exist in the list, an error is
// returned.
func (t *Tstruct) AppendListWithKey(v *Tstruct_ListWithKey) error {
	if v.KeyLeaf == nil {
		return fmt.Errorf("invalid nil key received for KeyLeaf")
	}

	key := *v.KeyLeaf

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ListWithKey == nil {
		t.ListWithKey = make(map[string]*Tstruct_ListWithKey)
	}

	if _, ok := t.ListWithKey[key]; ok {
		return fmt.Errorf("duplicate key for list ListWithKey %v", key)
	}

	t.ListWithKey[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Tstruct
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Tstruct) PopulateDefaults() {
	if (t == nil) {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.ListWithKey {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Tstruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Tstruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Tstruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// Tstruct belongs.
func (*Tstruct) ΛBelongingModule() string {
	return "exmod"
}
`,
		},
	}, {
		name: "struct with child container - getters generated",
		inStructToMap: &ParsedDirectory{
			Name: "InputStruct",
			Type: Container,
			Fields: map[string]*NodeDetails{
				"c1": {
					Name: "C1",
					YANGDetails: YANGNodeDetails{
						Name:         "c1",
						Defaults:     nil,
						Module:       "exmod",
						Path:         "/root-module/input-struct/c1",
						ResolvedPath: "",
					},
					Type:                    ContainerNode,
					LangType:                nil,
					MappedPaths:             [][]string{{"c1"}},
					MappedPathModules:       [][]string{{"exmod"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/root-module/input-struct",
			BelongingModule: "exmod",
		},
		inOtherStructMap: map[string]*ParsedDirectory{
			"/root-module/input-struct/c1": {
				Name:            "InputStruct_C1",
				Path:            "/root-module/input-struct/c1",
				BelongingModule: "exmod",
			},
		},
		inGoOpts: GoOpts{
			GenerateGetters:         true,
			GeneratePopulateDefault: true,
		},
		want: wantGoStructOut{
			structs: `
// InputStruct represents the /root-module/input-struct YANG schema element.
type InputStruct struct {
	C1	*InputStruct_C1	` + "`" + `path:"c1" module:"exmod"` + "`" + `
}

// IsYANGGoStruct ensures that InputStruct implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*InputStruct) IsYANGGoStruct() {}
`,
			methods: `
// GetOrCreateC1 retrieves the value of the C1 field
// or returns the existing field if it already exists.
func (t *InputStruct) GetOrCreateC1() *InputStruct_C1 {
	if t.C1 != nil {
		return t.C1
	}
	t.C1 = &InputStruct_C1{}
	return t.C1
}

// GetC1 returns the value of the C1 struct pointer
// from InputStruct. If the receiver or the field C1 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *InputStruct) GetC1() *InputStruct_C1 {
	if t != nil && t.C1 != nil {
		return t.C1
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the InputStruct
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *InputStruct) PopulateDefaults() {
	if (t == nil) {
		return
	}
	ygot.BuildEmptyTree(t)
	t.C1.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *InputStruct) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["InputStruct"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *InputStruct) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// InputStruct belongs.
func (*InputStruct) ΛBelongingModule() string {
	return "exmod"
}
`,
		},
	}, {
		name: "container with leaf getters",
		inStructToMap: &ParsedDirectory{
			Name: "Container",
			Fields: map[string]*NodeDetails{
				"leaf": {
					Name: "Leaf",
					YANGDetails: YANGNodeDetails{
						Name:         "leaf",
						Defaults:     nil,
						Module:       "m1",
						Path:         "/m1/foo/bar/leaf",
						ResolvedPath: "",
					},
					Type: LeafNode,
					LangType: &MappedType{
						NativeType:        "string",
						UnionTypes:        nil,
						IsEnumeratedValue: false,
						ZeroValue:         `""`,
						DefaultValue:      nil,
					},
					MappedPaths:             [][]string{{"bar", "leaf"}},
					MappedPathModules:       [][]string{{"m1", "m1"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/m1/foo",
			BelongingModule: "m1",
		},
		inGoOpts: GoOpts{
			GenerateLeafGetters:     true,
			GeneratePopulateDefault: true,
		},
		want: wantGoStructOut{
			structs: `
// Container represents the /m1/foo YANG schema element.
type Container struct {
	Leaf	*string	` + "`" + `path:"bar/leaf" module:"m1/m1"` + "`" + `
}

// IsYANGGoStruct ensures that Container implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Container) IsYANGGoStruct() {}
`,
			methods: `
// GetLeaf retrieves the value of the leaf Leaf from the Container
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Leaf is set, it can
// safely use t.GetLeaf() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Leaf == nil' before retrieving the leaf's value.
func (t *Container) GetLeaf() string {
	if t == nil || t.Leaf == nil {
		return ""
	}
	return *t.Leaf
}

// PopulateDefaults recursively populates unset leaf fields in the Container
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Container) PopulateDefaults() {
	if (t == nil) {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Container) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Container"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Container) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// Container belongs.
func (*Container) ΛBelongingModule() string {
	return "m1"
}
`,
		},
	}, {
		name: "leaf getter with default value",
		inStructToMap: &ParsedDirectory{
			Name: "Container",
			Fields: map[string]*NodeDetails{
				"leaf": {
					Name: "Leaf",
					YANGDetails: YANGNodeDetails{
						Name:         "leaf",
						Defaults:     []string{"DEFAULT VALUE"},
						Module:       "m1",
						Path:         "/m1/foo/bar/leaf",
						ResolvedPath: "",
					},
					Type: LeafNode,
					LangType: &MappedType{
						NativeType:        "string",
						UnionTypes:        nil,
						IsEnumeratedValue: false,
						ZeroValue:         `""`,
						DefaultValue:      ygot.String(`"DEFAULT VALUE"`),
					},
					MappedPaths:             [][]string{{"bar", "leaf"}},
					MappedPathModules:       [][]string{{"m1", "m1"}},
					ShadowMappedPaths:       nil,
					ShadowMappedPathModules: nil,
				},
			},
			Path:            "/m1/foo",
			BelongingModule: "m1",
		},
		inGoOpts: GoOpts{
			GenerateLeafGetters:     true,
			GeneratePopulateDefault: true,
		},
		want: wantGoStructOut{
			structs: `
// Container represents the /m1/foo YANG schema element.
type Container struct {
	Leaf	*string	` + "`" + `path:"bar/leaf" module:"m1/m1"` + "`" + `
}

// IsYANGGoStruct ensures that Container implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Container) IsYANGGoStruct() {}
`,
			methods: `
// GetLeaf retrieves the value of the leaf Leaf from the Container
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Leaf is set, it can
// safely use t.GetLeaf() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Leaf == nil' before retrieving the leaf's value.
func (t *Container) GetLeaf() string {
	if t == nil || t.Leaf == nil {
		return "DEFAULT VALUE"
	}
	return *t.Leaf
}

// PopulateDefaults recursively populates unset leaf fields in the Container
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Container) PopulateDefaults() {
	if (t == nil) {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Leaf == nil {
		var v string = "DEFAULT VALUE"
		t.Leaf = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Container) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Container"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Container) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module in whose namespace
// Container belongs.
func (*Container) ΛBelongingModule() string {
	return "m1"
}
`,
		},
	}}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Fill the current directory into the map to reduce test size.
			if tt.inOtherStructMap == nil {
				tt.inOtherStructMap = map[string]*ParsedDirectory{}
			}
			tt.inOtherStructMap[tt.inStructToMap.Path] = tt.inStructToMap
			// Always generate the JSON schema for this test.
			generatedUnions := map[string]bool{}
			got, errs := writeGoStruct(tt.inStructToMap, tt.inOtherStructMap, generatedUnions, tt.inIgnoreShadowSchemaPaths, tt.inGoOpts, true)

			if len(errs) != 0 && !tt.want.wantErr {
				t.Fatalf("%s writeGoStruct(targetStruct: %v): received unexpected errors: %v",
					tt.name, tt.inStructToMap, errs)
			}

			if len(errs) == 0 && tt.want.wantErr {
				t.Fatalf("%s writeGoStruct(targetStruct: %v): did not receive expected errors",
					tt.name, tt.inStructToMap)
			}

			// If we wanted an error, then skip the rest of the tests as the generated code will not
			// be correct.
			if tt.want.wantErr {
				return
			}

			if diff := pretty.Compare(tt.want.structs, got.StructDef); diff != "" {
				if diffl, err := testutil.GenerateUnifiedDiff(tt.want.structs, got.StructDef); err == nil {
					diff = diffl
				}
				t.Errorf("%s writeGoStruct(targetStruct: %v): struct generated code was not correct, diff (-want, +got):\n%s",
					tt.name, tt.inStructToMap, diff)
			}

			if diff := pretty.Compare(tt.want.keys, got.ListKeys); diff != "" {
				if diffl, err := testutil.GenerateUnifiedDiff(tt.want.keys, got.ListKeys); err == nil {
					diff = diffl
				}
				t.Errorf("%s writeGoStruct(targetStruct: %v): structs generated as list keys incorrect, diff (-want, +got):\n%s",
					tt.name, tt.inStructToMap, diff)
			}

			if diff := pretty.Compare(tt.want.methods, got.Methods); diff != "" {
				if diffl, err := testutil.GenerateUnifiedDiff(tt.want.methods, got.Methods); err == nil {
					diff = diffl
				}
				t.Errorf("%s writeGoStruct(targetStruct: %v): generated methods incorrect, diff (-want, +got):\n%s",
					tt.name, tt.inStructToMap, diff)
			}

			if diff := pretty.Compare(tt.want.interfaces, got.Interfaces); diff != "" {
				if diffl, err := testutil.GenerateUnifiedDiff(tt.want.interfaces, got.Interfaces); err == nil {
					diff = diffl
				}
				t.Errorf("%s: writeGoStruct(targetStruct: %v): interfaces generated for struct incorrect, diff (-want, +got):\n%s",
					tt.name, tt.inStructToMap, diff)
			}
		})
	}
}

// TestGenGoEnumeratedTypes validates the enumerated type code generation from a YANG
// module.
func TestGenGoEnumeratedTypes(t *testing.T) {
	// In order to create a mock enum within goyang, we must construct it using the
	// relevant methods, since the field of the EnumType struct (toString) that we
	// need to set is not publicly exported.
	testEnumerations := map[string][]string{
		"enumOne": {"SPEED_2.5G", "SPEED-40G"},
		"enumTwo": {"VALUE_1", "VALUE_2", "VALUE_3", "VALUE_4"},
	}
	testYangEnums := make(map[string]*yang.EnumType)

	for name, values := range testEnumerations {
		enum := yang.NewEnumType()
		for i, enumValue := range values {
			enum.Set(enumValue, int64(i))
		}
		testYangEnums[name] = enum
	}

	tests := []struct {
		name string
		in   map[string]*EnumeratedYANGType
		want map[string]*goEnumeratedType
	}{{
		name: "enum",
		in: map[string]*EnumeratedYANGType{
			"foo": {
				Name:     "EnumeratedValue",
				Kind:     SimpleEnumerationType,
				TypeName: "enumerated-value",
				ValToYANGDetails: []ygot.EnumDefinition{
					{
						Name:           "VALUE_A",
						DefiningModule: "",
					},
					{
						Name:           "VALUE_B",
						DefiningModule: "",
					},
					{
						Name:           "VALUE_C",
						DefiningModule: "",
					},
				},
			},
		},
		want: map[string]*goEnumeratedType{
			"EnumeratedValue": {
				Name: "EnumeratedValue",
				CodeValues: map[int64]string{
					0: "UNSET",
					1: "VALUE_A",
					2: "VALUE_B",
					3: "VALUE_C",
				},
				YANGValues: map[int64]ygot.EnumDefinition{
					1: {
						Name:           "VALUE_A",
						DefiningModule: "",
					},
					2: {
						Name:           "VALUE_B",
						DefiningModule: "",
					},
					3: {
						Name:           "VALUE_C",
						DefiningModule: "",
					},
				},
			},
		},
	}}

	for _, tt := range tests {
		got, err := genGoEnumeratedTypes(tt.in)
		if err != nil {
			t.Errorf("%s: genGoEnumeratedTypes(%v): got unexpected error: %v",
				tt.name, tt.in, err)
			continue
		}

		if diff := cmp.Diff(tt.want, got); diff != "" {
			t.Errorf("%s: genGoEnumeratedTypes(%v): got incorrect output, diff(-want, +got):\n%s",
				tt.name, tt.in, diff)
		}
	}
}

// TestWriteGoEnum validates the enumerated type code generation from a parsed enum.
func TestWriteGoEnum(t *testing.T) {
	tests := []struct {
		name string
		in   *goEnumeratedType
		want string
	}{{
		name: "enum from identityref",
		in: &goEnumeratedType{
			Name: "EnumeratedValue",
			CodeValues: map[int64]string{
				0: "UNSET",
				1: "VALUE_A",
				2: "VALUE_B",
				3: "VALUE_C",
			},
		},
		want: `
// E_EnumeratedValue is a derived int64 type which is used to represent
// the enumerated node EnumeratedValue. An additional value named
// EnumeratedValue_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_EnumeratedValue int64

// IsYANGGoEnum ensures that EnumeratedValue implements the yang.GoEnum
// interface. This ensures that EnumeratedValue can be identified as a
// mapped type for a YANG enumeration.
func (E_EnumeratedValue) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  EnumeratedValue.
func (E_EnumeratedValue) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_EnumeratedValue.
func (e E_EnumeratedValue) String() string {
	return ygot.EnumLogString(e, int64(e), "E_EnumeratedValue")
}

const (
	// EnumeratedValue_UNSET corresponds to the value UNSET of EnumeratedValue
	EnumeratedValue_UNSET E_EnumeratedValue = 0
	// EnumeratedValue_VALUE_A corresponds to the value VALUE_A of EnumeratedValue
	EnumeratedValue_VALUE_A E_EnumeratedValue = 1
	// EnumeratedValue_VALUE_B corresponds to the value VALUE_B of EnumeratedValue
	EnumeratedValue_VALUE_B E_EnumeratedValue = 2
	// EnumeratedValue_VALUE_C corresponds to the value VALUE_C of EnumeratedValue
	EnumeratedValue_VALUE_C E_EnumeratedValue = 3
)
`,
	}}

	for _, tt := range tests {
		got, err := writeGoEnum(tt.in)
		if err != nil {
			t.Errorf("%s: writeGoEnum(%v): got unexpected error: %v",
				tt.name, tt.in, err)
			continue
		}

		if diff := cmp.Diff(tt.want, got); diff != "" {
			fmt.Println(diff)
			if diffl, err := testutil.GenerateUnifiedDiff(tt.want, got); err == nil {
				diff = diffl
			}
			t.Errorf("%s: writeGoEnum(%v): got incorrect output, diff(-want, +got):\n%s",
				tt.name, tt.in, diff)
		}
	}
}

func TestWriteGoEnumMap(t *testing.T) {
	tests := []struct {
		name    string
		inMap   map[string]map[int64]ygot.EnumDefinition
		wantErr bool
		wantMap string
	}{{
		name: "simple map input",
		inMap: map[string]map[int64]ygot.EnumDefinition{
			"EnumOne": {
				1: {Name: "VAL1"},
				2: {Name: "VAL2"},
			},
		},
		wantMap: `
// ΛEnum is a map, keyed by the name of the type defined for each enum in the
// generated Go code, which provides a mapping between the constant int64 value
// of each value of the enumeration, and the string that is used to represent it
// in the YANG schema. The map is named ΛEnum in order to avoid clash with any
// valid YANG identifier.
var ΛEnum = map[string]map[int64]ygot.EnumDefinition{
	"E_EnumOne": {
		1: {Name: "VAL1"},
		2: {Name: "VAL2"},
	},
}
`,
	}, {
		name: "multiple enum input",
		inMap: map[string]map[int64]ygot.EnumDefinition{
			"EnumOne": {
				1: {Name: "VAL1"},
				2: {Name: "VAL2"},
			},
			"EnumTwo": {
				1: {Name: "VAL42"},
				2: {Name: "VAL43"},
			},
		},
		wantMap: `
// ΛEnum is a map, keyed by the name of the type defined for each enum in the
// generated Go code, which provides a mapping between the constant int64 value
// of each value of the enumeration, and the string that is used to represent it
// in the YANG schema. The map is named ΛEnum in order to avoid clash with any
// valid YANG identifier.
var ΛEnum = map[string]map[int64]ygot.EnumDefinition{
	"E_EnumOne": {
		1: {Name: "VAL1"},
		2: {Name: "VAL2"},
	},
	"E_EnumTwo": {
		1: {Name: "VAL42"},
		2: {Name: "VAL43"},
	},
}
`,
	}}

	for _, tt := range tests {
		got, err := writeGoEnumMap(tt.inMap)

		if err != nil {
			if !tt.wantErr {
				t.Errorf("%s: got unexpected error when generating map: %v", tt.name, err)
			}
			continue
		}

		if tt.wantMap != got {
			diff := fmt.Sprintf("got: %s, want %s", got, tt.wantMap)
			if diffl, err := testutil.GenerateUnifiedDiff(tt.wantMap, got); err == nil {
				diff = "diff (-want, +got):\n" + diffl
			}
			t.Errorf("%s: did not get expected generated enum, %s", tt.name, diff)
		}
	}
}

func TestGoLeafDefaults(t *testing.T) {
	tests := []struct {
		name   string
		inLeaf *yang.Entry
		inType *MappedType
		want   []string
	}{{
		name: "quoted default in leaf",
		inLeaf: &yang.Entry{
			Default: []string{"a-default-value"},
		},
		inType: &MappedType{NativeType: "string"},
		want:   []string{`"a-default-value"`},
	}, {
		name: "unquoted default in leaf",
		inLeaf: &yang.Entry{
			Default: []string{"42"},
		},
		inType: &MappedType{NativeType: "int32"},
		want:   []string{"42"},
	}, {
		name: "two quoted defaults in leaf",
		inLeaf: &yang.Entry{
			Default: []string{"a-default-value", "second"},
		},
		inType: &MappedType{NativeType: "string"},
		want:   []string{`"a-default-value"`, `"second"`},
	}, {
		name:   "no default",
		inLeaf: &yang.Entry{},
		inType: &MappedType{NativeType: "int32"},
	}, {
		name:   "default in type",
		inLeaf: &yang.Entry{},
		inType: &MappedType{NativeType: "int32", DefaultValue: ygot.String("0")},
		want:   []string{"0"},
	}, {
		name:   "enumerated default in leaf",
		inLeaf: &yang.Entry{Default: []string{"FORTY_TWO"}},
		inType: &MappedType{
			NativeType:        fmt.Sprintf("%sEnumType", goEnumPrefix),
			IsEnumeratedValue: true,
		},
		want: []string{"EnumType_FORTY_TWO"},
	}}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := goLeafDefaults(tt.inLeaf, tt.inType)
			if diff := cmp.Diff(tt.want, got); diff != "" {
				t.Fatalf("did not get expected default, (-want, +got):\n%s", diff)
			}
		})
	}
}
