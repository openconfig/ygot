// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package ygot contains helper methods for dealing with structs that represent
// a YANG schema. Particularly, it takes structs that represent a YANG schema -
// generated by ygen:
//	- Provides helper functions which simplify their usage such as functions
//	  to return pointers to a type.
//	- Renders structs to other output formats such as JSON, or gNMI
//	  notifications.
package ygot

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	gnmipb "github.com/openconfig/gnmi/proto/gnmi"
)

const (
	// indentString represents the default indentation string used for
	// JSON. Three spaces are used based on the legacy use of EmitJSON.
	indentString string = "   "
)

// structTagsToLibPaths takes an input struct field as a reflect.Type, and determines
// the set of validation library paths that it maps to. Returns the paths as a slice of
// empty interface slices, or an error.
func structTagToLibPaths(f reflect.StructField, parentPath *gnmiPath) ([]*gnmiPath, error) {
	if !parentPath.isValid() {
		return nil, fmt.Errorf("invalid path format in parentPath (%v, %v)", parentPath.stringSlicePath == nil, parentPath.pathElemPath == nil)
	}

	pathAnnotation, ok := f.Tag.Lookup("path")
	if !ok {
		return nil, fmt.Errorf("field did not specify a path")
	}

	var mapPaths []*gnmiPath
	tagPaths := strings.Split(pathAnnotation, "|")
	for _, p := range tagPaths {
		// Make a copy of the existing parent path so we can append to it without
		// modifying it for future paths.
		ePath := &gnmiPath{}

		if parentPath.isElementPath() {
			ePath.stringSlicePath = make([]string, len(parentPath.stringSlicePath))
			copy(ePath.stringSlicePath, parentPath.stringSlicePath)
		} else {
			ePath.pathElemPath = make([]*gnmipb.PathElem, len(parentPath.pathElemPath))
			copy(ePath.pathElemPath, parentPath.pathElemPath)
		}

		for _, pp := range strings.Split(p, "/") {
			// Handle empty path tags.
			if pp == "" {
				continue
			}
			if ePath.isElementPath() {
				ePath.stringSlicePath = append(ePath.stringSlicePath, pp)
			} else {
				ePath.pathElemPath = append(ePath.pathElemPath, &gnmipb.PathElem{Name: pp})
			}
		}
		mapPaths = append(mapPaths, ePath)
	}
	return mapPaths, nil
}

// enumFieldToString takes an input reflect.Value, which is type asserted to
// be a GoEnum, and resolves the string name corresponding to the value within
// the YANG schema. Returns the string name of the enum, a bool indicating
// whether the value was set, or an error. The appendModuleName specifies whether
// the defining module name should be appended to the enumerated value's name in
// the form "module:name", as per the encoding rules in RFC7951.
func enumFieldToString(field reflect.Value, appendModuleName bool) (string, bool, error) {
	// Generated structs can only have fields that are not pointers when they are enumerated
	// values, since these values have an UNSET value that allows us to determine when they
	// are not explicitly set by the user.
	// We check whether this is an enum field by checking whether the type implements the
	// GoEnum interface.
	enumVal, isEnum := field.Interface().(GoEnum)
	if !isEnum {
		return "", false, fmt.Errorf("supplied value was not a valid GoEnum: %v", field.Type())
	}

	e := reflect.ValueOf(enumVal)

	if e.Int() == 0 {
		// Enumerations are always derived int64 types, which have a default of
		// 0. The generated enumeration's _UNSET value is always zero, so we can
		// use this to determine that the enumeration was not explicitly set by
		// the user and skip mapping this leaf into the schema.
		return "", false, nil
	}

	// ΛMap returns a map that is keyed based on the name of the enumeration's Go type,
	// which provides a map between the integer values of the enumeration and the strings.
	// The ygen library expects input of the string names of the enumeration, so extract this.
	lookup, ok := enumVal.ΛMap()[e.Type().Name()]
	if !ok {
		return "", false, fmt.Errorf("cannot map enumerated value as type %s was unknown", field.Type().Name())
	}

	def, ok := lookup[e.Int()]
	if !ok {
		return "", false, fmt.Errorf("cannot map enumerated value as type %s has unknown value %d", field.Type().Name(), enumVal)
	}

	n := def.Name
	if appendModuleName && def.DefiningModule != "" {
		n = fmt.Sprintf("%s:%s", def.DefiningModule, def.Name)
	}
	return n, true, nil
}

// BuildEmptyTree initialises the YANG tree starting at the root GoStruct
// provided. This allows the YANG container hierarchy (i.e., any structs within
// the tree) to be pre-initialised rather than requiring the user to initialise
// each as it is required. Given that some trees may be large, then some
// caution should be exercised in initialising an entire tree.
func BuildEmptyTree(s GoStruct) {
	initialiseTree(reflect.ValueOf(s).Elem().Type(), reflect.ValueOf(s).Elem())
}

// initialiseTree takes an input data item's reflect.Value and reflect.Type for
// a particular GoStruct, and initialises the nested structs that are within it.
func initialiseTree(t reflect.Type, v reflect.Value) {
	for i := 0; i < v.NumField(); i++ {
		fVal := v.Field(i)
		fType := t.Field(i)

		if fType.Type.Kind() == reflect.Ptr {
			// Only initialise nested struct pointers, since all struct fields within
			// a GoStruct are expected to be pointers, and we do not want to initialise
			// non-struct values.
			if pVal := reflect.New(fType.Type.Elem()); pVal.Elem().Type().Kind() == reflect.Struct {
				initialiseTree(pVal.Elem().Type(), pVal.Elem())
				fVal.Set(pVal)
			}
		}
	}
}

// InitContainer initialises the container cname of the GoStruct s, it can be
// used to initialise an arbitrary named child container within a YANG
// structure in a generic manner. This allows the caller to generically
// initialise a sub-element of the YANG tree without needing to have specific
// handling code.
func InitContainer(s GoStruct, cname string) error {
	f := reflect.ValueOf(s).Elem().FieldByName(cname)
	if !f.IsValid() {
		return fmt.Errorf("invalid container %s as child of %v", cname, s)
	}
	t := f.Type()

	if n := reflect.New(t.Elem()); n.Elem().Type().Kind() == reflect.Struct {
		f.Set(n)
		return nil
	}

	return fmt.Errorf("field %s was not a struct to initialise", cname)
}

// binaryBase64 takes an input byte slice and returns it as a base64
// encoded string.
func binaryBase64(i []byte) string {
	var b bytes.Buffer
	encoder := base64.NewEncoder(base64.StdEncoding, &b)
	encoder.Write(i)
	encoder.Close()
	return b.String()
}

// JSONFormat is an enumerated integer value indicating the JSON format.
type JSONFormat int

const (
	// Internal is the custom JSON format that is output by the validation library, and
	// by pyangbind. It is loosely specified - but is the default used by generator developers.
	Internal JSONFormat = iota
	// RFC7951 is JSON that conforms to RFC7951.
	RFC7951
)

// EmitJSONConfig specifies the how JSON should be created by the EmitJSON function.
type EmitJSONConfig struct {
	// Format specifies the JSON format that should be output by the EmitJSON
	// function - using the enumerated JSONType function. By default, internal
	// format JSON will be produced.
	Format JSONFormat
	// RFC7951Config specifies the configuration options for RFC7951 JSON. Only
	// valid if Format is RFC7951.
	RFC7951Config *RFC7951JSONConfig
	// Indent is the string used for indentation within the JSON output. The
	// default value is three spaces.
	Indent string
}

// EmitJSON takes an input ValidatedGoStruct (produced by ygen with validation enabled)
// and serialises it to a JSON string. By default, produces the Internal format JSON.
func EmitJSON(s ValidatedGoStruct, opts *EmitJSONConfig) (string, error) {
	f := Internal
	if opts != nil {
		f = opts.Format
	}

	if err := s.Validate(); err != nil {
		return "", fmt.Errorf("validation err: %v", err)
	}

	var v map[string]interface{}
	var err error
	switch f {
	case Internal:
		if v, err = ConstructInternalJSON(s); err != nil {
			return "", fmt.Errorf("ConstructInternalJSON error: %v", err)
		}
	case RFC7951:
		var c *RFC7951JSONConfig
		if opts != nil {
			c = opts.RFC7951Config
		}
		if v, err = ConstructIETFJSON(s, c); err != nil {
			return "", fmt.Errorf("ConstructIETFJSON error: %v", err)
		}
	}

	indent := indentString
	if opts != nil && opts.Indent != "" {
		indent = opts.Indent
	}

	j, err := json.MarshalIndent(v, "", indent)
	if err != nil {
		return "", fmt.Errorf("JSON marshalling error: %v", err)
	}

	return string(j), nil
}
