// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package ygot contains helper methods for dealing with structs that represent
// a YANG schema. Particularly, it takes structs that represent a YANG schema -
// generated by ygen:
//	- Provides helper functions which simplify their usage such as functions
//	  to return pointers to a type.
//	- Renders structs to other output formats such as JSON, or gNMI
//	  notifications.
package ygot

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
)

const (
	// indentString represents the default indentation string used for
	// JSON. Three spaces are used based on the legacy use of EmitJSON.
	indentString string = "   "
)

// structTagsToLibPaths takes an input struct field as a reflect.Type, and determines
// the set of validation library paths that it maps to. Returns the paths as a slice of
// empty interface slices, or an error.
func structTagToLibPaths(f reflect.StructField, parentPath *gnmiPath) ([]*gnmiPath, error) {
	if !parentPath.isValid() {
		return nil, fmt.Errorf("invalid path format in parentPath (%v, %v)", parentPath.stringSlicePath == nil, parentPath.pathElemPath == nil)
	}

	pathAnnotation, ok := f.Tag.Lookup("path")
	if !ok {
		return nil, fmt.Errorf("field did not specify a path")
	}

	var mapPaths []*gnmiPath
	tagPaths := strings.Split(pathAnnotation, "|")
	for _, p := range tagPaths {
		// Make a copy of the existing parent path so we can append to it without
		// modifying it for future paths.
		ePath := parentPath.Copy()

		for _, pp := range strings.Split(p, "/") {
			// Handle empty path tags.
			if pp == "" {
				continue
			}
			ePath.AppendName(pp)
		}
		mapPaths = append(mapPaths, ePath)
	}
	return mapPaths, nil
}

// enumFieldToString takes an input reflect.Value, which is type asserted to
// be a GoEnum, and resolves the string name corresponding to the value within
// the YANG schema. Returns the string name of the enum, a bool indicating
// whether the value was set, or an error. The appendModuleName specifies whether
// the defining module name should be appended to the enumerated value's name in
// the form "module:name", as per the encoding rules in RFC7951.
func enumFieldToString(field reflect.Value, appendModuleName bool) (string, bool, error) {
	// Generated structs can only have fields that are not pointers when they are enumerated
	// values, since these values have an UNSET value that allows us to determine when they
	// are not explicitly set by the user.
	// We check whether this is an enum field by checking whether the type implements the
	// GoEnum interface.
	enumVal, isEnum := field.Interface().(GoEnum)
	if !isEnum {
		return "", false, fmt.Errorf("supplied value was not a valid GoEnum: %v", field.Type())
	}

	e := reflect.ValueOf(enumVal)

	if e.Int() == 0 {
		// Enumerations are always derived int64 types, which have a default of
		// 0. The generated enumeration's _UNSET value is always zero, so we can
		// use this to determine that the enumeration was not explicitly set by
		// the user and skip mapping this leaf into the schema.
		return "", false, nil
	}

	// ΛMap returns a map that is keyed based on the name of the enumeration's Go type,
	// which provides a map between the integer values of the enumeration and the strings.
	// The ygen library expects input of the string names of the enumeration, so extract this.
	lookup, ok := enumVal.ΛMap()[e.Type().Name()]
	if !ok {
		return "", false, fmt.Errorf("cannot map enumerated value as type %s was unknown", field.Type().Name())
	}

	def, ok := lookup[e.Int()]
	if !ok {
		return "", false, fmt.Errorf("cannot map enumerated value as type %s has unknown value %d", field.Type().Name(), enumVal)
	}

	n := def.Name
	if appendModuleName && def.DefiningModule != "" {
		n = fmt.Sprintf("%s:%s", def.DefiningModule, def.Name)
	}
	return n, true, nil
}

// BuildEmptyTree initialises the YANG tree starting at the root GoStruct
// provided. This allows the YANG container hierarchy (i.e., any structs within
// the tree) to be pre-initialised rather than requiring the user to initialise
// each as it is required. Given that some trees may be large, then some
// caution should be exercised in initialising an entire tree.
func BuildEmptyTree(s GoStruct) {
	initialiseTree(reflect.ValueOf(s).Elem().Type(), reflect.ValueOf(s).Elem())
}

// initialiseTree takes an input data item's reflect.Value and reflect.Type for
// a particular GoStruct, and initialises the nested structs that are within it.
func initialiseTree(t reflect.Type, v reflect.Value) {
	for i := 0; i < v.NumField(); i++ {
		fVal := v.Field(i)
		fType := t.Field(i)

		if fType.Type.Kind() == reflect.Ptr {
			// Only initialise nested struct pointers, since all struct fields within
			// a GoStruct are expected to be pointers, and we do not want to initialise
			// non-struct values.
			if pVal := reflect.New(fType.Type.Elem()); pVal.Elem().Type().Kind() == reflect.Struct {
				initialiseTree(pVal.Elem().Type(), pVal.Elem())
				fVal.Set(pVal)
			}
		}
	}
}

// InitContainer initialises the container cname of the GoStruct s, it can be
// used to initialise an arbitrary named child container within a YANG
// structure in a generic manner. This allows the caller to generically
// initialise a sub-element of the YANG tree without needing to have specific
// handling code.
func InitContainer(s GoStruct, cname string) error {
	f := reflect.ValueOf(s).Elem().FieldByName(cname)
	if !f.IsValid() {
		return fmt.Errorf("invalid container %s as child of %v", cname, s)
	}
	t := f.Type()

	if n := reflect.New(t.Elem()); n.Elem().Type().Kind() == reflect.Struct {
		f.Set(n)
		return nil
	}

	return fmt.Errorf("field %s was not a struct to initialise", cname)
}

// binaryBase64 takes an input byte slice and returns it as a base64
// encoded string.
func binaryBase64(i []byte) string {
	var b bytes.Buffer
	encoder := base64.NewEncoder(base64.StdEncoding, &b)
	encoder.Write(i)
	encoder.Close()
	return b.String()
}

// JSONFormat is an enumerated integer value indicating the JSON format.
type JSONFormat int

const (
	// Internal is the custom JSON format that is output by the validation library, and
	// by pyangbind. It is loosely specified - but is the default used by generator developers.
	Internal JSONFormat = iota
	// RFC7951 is JSON that conforms to RFC7951.
	RFC7951
)

// EmitJSONConfig specifies the how JSON should be created by the EmitJSON function.
type EmitJSONConfig struct {
	// Format specifies the JSON format that should be output by the EmitJSON
	// function - using the enumerated JSONType function. By default, internal
	// format JSON will be produced.
	Format JSONFormat
	// RFC7951Config specifies the configuration options for RFC7951 JSON. Only
	// valid if Format is RFC7951.
	RFC7951Config *RFC7951JSONConfig
	// Indent is the string used for indentation within the JSON output. The
	// default value is three spaces.
	Indent string
}

// EmitJSON takes an input ValidatedGoStruct (produced by ygen with validation enabled)
// and serialises it to a JSON string. By default, produces the Internal format JSON.
func EmitJSON(s ValidatedGoStruct, opts *EmitJSONConfig) (string, error) {
	if err := s.Validate(); err != nil {
		return "", fmt.Errorf("validation err: %v", err)
	}

	v, err := makeJSON(s, opts)
	if err != nil {
		return "", err
	}

	indent := indentString
	if opts != nil && opts.Indent != "" {
		indent = opts.Indent
	}

	j, err := json.MarshalIndent(v, "", indent)
	if err != nil {
		return "", fmt.Errorf("JSON marshalling error: %v", err)
	}

	return string(j), nil
}

// makeJSON renders the GoStruct s to map[string]interface{} according to the
// JSON format specified. By default makeJSON returns internal format JSON.
func makeJSON(s GoStruct, opts *EmitJSONConfig) (map[string]interface{}, error) {
	f := Internal
	if opts != nil {
		f = opts.Format
	}

	var v map[string]interface{}
	var err error
	switch f {
	case Internal:
		if v, err = ConstructInternalJSON(s); err != nil {
			return nil, fmt.Errorf("ConstructInternalJSON error: %v", err)
		}
	case RFC7951:
		var c *RFC7951JSONConfig
		if opts != nil {
			c = opts.RFC7951Config
		}
		if v, err = ConstructIETFJSON(s, c); err != nil {
			return nil, fmt.Errorf("ConstructIETFJSON error: %v", err)
		}
	}
	return v, nil
}

// MergeStructJSON marshals the GoStruct ns to JSON according to the configuration, and
// merges it with the existing JSON provided as a map[string]interface{}. The merged
// JSON output is returned.
//
// To create valid JSON-serialised YANG, it is expected that the existing JSON is in
// the same format as is specified in the options. Where there are overlapping tree
// elements in the serialised struct they are merged where possible.
func MergeStructJSON(ns GoStruct, ej map[string]interface{}, opts *EmitJSONConfig) (map[string]interface{}, error) {
	j, err := makeJSON(ns, opts)
	if err != nil {
		return nil, err
	}

	nj, err := MergeJSON(ej, j)
	if err != nil {
		return nil, err
	}
	return nj, nil
}

// MergeJSON takes two input maps, and merges them into a single map.
func MergeJSON(a, b map[string]interface{}) (map[string]interface{}, error) {
	o := map[string]interface{}{}

	// Copy map a into the output.
	for k, v := range a {
		o[k] = v
	}

	for k, v := range b {
		if _, ok := o[k]; !ok {
			// Simple case, where the branch in b does not exist in
			// a, so we can simply add the subtree.
			o[k] = v
			continue
		}

		src, sok := o[k].(map[string]interface{})
		dst, dok := v.(map[string]interface{})
		if sok && dok {
			// The key exists in both a and b, and is a map[string]interface{}
			// in both, such that it can be merged as the subtree.
			var err error
			o[k], err = MergeJSON(src, dst)
			if err != nil {
				return nil, err
			}
			continue
		}

		ssrc, sok := o[k].([]interface{})
		sdst, dok := v.([]interface{})
		if sok && dok {
			// The key exists in both a and b, and is a slice
			// such that we can concat the two slices.
			o[k] = append(ssrc, sdst...)
			continue
		}

		return nil, fmt.Errorf("%s is not a mergable JSON type in tree, a: %T, b: %T", k, o[k], v)
	}

	return o, nil
}
