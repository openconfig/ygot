/*
Package exampleoc is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

NOTE WELL: This is an example code file that is distributed with ygot.
It should not be used within your application, as it WILL change,
without warning. Rather, you should generate structs directly from
OpenConfig models using the ygot package.

This package was generated by github.com/openconfig/ygot
using the following YANG input files:
	- public/release/models/network-instance/openconfig-network-instance.yang
	- public/release/models/optical-transport/openconfig-optical-amplifier.yang
	- public/release/models/optical-transport/openconfig-terminal-device.yang
	- public/release/models/optical-transport/openconfig-transport-line-protection.yang
	- public/release/models/platform/openconfig-platform.yang
	- public/release/models/policy/openconfig-routing-policy.yang
	- public/release/models/lacp/openconfig-lacp.yang
	- public/release/models/system/openconfig-system.yang
	- public/release/models/lldp/openconfig-lldp.yang
	- public/release/models/stp/openconfig-spanning-tree.yang
	- public/release/models/interfaces/openconfig-interfaces.yang
	- public/release/models/interfaces/openconfig-if-ip.yang
	- public/release/models/interfaces/openconfig-if-aggregate.yang
	- public/release/models/interfaces/openconfig-if-ethernet.yang
	- public/release/models/interfaces/openconfig-if-ip-ext.yang
Imported modules were sourced from:
	- public/...
	- deps/...
*/
package exampleoc

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

var (
	SchemaTree map[string]*yang.Entry
)

func init() {
	var err error
	if SchemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled.
func Unmarshal(data []byte, destStruct ygot.GoStruct) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree)
}

// NewApsModule creates a new entry in the ApsModule list of the
// Aps struct. The keys of the list are populated from the input
// arguments.
func (t *Aps) NewApsModule(Name string) (*Aps_ApsModule, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ApsModule == nil {
		t.ApsModule = make(map[string]*Aps_ApsModule)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ApsModule[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ApsModule", key)
	}

	t.ApsModule[key] = &Aps_ApsModule{
		Name: &Name,
	}

	return t.ApsModule[key], nil
}

// RenameApsModule renames an entry in the list ApsModule within
// the Aps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Aps) RenameApsModule(oldK, newK string) error {
	if _, ok := t.ApsModule[newK]; ok {
		return fmt.Errorf("key %v already exists in ApsModule", newK)
	}

	e, ok := t.ApsModule[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ApsModule", oldK)
	}
	e.Name = &newK

	t.ApsModule[newK] = e
	delete(t.ApsModule, oldK)
	return nil
}

// GetOrCreateApsModule retrieves the value with the specified keys from
// the receiver Aps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Aps) GetOrCreateApsModule(Name string) *Aps_ApsModule {

	key := Name

	if v, ok := t.ApsModule[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewApsModule(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateApsModule got unexpected error: %v", err))
	}
	return v
}

// GetApsModule retrieves the value with the specified key from
// the ApsModule map field of Aps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Aps) GetApsModule(Name string) *Aps_ApsModule {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ApsModule[key]; ok {
		return lm
	}
	return nil
}

// AppendApsModule appends the supplied Aps_ApsModule struct to the
// list ApsModule of Aps. If the key value(s) specified in
// the supplied Aps_ApsModule already exist in the list, an error is
// returned.
func (t *Aps) AppendApsModule(v *Aps_ApsModule) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ApsModule == nil {
		t.ApsModule = make(map[string]*Aps_ApsModule)
	}

	if _, ok := t.ApsModule[key]; ok {
		return fmt.Errorf("duplicate key for list ApsModule %v", key)
	}

	t.ApsModule[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreatePorts retrieves the value of the Ports field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule) GetOrCreatePorts() *Aps_ApsModule_Ports {
	if s.Ports != nil {
		return s.Ports
	}
	s.Ports = &Aps_ApsModule_Ports{}
	return s.Ports
}

// GetPorts returns the value of the Ports struct pointer
// from Aps_ApsModule. If the receiver or the field Ports is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule) GetPorts() *Aps_ApsModule_Ports {
	if s != nil && s.Ports != nil {
		return s.Ports
	}
	return nil
}

// ΛListKeyMap returns the keys of the Aps_ApsModule struct, which is a YANG list entry.
func (t *Aps_ApsModule) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCommonIn retrieves the value of the CommonIn field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports) GetOrCreateCommonIn() *Aps_ApsModule_Ports_CommonIn {
	if s.CommonIn != nil {
		return s.CommonIn
	}
	s.CommonIn = &Aps_ApsModule_Ports_CommonIn{}
	return s.CommonIn
}

// GetOrCreateCommonOutput retrieves the value of the CommonOutput field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports) GetOrCreateCommonOutput() *Aps_ApsModule_Ports_CommonOutput {
	if s.CommonOutput != nil {
		return s.CommonOutput
	}
	s.CommonOutput = &Aps_ApsModule_Ports_CommonOutput{}
	return s.CommonOutput
}

// GetOrCreateLinePrimaryIn retrieves the value of the LinePrimaryIn field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports) GetOrCreateLinePrimaryIn() *Aps_ApsModule_Ports_LinePrimaryIn {
	if s.LinePrimaryIn != nil {
		return s.LinePrimaryIn
	}
	s.LinePrimaryIn = &Aps_ApsModule_Ports_LinePrimaryIn{}
	return s.LinePrimaryIn
}

// GetOrCreateLinePrimaryOut retrieves the value of the LinePrimaryOut field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports) GetOrCreateLinePrimaryOut() *Aps_ApsModule_Ports_LinePrimaryOut {
	if s.LinePrimaryOut != nil {
		return s.LinePrimaryOut
	}
	s.LinePrimaryOut = &Aps_ApsModule_Ports_LinePrimaryOut{}
	return s.LinePrimaryOut
}

// GetOrCreateLineSecondaryIn retrieves the value of the LineSecondaryIn field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports) GetOrCreateLineSecondaryIn() *Aps_ApsModule_Ports_LineSecondaryIn {
	if s.LineSecondaryIn != nil {
		return s.LineSecondaryIn
	}
	s.LineSecondaryIn = &Aps_ApsModule_Ports_LineSecondaryIn{}
	return s.LineSecondaryIn
}

// GetOrCreateLineSecondaryOut retrieves the value of the LineSecondaryOut field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports) GetOrCreateLineSecondaryOut() *Aps_ApsModule_Ports_LineSecondaryOut {
	if s.LineSecondaryOut != nil {
		return s.LineSecondaryOut
	}
	s.LineSecondaryOut = &Aps_ApsModule_Ports_LineSecondaryOut{}
	return s.LineSecondaryOut
}

// GetCommonIn returns the value of the CommonIn struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field CommonIn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports) GetCommonIn() *Aps_ApsModule_Ports_CommonIn {
	if s != nil && s.CommonIn != nil {
		return s.CommonIn
	}
	return nil
}

// GetCommonOutput returns the value of the CommonOutput struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field CommonOutput is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports) GetCommonOutput() *Aps_ApsModule_Ports_CommonOutput {
	if s != nil && s.CommonOutput != nil {
		return s.CommonOutput
	}
	return nil
}

// GetLinePrimaryIn returns the value of the LinePrimaryIn struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field LinePrimaryIn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports) GetLinePrimaryIn() *Aps_ApsModule_Ports_LinePrimaryIn {
	if s != nil && s.LinePrimaryIn != nil {
		return s.LinePrimaryIn
	}
	return nil
}

// GetLinePrimaryOut returns the value of the LinePrimaryOut struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field LinePrimaryOut is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports) GetLinePrimaryOut() *Aps_ApsModule_Ports_LinePrimaryOut {
	if s != nil && s.LinePrimaryOut != nil {
		return s.LinePrimaryOut
	}
	return nil
}

// GetLineSecondaryIn returns the value of the LineSecondaryIn struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field LineSecondaryIn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports) GetLineSecondaryIn() *Aps_ApsModule_Ports_LineSecondaryIn {
	if s != nil && s.LineSecondaryIn != nil {
		return s.LineSecondaryIn
	}
	return nil
}

// GetLineSecondaryOut returns the value of the LineSecondaryOut struct pointer
// from Aps_ApsModule_Ports. If the receiver or the field LineSecondaryOut is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports) GetLineSecondaryOut() *Aps_ApsModule_Ports_LineSecondaryOut {
	if s != nil && s.LineSecondaryOut != nil {
		return s.LineSecondaryOut
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports_CommonIn) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_CommonIn_OpticalPower {
	if s.OpticalPower != nil {
		return s.OpticalPower
	}
	s.OpticalPower = &Aps_ApsModule_Ports_CommonIn_OpticalPower{}
	return s.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_CommonIn. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports_CommonIn) GetOpticalPower() *Aps_ApsModule_Ports_CommonIn_OpticalPower {
	if s != nil && s.OpticalPower != nil {
		return s.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_CommonIn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_CommonIn"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_CommonIn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_CommonIn_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_CommonIn_OpticalPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_CommonIn_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports_CommonOutput) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_CommonOutput_OpticalPower {
	if s.OpticalPower != nil {
		return s.OpticalPower
	}
	s.OpticalPower = &Aps_ApsModule_Ports_CommonOutput_OpticalPower{}
	return s.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_CommonOutput. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports_CommonOutput) GetOpticalPower() *Aps_ApsModule_Ports_CommonOutput_OpticalPower {
	if s != nil && s.OpticalPower != nil {
		return s.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_CommonOutput) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_CommonOutput"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_CommonOutput) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_CommonOutput_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_CommonOutput_OpticalPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_CommonOutput_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports_LinePrimaryIn) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower {
	if s.OpticalPower != nil {
		return s.OpticalPower
	}
	s.OpticalPower = &Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower{}
	return s.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_LinePrimaryIn. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports_LinePrimaryIn) GetOpticalPower() *Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower {
	if s != nil && s.OpticalPower != nil {
		return s.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_LinePrimaryIn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LinePrimaryIn"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LinePrimaryIn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LinePrimaryIn_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports_LinePrimaryOut) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower {
	if s.OpticalPower != nil {
		return s.OpticalPower
	}
	s.OpticalPower = &Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower{}
	return s.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_LinePrimaryOut. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports_LinePrimaryOut) GetOpticalPower() *Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower {
	if s != nil && s.OpticalPower != nil {
		return s.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_LinePrimaryOut) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LinePrimaryOut"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LinePrimaryOut) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LinePrimaryOut_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports_LineSecondaryIn) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower {
	if s.OpticalPower != nil {
		return s.OpticalPower
	}
	s.OpticalPower = &Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower{}
	return s.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_LineSecondaryIn. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports_LineSecondaryIn) GetOpticalPower() *Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower {
	if s != nil && s.OpticalPower != nil {
		return s.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_LineSecondaryIn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LineSecondaryIn"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LineSecondaryIn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LineSecondaryIn_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOpticalPower retrieves the value of the OpticalPower field
// or returns the existing field if it already exists.
func (s *Aps_ApsModule_Ports_LineSecondaryOut) GetOrCreateOpticalPower() *Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower {
	if s.OpticalPower != nil {
		return s.OpticalPower
	}
	s.OpticalPower = &Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower{}
	return s.OpticalPower
}

// GetOpticalPower returns the value of the OpticalPower struct pointer
// from Aps_ApsModule_Ports_LineSecondaryOut. If the receiver or the field OpticalPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Aps_ApsModule_Ports_LineSecondaryOut) GetOpticalPower() *Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower {
	if s != nil && s.OpticalPower != nil {
		return s.OpticalPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_LineSecondaryOut) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LineSecondaryOut"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LineSecondaryOut) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Aps_ApsModule_Ports_LineSecondaryOut_OpticalPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp) NewNeighbor(NeighborAddress string) (*Bgp_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Bgp_Neighbor)
	}

	key := NeighborAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Bgp_Neighbor{
		NeighborAddress: &NeighborAddress,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.NeighborAddress = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp) GetOrCreateNeighbor(NeighborAddress string) *Bgp_Neighbor {

	key := NeighborAddress

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(NeighborAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp) GetNeighbor(NeighborAddress string) *Bgp_Neighbor {

	if t == nil {
		return nil
	}

	key := NeighborAddress

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied Bgp_Neighbor struct to the
// list Neighbor of Bgp. If the key value(s) specified in
// the supplied Bgp_Neighbor already exist in the list, an error is
// returned.
func (t *Bgp) AppendNeighbor(v *Bgp_Neighbor) error {
	key := *v.NeighborAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Bgp_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// NewPeerGroup creates a new entry in the PeerGroup list of the
// Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp) NewPeerGroup(PeerGroupName string) (*Bgp_PeerGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PeerGroup == nil {
		t.PeerGroup = make(map[string]*Bgp_PeerGroup)
	}

	key := PeerGroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PeerGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PeerGroup", key)
	}

	t.PeerGroup[key] = &Bgp_PeerGroup{
		PeerGroupName: &PeerGroupName,
	}

	return t.PeerGroup[key], nil
}

// RenamePeerGroup renames an entry in the list PeerGroup within
// the Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp) RenamePeerGroup(oldK, newK string) error {
	if _, ok := t.PeerGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in PeerGroup", newK)
	}

	e, ok := t.PeerGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PeerGroup", oldK)
	}
	e.PeerGroupName = &newK

	t.PeerGroup[newK] = e
	delete(t.PeerGroup, oldK)
	return nil
}

// GetOrCreatePeerGroup retrieves the value with the specified keys from
// the receiver Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp) GetOrCreatePeerGroup(PeerGroupName string) *Bgp_PeerGroup {

	key := PeerGroupName

	if v, ok := t.PeerGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPeerGroup(PeerGroupName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePeerGroup got unexpected error: %v", err))
	}
	return v
}

// GetPeerGroup retrieves the value with the specified key from
// the PeerGroup map field of Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp) GetPeerGroup(PeerGroupName string) *Bgp_PeerGroup {

	if t == nil {
		return nil
	}

	key := PeerGroupName

	if lm, ok := t.PeerGroup[key]; ok {
		return lm
	}
	return nil
}

// AppendPeerGroup appends the supplied Bgp_PeerGroup struct to the
// list PeerGroup of Bgp. If the key value(s) specified in
// the supplied Bgp_PeerGroup already exist in the list, an error is
// returned.
func (t *Bgp) AppendPeerGroup(v *Bgp_PeerGroup) error {
	key := *v.PeerGroupName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PeerGroup == nil {
		t.PeerGroup = make(map[string]*Bgp_PeerGroup)
	}

	if _, ok := t.PeerGroup[key]; ok {
		return fmt.Errorf("duplicate key for list PeerGroup %v", key)
	}

	t.PeerGroup[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (s *Bgp) GetOrCreateGlobal() *Bgp_Global {
	if s.Global != nil {
		return s.Global
	}
	s.Global = &Bgp_Global{}
	return s.Global
}

// GetGlobal returns the value of the Global struct pointer
// from Bgp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp) GetGlobal() *Bgp_Global {
	if s != nil && s.Global != nil {
		return s.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAfiSafi creates a new entry in the AfiSafi list of the
// Bgp_Global struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp_Global) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*Bgp_Global_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_Global_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &Bgp_Global_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the Bgp_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp_Global) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver Bgp_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp_Global) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_Global_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of Bgp_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp_Global) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_Global_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// AppendAfiSafi appends the supplied Bgp_Global_AfiSafi struct to the
// list AfiSafi of Bgp_Global. If the key value(s) specified in
// the supplied Bgp_Global_AfiSafi already exist in the list, an error is
// returned.
func (t *Bgp_Global) AppendAfiSafi(v *Bgp_Global_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_Global_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// NewDynamicNeighborPrefix creates a new entry in the DynamicNeighborPrefix list of the
// Bgp_Global struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp_Global) NewDynamicNeighborPrefix(Prefix string) (*Bgp_Global_DynamicNeighborPrefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DynamicNeighborPrefix == nil {
		t.DynamicNeighborPrefix = make(map[string]*Bgp_Global_DynamicNeighborPrefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DynamicNeighborPrefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DynamicNeighborPrefix", key)
	}

	t.DynamicNeighborPrefix[key] = &Bgp_Global_DynamicNeighborPrefix{
		Prefix: &Prefix,
	}

	return t.DynamicNeighborPrefix[key], nil
}

// RenameDynamicNeighborPrefix renames an entry in the list DynamicNeighborPrefix within
// the Bgp_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp_Global) RenameDynamicNeighborPrefix(oldK, newK string) error {
	if _, ok := t.DynamicNeighborPrefix[newK]; ok {
		return fmt.Errorf("key %v already exists in DynamicNeighborPrefix", newK)
	}

	e, ok := t.DynamicNeighborPrefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DynamicNeighborPrefix", oldK)
	}
	e.Prefix = &newK

	t.DynamicNeighborPrefix[newK] = e
	delete(t.DynamicNeighborPrefix, oldK)
	return nil
}

// GetOrCreateDynamicNeighborPrefix retrieves the value with the specified keys from
// the receiver Bgp_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp_Global) GetOrCreateDynamicNeighborPrefix(Prefix string) *Bgp_Global_DynamicNeighborPrefix {

	key := Prefix

	if v, ok := t.DynamicNeighborPrefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDynamicNeighborPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDynamicNeighborPrefix got unexpected error: %v", err))
	}
	return v
}

// GetDynamicNeighborPrefix retrieves the value with the specified key from
// the DynamicNeighborPrefix map field of Bgp_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp_Global) GetDynamicNeighborPrefix(Prefix string) *Bgp_Global_DynamicNeighborPrefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.DynamicNeighborPrefix[key]; ok {
		return lm
	}
	return nil
}

// AppendDynamicNeighborPrefix appends the supplied Bgp_Global_DynamicNeighborPrefix struct to the
// list DynamicNeighborPrefix of Bgp_Global. If the key value(s) specified in
// the supplied Bgp_Global_DynamicNeighborPrefix already exist in the list, an error is
// returned.
func (t *Bgp_Global) AppendDynamicNeighborPrefix(v *Bgp_Global_DynamicNeighborPrefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DynamicNeighborPrefix == nil {
		t.DynamicNeighborPrefix = make(map[string]*Bgp_Global_DynamicNeighborPrefix)
	}

	if _, ok := t.DynamicNeighborPrefix[key]; ok {
		return fmt.Errorf("duplicate key for list DynamicNeighborPrefix %v", key)
	}

	t.DynamicNeighborPrefix[key] = v
	return nil
}

// GetOrCreateConfederation retrieves the value of the Confederation field
// or returns the existing field if it already exists.
func (s *Bgp_Global) GetOrCreateConfederation() *Bgp_Global_Confederation {
	if s.Confederation != nil {
		return s.Confederation
	}
	s.Confederation = &Bgp_Global_Confederation{}
	return s.Confederation
}

// GetOrCreateDefaultRouteDistance retrieves the value of the DefaultRouteDistance field
// or returns the existing field if it already exists.
func (s *Bgp_Global) GetOrCreateDefaultRouteDistance() *Bgp_Global_DefaultRouteDistance {
	if s.DefaultRouteDistance != nil {
		return s.DefaultRouteDistance
	}
	s.DefaultRouteDistance = &Bgp_Global_DefaultRouteDistance{}
	return s.DefaultRouteDistance
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *Bgp_Global) GetOrCreateGracefulRestart() *Bgp_Global_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &Bgp_Global_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateRouteSelectionOptions retrieves the value of the RouteSelectionOptions field
// or returns the existing field if it already exists.
func (s *Bgp_Global) GetOrCreateRouteSelectionOptions() *Bgp_Global_RouteSelectionOptions {
	if s.RouteSelectionOptions != nil {
		return s.RouteSelectionOptions
	}
	s.RouteSelectionOptions = &Bgp_Global_RouteSelectionOptions{}
	return s.RouteSelectionOptions
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *Bgp_Global) GetOrCreateUseMultiplePaths() *Bgp_Global_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &Bgp_Global_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetConfederation returns the value of the Confederation struct pointer
// from Bgp_Global. If the receiver or the field Confederation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global) GetConfederation() *Bgp_Global_Confederation {
	if s != nil && s.Confederation != nil {
		return s.Confederation
	}
	return nil
}

// GetDefaultRouteDistance returns the value of the DefaultRouteDistance struct pointer
// from Bgp_Global. If the receiver or the field DefaultRouteDistance is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global) GetDefaultRouteDistance() *Bgp_Global_DefaultRouteDistance {
	if s != nil && s.DefaultRouteDistance != nil {
		return s.DefaultRouteDistance
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global) GetGracefulRestart() *Bgp_Global_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetRouteSelectionOptions returns the value of the RouteSelectionOptions struct pointer
// from Bgp_Global. If the receiver or the field RouteSelectionOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global) GetRouteSelectionOptions() *Bgp_Global_RouteSelectionOptions {
	if s != nil && s.RouteSelectionOptions != nil {
		return s.RouteSelectionOptions
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_Global. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global) GetUseMultiplePaths() *Bgp_Global_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateAddPaths() *Bgp_Global_AfiSafi_AddPaths {
	if s.AddPaths != nil {
		return s.AddPaths
	}
	s.AddPaths = &Bgp_Global_AfiSafi_AddPaths{}
	return s.AddPaths
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateGracefulRestart() *Bgp_Global_AfiSafi_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &Bgp_Global_AfiSafi_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateIpv4LabeledUnicast() *Bgp_Global_AfiSafi_Ipv4LabeledUnicast {
	if s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	s.Ipv4LabeledUnicast = &Bgp_Global_AfiSafi_Ipv4LabeledUnicast{}
	return s.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateIpv4Unicast() *Bgp_Global_AfiSafi_Ipv4Unicast {
	if s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	s.Ipv4Unicast = &Bgp_Global_AfiSafi_Ipv4Unicast{}
	return s.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateIpv6LabeledUnicast() *Bgp_Global_AfiSafi_Ipv6LabeledUnicast {
	if s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	s.Ipv6LabeledUnicast = &Bgp_Global_AfiSafi_Ipv6LabeledUnicast{}
	return s.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateIpv6Unicast() *Bgp_Global_AfiSafi_Ipv6Unicast {
	if s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	s.Ipv6Unicast = &Bgp_Global_AfiSafi_Ipv6Unicast{}
	return s.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateL2VpnEvpn() *Bgp_Global_AfiSafi_L2VpnEvpn {
	if s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	s.L2VpnEvpn = &Bgp_Global_AfiSafi_L2VpnEvpn{}
	return s.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateL2VpnVpls() *Bgp_Global_AfiSafi_L2VpnVpls {
	if s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	s.L2VpnVpls = &Bgp_Global_AfiSafi_L2VpnVpls{}
	return s.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *Bgp_Global_AfiSafi_L3VpnIpv4Multicast {
	if s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	s.L3VpnIpv4Multicast = &Bgp_Global_AfiSafi_L3VpnIpv4Multicast{}
	return s.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *Bgp_Global_AfiSafi_L3VpnIpv4Unicast {
	if s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	s.L3VpnIpv4Unicast = &Bgp_Global_AfiSafi_L3VpnIpv4Unicast{}
	return s.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *Bgp_Global_AfiSafi_L3VpnIpv6Multicast {
	if s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	s.L3VpnIpv6Multicast = &Bgp_Global_AfiSafi_L3VpnIpv6Multicast{}
	return s.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *Bgp_Global_AfiSafi_L3VpnIpv6Unicast {
	if s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	s.L3VpnIpv6Unicast = &Bgp_Global_AfiSafi_L3VpnIpv6Unicast{}
	return s.L3VpnIpv6Unicast
}

// GetOrCreateRouteSelectionOptions retrieves the value of the RouteSelectionOptions field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateRouteSelectionOptions() *Bgp_Global_AfiSafi_RouteSelectionOptions {
	if s.RouteSelectionOptions != nil {
		return s.RouteSelectionOptions
	}
	s.RouteSelectionOptions = &Bgp_Global_AfiSafi_RouteSelectionOptions{}
	return s.RouteSelectionOptions
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateSrtePolicyIpv4() *Bgp_Global_AfiSafi_SrtePolicyIpv4 {
	if s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	s.SrtePolicyIpv4 = &Bgp_Global_AfiSafi_SrtePolicyIpv4{}
	return s.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateSrtePolicyIpv6() *Bgp_Global_AfiSafi_SrtePolicyIpv6 {
	if s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	s.SrtePolicyIpv6 = &Bgp_Global_AfiSafi_SrtePolicyIpv6{}
	return s.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi) GetOrCreateUseMultiplePaths() *Bgp_Global_AfiSafi_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &Bgp_Global_AfiSafi_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetAddPaths() *Bgp_Global_AfiSafi_AddPaths {
	if s != nil && s.AddPaths != nil {
		return s.AddPaths
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetGracefulRestart() *Bgp_Global_AfiSafi_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetIpv4LabeledUnicast() *Bgp_Global_AfiSafi_Ipv4LabeledUnicast {
	if s != nil && s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetIpv4Unicast() *Bgp_Global_AfiSafi_Ipv4Unicast {
	if s != nil && s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetIpv6LabeledUnicast() *Bgp_Global_AfiSafi_Ipv6LabeledUnicast {
	if s != nil && s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetIpv6Unicast() *Bgp_Global_AfiSafi_Ipv6Unicast {
	if s != nil && s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetL2VpnEvpn() *Bgp_Global_AfiSafi_L2VpnEvpn {
	if s != nil && s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetL2VpnVpls() *Bgp_Global_AfiSafi_L2VpnVpls {
	if s != nil && s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetL3VpnIpv4Multicast() *Bgp_Global_AfiSafi_L3VpnIpv4Multicast {
	if s != nil && s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetL3VpnIpv4Unicast() *Bgp_Global_AfiSafi_L3VpnIpv4Unicast {
	if s != nil && s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetL3VpnIpv6Multicast() *Bgp_Global_AfiSafi_L3VpnIpv6Multicast {
	if s != nil && s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetL3VpnIpv6Unicast() *Bgp_Global_AfiSafi_L3VpnIpv6Unicast {
	if s != nil && s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	return nil
}

// GetRouteSelectionOptions returns the value of the RouteSelectionOptions struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field RouteSelectionOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetRouteSelectionOptions() *Bgp_Global_AfiSafi_RouteSelectionOptions {
	if s != nil && s.RouteSelectionOptions != nil {
		return s.RouteSelectionOptions
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetSrtePolicyIpv4() *Bgp_Global_AfiSafi_SrtePolicyIpv4 {
	if s != nil && s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetSrtePolicyIpv6() *Bgp_Global_AfiSafi_SrtePolicyIpv6 {
	if s != nil && s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_Global_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi) GetUseMultiplePaths() *Bgp_Global_AfiSafi_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the Bgp_Global_AfiSafi struct, which is a YANG list entry.
func (t *Bgp_Global_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_AddPaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv4LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_Ipv4Unicast) GetPrefixLimit() *Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv6LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_Ipv6Unicast) GetPrefixLimit() *Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_L2VpnEvpn) GetPrefixLimit() *Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L2VpnEvpn"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_L2VpnVpls) GetPrefixLimit() *Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L2VpnVpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv4Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv6Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_RouteSelectionOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_RouteSelectionOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_RouteSelectionOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_SrtePolicyIpv4"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Global_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_SrtePolicyIpv6"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (s *Bgp_Global_AfiSafi_UseMultiplePaths) GetOrCreateIbgp() *Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp {
	if s.Ibgp != nil {
		return s.Ibgp
	}
	s.Ibgp = &Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp{}
	return s.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_Global_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_UseMultiplePaths) GetEbgp() *Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from Bgp_Global_AfiSafi_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_AfiSafi_UseMultiplePaths) GetIbgp() *Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp {
	if s != nil && s.Ibgp != nil {
		return s.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_Confederation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_Confederation"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_Confederation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_DefaultRouteDistance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_DefaultRouteDistance"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_DefaultRouteDistance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Bgp_Global_DynamicNeighborPrefix struct, which is a YANG list entry.
func (t *Bgp_Global_DynamicNeighborPrefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_DynamicNeighborPrefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_DynamicNeighborPrefix"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_DynamicNeighborPrefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_RouteSelectionOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_RouteSelectionOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_RouteSelectionOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *Bgp_Global_UseMultiplePaths) GetOrCreateEbgp() *Bgp_Global_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &Bgp_Global_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (s *Bgp_Global_UseMultiplePaths) GetOrCreateIbgp() *Bgp_Global_UseMultiplePaths_Ibgp {
	if s.Ibgp != nil {
		return s.Ibgp
	}
	s.Ibgp = &Bgp_Global_UseMultiplePaths_Ibgp{}
	return s.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_Global_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_UseMultiplePaths) GetEbgp() *Bgp_Global_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from Bgp_Global_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Global_UseMultiplePaths) GetIbgp() *Bgp_Global_UseMultiplePaths_Ibgp {
	if s != nil && s.Ibgp != nil {
		return s.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Global_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Global_UseMultiplePaths_Ibgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Global_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAfiSafi creates a new entry in the AfiSafi list of the
// Bgp_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp_Neighbor) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*Bgp_Neighbor_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_Neighbor_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &Bgp_Neighbor_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the Bgp_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp_Neighbor) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver Bgp_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp_Neighbor) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_Neighbor_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of Bgp_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp_Neighbor) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_Neighbor_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// AppendAfiSafi appends the supplied Bgp_Neighbor_AfiSafi struct to the
// list AfiSafi of Bgp_Neighbor. If the key value(s) specified in
// the supplied Bgp_Neighbor_AfiSafi already exist in the list, an error is
// returned.
func (t *Bgp_Neighbor) AppendAfiSafi(v *Bgp_Neighbor_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_Neighbor_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateApplyPolicy() *Bgp_Neighbor_ApplyPolicy {
	if s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	s.ApplyPolicy = &Bgp_Neighbor_ApplyPolicy{}
	return s.ApplyPolicy
}

// GetOrCreateAsPathOptions retrieves the value of the AsPathOptions field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateAsPathOptions() *Bgp_Neighbor_AsPathOptions {
	if s.AsPathOptions != nil {
		return s.AsPathOptions
	}
	s.AsPathOptions = &Bgp_Neighbor_AsPathOptions{}
	return s.AsPathOptions
}

// GetOrCreateEbgpMultihop retrieves the value of the EbgpMultihop field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateEbgpMultihop() *Bgp_Neighbor_EbgpMultihop {
	if s.EbgpMultihop != nil {
		return s.EbgpMultihop
	}
	s.EbgpMultihop = &Bgp_Neighbor_EbgpMultihop{}
	return s.EbgpMultihop
}

// GetOrCreateErrorHandling retrieves the value of the ErrorHandling field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateErrorHandling() *Bgp_Neighbor_ErrorHandling {
	if s.ErrorHandling != nil {
		return s.ErrorHandling
	}
	s.ErrorHandling = &Bgp_Neighbor_ErrorHandling{}
	return s.ErrorHandling
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateGracefulRestart() *Bgp_Neighbor_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &Bgp_Neighbor_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateLoggingOptions retrieves the value of the LoggingOptions field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateLoggingOptions() *Bgp_Neighbor_LoggingOptions {
	if s.LoggingOptions != nil {
		return s.LoggingOptions
	}
	s.LoggingOptions = &Bgp_Neighbor_LoggingOptions{}
	return s.LoggingOptions
}

// GetOrCreateMessages retrieves the value of the Messages field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateMessages() *Bgp_Neighbor_Messages {
	if s.Messages != nil {
		return s.Messages
	}
	s.Messages = &Bgp_Neighbor_Messages{}
	return s.Messages
}

// GetOrCreateQueues retrieves the value of the Queues field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateQueues() *Bgp_Neighbor_Queues {
	if s.Queues != nil {
		return s.Queues
	}
	s.Queues = &Bgp_Neighbor_Queues{}
	return s.Queues
}

// GetOrCreateRouteReflector retrieves the value of the RouteReflector field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateRouteReflector() *Bgp_Neighbor_RouteReflector {
	if s.RouteReflector != nil {
		return s.RouteReflector
	}
	s.RouteReflector = &Bgp_Neighbor_RouteReflector{}
	return s.RouteReflector
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateTimers() *Bgp_Neighbor_Timers {
	if s.Timers != nil {
		return s.Timers
	}
	s.Timers = &Bgp_Neighbor_Timers{}
	return s.Timers
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateTransport() *Bgp_Neighbor_Transport {
	if s.Transport != nil {
		return s.Transport
	}
	s.Transport = &Bgp_Neighbor_Transport{}
	return s.Transport
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor) GetOrCreateUseMultiplePaths() *Bgp_Neighbor_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &Bgp_Neighbor_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from Bgp_Neighbor. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetApplyPolicy() *Bgp_Neighbor_ApplyPolicy {
	if s != nil && s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	return nil
}

// GetAsPathOptions returns the value of the AsPathOptions struct pointer
// from Bgp_Neighbor. If the receiver or the field AsPathOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetAsPathOptions() *Bgp_Neighbor_AsPathOptions {
	if s != nil && s.AsPathOptions != nil {
		return s.AsPathOptions
	}
	return nil
}

// GetEbgpMultihop returns the value of the EbgpMultihop struct pointer
// from Bgp_Neighbor. If the receiver or the field EbgpMultihop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetEbgpMultihop() *Bgp_Neighbor_EbgpMultihop {
	if s != nil && s.EbgpMultihop != nil {
		return s.EbgpMultihop
	}
	return nil
}

// GetErrorHandling returns the value of the ErrorHandling struct pointer
// from Bgp_Neighbor. If the receiver or the field ErrorHandling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetErrorHandling() *Bgp_Neighbor_ErrorHandling {
	if s != nil && s.ErrorHandling != nil {
		return s.ErrorHandling
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_Neighbor. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetGracefulRestart() *Bgp_Neighbor_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetLoggingOptions returns the value of the LoggingOptions struct pointer
// from Bgp_Neighbor. If the receiver or the field LoggingOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetLoggingOptions() *Bgp_Neighbor_LoggingOptions {
	if s != nil && s.LoggingOptions != nil {
		return s.LoggingOptions
	}
	return nil
}

// GetMessages returns the value of the Messages struct pointer
// from Bgp_Neighbor. If the receiver or the field Messages is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetMessages() *Bgp_Neighbor_Messages {
	if s != nil && s.Messages != nil {
		return s.Messages
	}
	return nil
}

// GetQueues returns the value of the Queues struct pointer
// from Bgp_Neighbor. If the receiver or the field Queues is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetQueues() *Bgp_Neighbor_Queues {
	if s != nil && s.Queues != nil {
		return s.Queues
	}
	return nil
}

// GetRouteReflector returns the value of the RouteReflector struct pointer
// from Bgp_Neighbor. If the receiver or the field RouteReflector is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetRouteReflector() *Bgp_Neighbor_RouteReflector {
	if s != nil && s.RouteReflector != nil {
		return s.RouteReflector
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from Bgp_Neighbor. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetTimers() *Bgp_Neighbor_Timers {
	if s != nil && s.Timers != nil {
		return s.Timers
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from Bgp_Neighbor. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetTransport() *Bgp_Neighbor_Transport {
	if s != nil && s.Transport != nil {
		return s.Transport
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_Neighbor. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor) GetUseMultiplePaths() *Bgp_Neighbor_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the Bgp_Neighbor struct, which is a YANG list entry.
func (t *Bgp_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NeighborAddress == nil {
		return nil, fmt.Errorf("nil value for key NeighborAddress")
	}

	return map[string]interface{}{
		"neighbor-address": *t.NeighborAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateAddPaths() *Bgp_Neighbor_AfiSafi_AddPaths {
	if s.AddPaths != nil {
		return s.AddPaths
	}
	s.AddPaths = &Bgp_Neighbor_AfiSafi_AddPaths{}
	return s.AddPaths
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateApplyPolicy() *Bgp_Neighbor_AfiSafi_ApplyPolicy {
	if s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	s.ApplyPolicy = &Bgp_Neighbor_AfiSafi_ApplyPolicy{}
	return s.ApplyPolicy
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateGracefulRestart() *Bgp_Neighbor_AfiSafi_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &Bgp_Neighbor_AfiSafi_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateIpv4LabeledUnicast() *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast {
	if s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	s.Ipv4LabeledUnicast = &Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast{}
	return s.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateIpv4Unicast() *Bgp_Neighbor_AfiSafi_Ipv4Unicast {
	if s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	s.Ipv4Unicast = &Bgp_Neighbor_AfiSafi_Ipv4Unicast{}
	return s.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateIpv6LabeledUnicast() *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast {
	if s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	s.Ipv6LabeledUnicast = &Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast{}
	return s.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateIpv6Unicast() *Bgp_Neighbor_AfiSafi_Ipv6Unicast {
	if s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	s.Ipv6Unicast = &Bgp_Neighbor_AfiSafi_Ipv6Unicast{}
	return s.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateL2VpnEvpn() *Bgp_Neighbor_AfiSafi_L2VpnEvpn {
	if s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	s.L2VpnEvpn = &Bgp_Neighbor_AfiSafi_L2VpnEvpn{}
	return s.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateL2VpnVpls() *Bgp_Neighbor_AfiSafi_L2VpnVpls {
	if s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	s.L2VpnVpls = &Bgp_Neighbor_AfiSafi_L2VpnVpls{}
	return s.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast {
	if s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	s.L3VpnIpv4Multicast = &Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast{}
	return s.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast {
	if s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	s.L3VpnIpv4Unicast = &Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast{}
	return s.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast {
	if s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	s.L3VpnIpv6Multicast = &Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast{}
	return s.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast {
	if s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	s.L3VpnIpv6Unicast = &Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast{}
	return s.L3VpnIpv6Unicast
}

// GetOrCreatePrefixes retrieves the value of the Prefixes field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreatePrefixes() *Bgp_Neighbor_AfiSafi_Prefixes {
	if s.Prefixes != nil {
		return s.Prefixes
	}
	s.Prefixes = &Bgp_Neighbor_AfiSafi_Prefixes{}
	return s.Prefixes
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateSrtePolicyIpv4() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4 {
	if s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	s.SrtePolicyIpv4 = &Bgp_Neighbor_AfiSafi_SrtePolicyIpv4{}
	return s.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateSrtePolicyIpv6() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6 {
	if s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	s.SrtePolicyIpv6 = &Bgp_Neighbor_AfiSafi_SrtePolicyIpv6{}
	return s.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi) GetOrCreateUseMultiplePaths() *Bgp_Neighbor_AfiSafi_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &Bgp_Neighbor_AfiSafi_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetAddPaths() *Bgp_Neighbor_AfiSafi_AddPaths {
	if s != nil && s.AddPaths != nil {
		return s.AddPaths
	}
	return nil
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetApplyPolicy() *Bgp_Neighbor_AfiSafi_ApplyPolicy {
	if s != nil && s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetGracefulRestart() *Bgp_Neighbor_AfiSafi_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetIpv4LabeledUnicast() *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast {
	if s != nil && s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetIpv4Unicast() *Bgp_Neighbor_AfiSafi_Ipv4Unicast {
	if s != nil && s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetIpv6LabeledUnicast() *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast {
	if s != nil && s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetIpv6Unicast() *Bgp_Neighbor_AfiSafi_Ipv6Unicast {
	if s != nil && s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetL2VpnEvpn() *Bgp_Neighbor_AfiSafi_L2VpnEvpn {
	if s != nil && s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetL2VpnVpls() *Bgp_Neighbor_AfiSafi_L2VpnVpls {
	if s != nil && s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetL3VpnIpv4Multicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast {
	if s != nil && s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetL3VpnIpv4Unicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast {
	if s != nil && s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetL3VpnIpv6Multicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast {
	if s != nil && s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetL3VpnIpv6Unicast() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast {
	if s != nil && s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	return nil
}

// GetPrefixes returns the value of the Prefixes struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field Prefixes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetPrefixes() *Bgp_Neighbor_AfiSafi_Prefixes {
	if s != nil && s.Prefixes != nil {
		return s.Prefixes
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetSrtePolicyIpv4() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4 {
	if s != nil && s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetSrtePolicyIpv6() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6 {
	if s != nil && s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_Neighbor_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi) GetUseMultiplePaths() *Bgp_Neighbor_AfiSafi_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the Bgp_Neighbor_AfiSafi struct, which is a YANG list entry.
func (t *Bgp_Neighbor_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_AddPaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_ApplyPolicy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_Ipv4Unicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_Ipv6Unicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_L2VpnEvpn) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L2VpnEvpn"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_L2VpnVpls) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L2VpnVpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_Prefixes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_Prefixes"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_Prefixes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_SrtePolicyIpv4"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_Neighbor_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_SrtePolicyIpv6"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_Neighbor_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_AfiSafi_UseMultiplePaths) GetEbgp() *Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_ApplyPolicy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_AsPathOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_AsPathOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_AsPathOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_EbgpMultihop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_EbgpMultihop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_EbgpMultihop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_ErrorHandling) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_ErrorHandling"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_ErrorHandling) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_LoggingOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_LoggingOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_LoggingOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateReceived retrieves the value of the Received field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_Messages) GetOrCreateReceived() *Bgp_Neighbor_Messages_Received {
	if s.Received != nil {
		return s.Received
	}
	s.Received = &Bgp_Neighbor_Messages_Received{}
	return s.Received
}

// GetOrCreateSent retrieves the value of the Sent field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_Messages) GetOrCreateSent() *Bgp_Neighbor_Messages_Sent {
	if s.Sent != nil {
		return s.Sent
	}
	s.Sent = &Bgp_Neighbor_Messages_Sent{}
	return s.Sent
}

// GetReceived returns the value of the Received struct pointer
// from Bgp_Neighbor_Messages. If the receiver or the field Received is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_Messages) GetReceived() *Bgp_Neighbor_Messages_Received {
	if s != nil && s.Received != nil {
		return s.Received
	}
	return nil
}

// GetSent returns the value of the Sent struct pointer
// from Bgp_Neighbor_Messages. If the receiver or the field Sent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_Messages) GetSent() *Bgp_Neighbor_Messages_Sent {
	if s != nil && s.Sent != nil {
		return s.Sent
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_Messages) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Messages"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Messages) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_Messages_Received) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Messages_Received"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Messages_Received) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_Messages_Sent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Messages_Sent"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Messages_Sent) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_Queues) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Queues"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Queues) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_RouteReflector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_RouteReflector"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_RouteReflector) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Timers"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Timers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_Transport"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_Transport) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *Bgp_Neighbor_UseMultiplePaths) GetOrCreateEbgp() *Bgp_Neighbor_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &Bgp_Neighbor_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_Neighbor_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_Neighbor_UseMultiplePaths) GetEbgp() *Bgp_Neighbor_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_Neighbor_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_Neighbor_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_Neighbor_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAfiSafi creates a new entry in the AfiSafi list of the
// Bgp_PeerGroup struct. The keys of the list are populated from the input
// arguments.
func (t *Bgp_PeerGroup) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*Bgp_PeerGroup_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_PeerGroup_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &Bgp_PeerGroup_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the Bgp_PeerGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Bgp_PeerGroup) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver Bgp_PeerGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Bgp_PeerGroup) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_PeerGroup_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of Bgp_PeerGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Bgp_PeerGroup) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *Bgp_PeerGroup_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// AppendAfiSafi appends the supplied Bgp_PeerGroup_AfiSafi struct to the
// list AfiSafi of Bgp_PeerGroup. If the key value(s) specified in
// the supplied Bgp_PeerGroup_AfiSafi already exist in the list, an error is
// returned.
func (t *Bgp_PeerGroup) AppendAfiSafi(v *Bgp_PeerGroup_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*Bgp_PeerGroup_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup) GetOrCreateApplyPolicy() *Bgp_PeerGroup_ApplyPolicy {
	if s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	s.ApplyPolicy = &Bgp_PeerGroup_ApplyPolicy{}
	return s.ApplyPolicy
}

// GetOrCreateAsPathOptions retrieves the value of the AsPathOptions field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup) GetOrCreateAsPathOptions() *Bgp_PeerGroup_AsPathOptions {
	if s.AsPathOptions != nil {
		return s.AsPathOptions
	}
	s.AsPathOptions = &Bgp_PeerGroup_AsPathOptions{}
	return s.AsPathOptions
}

// GetOrCreateEbgpMultihop retrieves the value of the EbgpMultihop field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup) GetOrCreateEbgpMultihop() *Bgp_PeerGroup_EbgpMultihop {
	if s.EbgpMultihop != nil {
		return s.EbgpMultihop
	}
	s.EbgpMultihop = &Bgp_PeerGroup_EbgpMultihop{}
	return s.EbgpMultihop
}

// GetOrCreateErrorHandling retrieves the value of the ErrorHandling field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup) GetOrCreateErrorHandling() *Bgp_PeerGroup_ErrorHandling {
	if s.ErrorHandling != nil {
		return s.ErrorHandling
	}
	s.ErrorHandling = &Bgp_PeerGroup_ErrorHandling{}
	return s.ErrorHandling
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup) GetOrCreateGracefulRestart() *Bgp_PeerGroup_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &Bgp_PeerGroup_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateLoggingOptions retrieves the value of the LoggingOptions field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup) GetOrCreateLoggingOptions() *Bgp_PeerGroup_LoggingOptions {
	if s.LoggingOptions != nil {
		return s.LoggingOptions
	}
	s.LoggingOptions = &Bgp_PeerGroup_LoggingOptions{}
	return s.LoggingOptions
}

// GetOrCreateRouteReflector retrieves the value of the RouteReflector field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup) GetOrCreateRouteReflector() *Bgp_PeerGroup_RouteReflector {
	if s.RouteReflector != nil {
		return s.RouteReflector
	}
	s.RouteReflector = &Bgp_PeerGroup_RouteReflector{}
	return s.RouteReflector
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup) GetOrCreateTimers() *Bgp_PeerGroup_Timers {
	if s.Timers != nil {
		return s.Timers
	}
	s.Timers = &Bgp_PeerGroup_Timers{}
	return s.Timers
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup) GetOrCreateTransport() *Bgp_PeerGroup_Transport {
	if s.Transport != nil {
		return s.Transport
	}
	s.Transport = &Bgp_PeerGroup_Transport{}
	return s.Transport
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup) GetOrCreateUseMultiplePaths() *Bgp_PeerGroup_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &Bgp_PeerGroup_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from Bgp_PeerGroup. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup) GetApplyPolicy() *Bgp_PeerGroup_ApplyPolicy {
	if s != nil && s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	return nil
}

// GetAsPathOptions returns the value of the AsPathOptions struct pointer
// from Bgp_PeerGroup. If the receiver or the field AsPathOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup) GetAsPathOptions() *Bgp_PeerGroup_AsPathOptions {
	if s != nil && s.AsPathOptions != nil {
		return s.AsPathOptions
	}
	return nil
}

// GetEbgpMultihop returns the value of the EbgpMultihop struct pointer
// from Bgp_PeerGroup. If the receiver or the field EbgpMultihop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup) GetEbgpMultihop() *Bgp_PeerGroup_EbgpMultihop {
	if s != nil && s.EbgpMultihop != nil {
		return s.EbgpMultihop
	}
	return nil
}

// GetErrorHandling returns the value of the ErrorHandling struct pointer
// from Bgp_PeerGroup. If the receiver or the field ErrorHandling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup) GetErrorHandling() *Bgp_PeerGroup_ErrorHandling {
	if s != nil && s.ErrorHandling != nil {
		return s.ErrorHandling
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_PeerGroup. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup) GetGracefulRestart() *Bgp_PeerGroup_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetLoggingOptions returns the value of the LoggingOptions struct pointer
// from Bgp_PeerGroup. If the receiver or the field LoggingOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup) GetLoggingOptions() *Bgp_PeerGroup_LoggingOptions {
	if s != nil && s.LoggingOptions != nil {
		return s.LoggingOptions
	}
	return nil
}

// GetRouteReflector returns the value of the RouteReflector struct pointer
// from Bgp_PeerGroup. If the receiver or the field RouteReflector is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup) GetRouteReflector() *Bgp_PeerGroup_RouteReflector {
	if s != nil && s.RouteReflector != nil {
		return s.RouteReflector
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from Bgp_PeerGroup. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup) GetTimers() *Bgp_PeerGroup_Timers {
	if s != nil && s.Timers != nil {
		return s.Timers
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from Bgp_PeerGroup. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup) GetTransport() *Bgp_PeerGroup_Transport {
	if s != nil && s.Transport != nil {
		return s.Transport
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_PeerGroup. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup) GetUseMultiplePaths() *Bgp_PeerGroup_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the Bgp_PeerGroup struct, which is a YANG list entry.
func (t *Bgp_PeerGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PeerGroupName == nil {
		return nil, fmt.Errorf("nil value for key PeerGroupName")
	}

	return map[string]interface{}{
		"peer-group-name": *t.PeerGroupName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateAddPaths() *Bgp_PeerGroup_AfiSafi_AddPaths {
	if s.AddPaths != nil {
		return s.AddPaths
	}
	s.AddPaths = &Bgp_PeerGroup_AfiSafi_AddPaths{}
	return s.AddPaths
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateApplyPolicy() *Bgp_PeerGroup_AfiSafi_ApplyPolicy {
	if s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	s.ApplyPolicy = &Bgp_PeerGroup_AfiSafi_ApplyPolicy{}
	return s.ApplyPolicy
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateGracefulRestart() *Bgp_PeerGroup_AfiSafi_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &Bgp_PeerGroup_AfiSafi_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateIpv4LabeledUnicast() *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast {
	if s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	s.Ipv4LabeledUnicast = &Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast{}
	return s.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateIpv4Unicast() *Bgp_PeerGroup_AfiSafi_Ipv4Unicast {
	if s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	s.Ipv4Unicast = &Bgp_PeerGroup_AfiSafi_Ipv4Unicast{}
	return s.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateIpv6LabeledUnicast() *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast {
	if s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	s.Ipv6LabeledUnicast = &Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast{}
	return s.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateIpv6Unicast() *Bgp_PeerGroup_AfiSafi_Ipv6Unicast {
	if s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	s.Ipv6Unicast = &Bgp_PeerGroup_AfiSafi_Ipv6Unicast{}
	return s.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateL2VpnEvpn() *Bgp_PeerGroup_AfiSafi_L2VpnEvpn {
	if s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	s.L2VpnEvpn = &Bgp_PeerGroup_AfiSafi_L2VpnEvpn{}
	return s.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateL2VpnVpls() *Bgp_PeerGroup_AfiSafi_L2VpnVpls {
	if s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	s.L2VpnVpls = &Bgp_PeerGroup_AfiSafi_L2VpnVpls{}
	return s.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast {
	if s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	s.L3VpnIpv4Multicast = &Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast{}
	return s.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast {
	if s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	s.L3VpnIpv4Unicast = &Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast{}
	return s.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast {
	if s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	s.L3VpnIpv6Multicast = &Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast{}
	return s.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast {
	if s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	s.L3VpnIpv6Unicast = &Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast{}
	return s.L3VpnIpv6Unicast
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateSrtePolicyIpv4() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4 {
	if s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	s.SrtePolicyIpv4 = &Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4{}
	return s.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateSrtePolicyIpv6() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6 {
	if s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	s.SrtePolicyIpv6 = &Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6{}
	return s.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi) GetOrCreateUseMultiplePaths() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &Bgp_PeerGroup_AfiSafi_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetAddPaths() *Bgp_PeerGroup_AfiSafi_AddPaths {
	if s != nil && s.AddPaths != nil {
		return s.AddPaths
	}
	return nil
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetApplyPolicy() *Bgp_PeerGroup_AfiSafi_ApplyPolicy {
	if s != nil && s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetGracefulRestart() *Bgp_PeerGroup_AfiSafi_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetIpv4LabeledUnicast() *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast {
	if s != nil && s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetIpv4Unicast() *Bgp_PeerGroup_AfiSafi_Ipv4Unicast {
	if s != nil && s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetIpv6LabeledUnicast() *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast {
	if s != nil && s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetIpv6Unicast() *Bgp_PeerGroup_AfiSafi_Ipv6Unicast {
	if s != nil && s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetL2VpnEvpn() *Bgp_PeerGroup_AfiSafi_L2VpnEvpn {
	if s != nil && s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetL2VpnVpls() *Bgp_PeerGroup_AfiSafi_L2VpnVpls {
	if s != nil && s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetL3VpnIpv4Multicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast {
	if s != nil && s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetL3VpnIpv4Unicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast {
	if s != nil && s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetL3VpnIpv6Multicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast {
	if s != nil && s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetL3VpnIpv6Unicast() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast {
	if s != nil && s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetSrtePolicyIpv4() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4 {
	if s != nil && s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetSrtePolicyIpv6() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6 {
	if s != nil && s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from Bgp_PeerGroup_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi) GetUseMultiplePaths() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the Bgp_PeerGroup_AfiSafi struct, which is a YANG list entry.
func (t *Bgp_PeerGroup_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_AddPaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_ApplyPolicy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_Ipv4Unicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_Ipv6Unicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_L2VpnEvpn) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L2VpnEvpn"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_L2VpnVpls) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L2VpnVpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetOrCreateIbgp() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp {
	if s.Ibgp != nil {
		return s.Ibgp
	}
	s.Ibgp = &Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp{}
	return s.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_PeerGroup_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetEbgp() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from Bgp_PeerGroup_AfiSafi_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetIbgp() *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp {
	if s != nil && s.Ibgp != nil {
		return s.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_ApplyPolicy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_AsPathOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_AsPathOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_AsPathOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_EbgpMultihop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_EbgpMultihop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_EbgpMultihop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_ErrorHandling) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_ErrorHandling"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_ErrorHandling) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_LoggingOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_LoggingOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_LoggingOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_RouteReflector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_RouteReflector"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_RouteReflector) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_Timers"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_Timers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_Transport"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_Transport) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_UseMultiplePaths) GetOrCreateEbgp() *Bgp_PeerGroup_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &Bgp_PeerGroup_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (s *Bgp_PeerGroup_UseMultiplePaths) GetOrCreateIbgp() *Bgp_PeerGroup_UseMultiplePaths_Ibgp {
	if s.Ibgp != nil {
		return s.Ibgp
	}
	s.Ibgp = &Bgp_PeerGroup_UseMultiplePaths_Ibgp{}
	return s.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from Bgp_PeerGroup_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_UseMultiplePaths) GetEbgp() *Bgp_PeerGroup_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from Bgp_PeerGroup_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Bgp_PeerGroup_UseMultiplePaths) GetIbgp() *Bgp_PeerGroup_UseMultiplePaths_Ibgp {
	if s != nil && s.Ibgp != nil {
		return s.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Bgp_PeerGroup_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Bgp_PeerGroup_UseMultiplePaths_Ibgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Bgp_PeerGroup_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewProperty creates a new entry in the Property list of the
// Component struct. The keys of the list are populated from the input
// arguments.
func (t *Component) NewProperty(Name string) (*Component_Property, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Property == nil {
		t.Property = make(map[string]*Component_Property)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Property[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Property", key)
	}

	t.Property[key] = &Component_Property{
		Name: &Name,
	}

	return t.Property[key], nil
}

// RenameProperty renames an entry in the list Property within
// the Component struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Component) RenameProperty(oldK, newK string) error {
	if _, ok := t.Property[newK]; ok {
		return fmt.Errorf("key %v already exists in Property", newK)
	}

	e, ok := t.Property[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Property", oldK)
	}
	e.Name = &newK

	t.Property[newK] = e
	delete(t.Property, oldK)
	return nil
}

// GetOrCreateProperty retrieves the value with the specified keys from
// the receiver Component. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Component) GetOrCreateProperty(Name string) *Component_Property {

	key := Name

	if v, ok := t.Property[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProperty(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProperty got unexpected error: %v", err))
	}
	return v
}

// GetProperty retrieves the value with the specified key from
// the Property map field of Component. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Component) GetProperty(Name string) *Component_Property {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Property[key]; ok {
		return lm
	}
	return nil
}

// AppendProperty appends the supplied Component_Property struct to the
// list Property of Component. If the key value(s) specified in
// the supplied Component_Property already exist in the list, an error is
// returned.
func (t *Component) AppendProperty(v *Component_Property) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Property == nil {
		t.Property = make(map[string]*Component_Property)
	}

	if _, ok := t.Property[key]; ok {
		return fmt.Errorf("duplicate key for list Property %v", key)
	}

	t.Property[key] = v
	return nil
}

// NewSubcomponent creates a new entry in the Subcomponent list of the
// Component struct. The keys of the list are populated from the input
// arguments.
func (t *Component) NewSubcomponent(Name string) (*Component_Subcomponent, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subcomponent == nil {
		t.Subcomponent = make(map[string]*Component_Subcomponent)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subcomponent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subcomponent", key)
	}

	t.Subcomponent[key] = &Component_Subcomponent{
		Name: &Name,
	}

	return t.Subcomponent[key], nil
}

// RenameSubcomponent renames an entry in the list Subcomponent within
// the Component struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Component) RenameSubcomponent(oldK, newK string) error {
	if _, ok := t.Subcomponent[newK]; ok {
		return fmt.Errorf("key %v already exists in Subcomponent", newK)
	}

	e, ok := t.Subcomponent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subcomponent", oldK)
	}
	e.Name = &newK

	t.Subcomponent[newK] = e
	delete(t.Subcomponent, oldK)
	return nil
}

// GetOrCreateSubcomponent retrieves the value with the specified keys from
// the receiver Component. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Component) GetOrCreateSubcomponent(Name string) *Component_Subcomponent {

	key := Name

	if v, ok := t.Subcomponent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubcomponent(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubcomponent got unexpected error: %v", err))
	}
	return v
}

// GetSubcomponent retrieves the value with the specified key from
// the Subcomponent map field of Component. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Component) GetSubcomponent(Name string) *Component_Subcomponent {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Subcomponent[key]; ok {
		return lm
	}
	return nil
}

// AppendSubcomponent appends the supplied Component_Subcomponent struct to the
// list Subcomponent of Component. If the key value(s) specified in
// the supplied Component_Subcomponent already exist in the list, an error is
// returned.
func (t *Component) AppendSubcomponent(v *Component_Subcomponent) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subcomponent == nil {
		t.Subcomponent = make(map[string]*Component_Subcomponent)
	}

	if _, ok := t.Subcomponent[key]; ok {
		return fmt.Errorf("duplicate key for list Subcomponent %v", key)
	}

	t.Subcomponent[key] = v
	return nil
}

// GetOrCreateBackplane retrieves the value of the Backplane field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateBackplane() *Component_Backplane {
	if s.Backplane != nil {
		return s.Backplane
	}
	s.Backplane = &Component_Backplane{}
	return s.Backplane
}

// GetOrCreateChassis retrieves the value of the Chassis field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateChassis() *Component_Chassis {
	if s.Chassis != nil {
		return s.Chassis
	}
	s.Chassis = &Component_Chassis{}
	return s.Chassis
}

// GetOrCreateCpu retrieves the value of the Cpu field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateCpu() *Component_Cpu {
	if s.Cpu != nil {
		return s.Cpu
	}
	s.Cpu = &Component_Cpu{}
	return s.Cpu
}

// GetOrCreateFabric retrieves the value of the Fabric field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateFabric() *Component_Fabric {
	if s.Fabric != nil {
		return s.Fabric
	}
	s.Fabric = &Component_Fabric{}
	return s.Fabric
}

// GetOrCreateFan retrieves the value of the Fan field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateFan() *Component_Fan {
	if s.Fan != nil {
		return s.Fan
	}
	s.Fan = &Component_Fan{}
	return s.Fan
}

// GetOrCreateIntegratedCircuit retrieves the value of the IntegratedCircuit field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateIntegratedCircuit() *Component_IntegratedCircuit {
	if s.IntegratedCircuit != nil {
		return s.IntegratedCircuit
	}
	s.IntegratedCircuit = &Component_IntegratedCircuit{}
	return s.IntegratedCircuit
}

// GetOrCreateMemory retrieves the value of the Memory field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateMemory() *Component_Memory {
	if s.Memory != nil {
		return s.Memory
	}
	s.Memory = &Component_Memory{}
	return s.Memory
}

// GetOrCreateOpticalChannel retrieves the value of the OpticalChannel field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateOpticalChannel() *Component_OpticalChannel {
	if s.OpticalChannel != nil {
		return s.OpticalChannel
	}
	s.OpticalChannel = &Component_OpticalChannel{}
	return s.OpticalChannel
}

// GetOrCreateOpticalPort retrieves the value of the OpticalPort field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateOpticalPort() *Component_OpticalPort {
	if s.OpticalPort != nil {
		return s.OpticalPort
	}
	s.OpticalPort = &Component_OpticalPort{}
	return s.OpticalPort
}

// GetOrCreatePort retrieves the value of the Port field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreatePort() *Component_Port {
	if s.Port != nil {
		return s.Port
	}
	s.Port = &Component_Port{}
	return s.Port
}

// GetOrCreatePowerSupply retrieves the value of the PowerSupply field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreatePowerSupply() *Component_PowerSupply {
	if s.PowerSupply != nil {
		return s.PowerSupply
	}
	s.PowerSupply = &Component_PowerSupply{}
	return s.PowerSupply
}

// GetOrCreateStorage retrieves the value of the Storage field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateStorage() *Component_Storage {
	if s.Storage != nil {
		return s.Storage
	}
	s.Storage = &Component_Storage{}
	return s.Storage
}

// GetOrCreateTemperature retrieves the value of the Temperature field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateTemperature() *Component_Temperature {
	if s.Temperature != nil {
		return s.Temperature
	}
	s.Temperature = &Component_Temperature{}
	return s.Temperature
}

// GetOrCreateTransceiver retrieves the value of the Transceiver field
// or returns the existing field if it already exists.
func (s *Component) GetOrCreateTransceiver() *Component_Transceiver {
	if s.Transceiver != nil {
		return s.Transceiver
	}
	s.Transceiver = &Component_Transceiver{}
	return s.Transceiver
}

// GetBackplane returns the value of the Backplane struct pointer
// from Component. If the receiver or the field Backplane is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetBackplane() *Component_Backplane {
	if s != nil && s.Backplane != nil {
		return s.Backplane
	}
	return nil
}

// GetChassis returns the value of the Chassis struct pointer
// from Component. If the receiver or the field Chassis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetChassis() *Component_Chassis {
	if s != nil && s.Chassis != nil {
		return s.Chassis
	}
	return nil
}

// GetCpu returns the value of the Cpu struct pointer
// from Component. If the receiver or the field Cpu is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetCpu() *Component_Cpu {
	if s != nil && s.Cpu != nil {
		return s.Cpu
	}
	return nil
}

// GetFabric returns the value of the Fabric struct pointer
// from Component. If the receiver or the field Fabric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetFabric() *Component_Fabric {
	if s != nil && s.Fabric != nil {
		return s.Fabric
	}
	return nil
}

// GetFan returns the value of the Fan struct pointer
// from Component. If the receiver or the field Fan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetFan() *Component_Fan {
	if s != nil && s.Fan != nil {
		return s.Fan
	}
	return nil
}

// GetIntegratedCircuit returns the value of the IntegratedCircuit struct pointer
// from Component. If the receiver or the field IntegratedCircuit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetIntegratedCircuit() *Component_IntegratedCircuit {
	if s != nil && s.IntegratedCircuit != nil {
		return s.IntegratedCircuit
	}
	return nil
}

// GetMemory returns the value of the Memory struct pointer
// from Component. If the receiver or the field Memory is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetMemory() *Component_Memory {
	if s != nil && s.Memory != nil {
		return s.Memory
	}
	return nil
}

// GetOpticalChannel returns the value of the OpticalChannel struct pointer
// from Component. If the receiver or the field OpticalChannel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetOpticalChannel() *Component_OpticalChannel {
	if s != nil && s.OpticalChannel != nil {
		return s.OpticalChannel
	}
	return nil
}

// GetOpticalPort returns the value of the OpticalPort struct pointer
// from Component. If the receiver or the field OpticalPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetOpticalPort() *Component_OpticalPort {
	if s != nil && s.OpticalPort != nil {
		return s.OpticalPort
	}
	return nil
}

// GetPort returns the value of the Port struct pointer
// from Component. If the receiver or the field Port is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetPort() *Component_Port {
	if s != nil && s.Port != nil {
		return s.Port
	}
	return nil
}

// GetPowerSupply returns the value of the PowerSupply struct pointer
// from Component. If the receiver or the field PowerSupply is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetPowerSupply() *Component_PowerSupply {
	if s != nil && s.PowerSupply != nil {
		return s.PowerSupply
	}
	return nil
}

// GetStorage returns the value of the Storage struct pointer
// from Component. If the receiver or the field Storage is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetStorage() *Component_Storage {
	if s != nil && s.Storage != nil {
		return s.Storage
	}
	return nil
}

// GetTemperature returns the value of the Temperature struct pointer
// from Component. If the receiver or the field Temperature is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetTemperature() *Component_Temperature {
	if s != nil && s.Temperature != nil {
		return s.Temperature
	}
	return nil
}

// GetTransceiver returns the value of the Transceiver struct pointer
// from Component. If the receiver or the field Transceiver is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component) GetTransceiver() *Component_Transceiver {
	if s != nil && s.Transceiver != nil {
		return s.Transceiver
	}
	return nil
}

// ΛListKeyMap returns the keys of the Component struct, which is a YANG list entry.
func (t *Component) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Backplane) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Backplane"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Backplane) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Chassis) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Chassis"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Chassis) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Cpu) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Cpu"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Cpu) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Fabric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Fabric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Fabric) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Fan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Fan"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Fan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_IntegratedCircuit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_IntegratedCircuit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_IntegratedCircuit) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Memory) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Memory"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Memory) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateChromaticDispersion retrieves the value of the ChromaticDispersion field
// or returns the existing field if it already exists.
func (s *Component_OpticalChannel) GetOrCreateChromaticDispersion() *Component_OpticalChannel_ChromaticDispersion {
	if s.ChromaticDispersion != nil {
		return s.ChromaticDispersion
	}
	s.ChromaticDispersion = &Component_OpticalChannel_ChromaticDispersion{}
	return s.ChromaticDispersion
}

// GetOrCreateInputPower retrieves the value of the InputPower field
// or returns the existing field if it already exists.
func (s *Component_OpticalChannel) GetOrCreateInputPower() *Component_OpticalChannel_InputPower {
	if s.InputPower != nil {
		return s.InputPower
	}
	s.InputPower = &Component_OpticalChannel_InputPower{}
	return s.InputPower
}

// GetOrCreateLaserBiasCurrent retrieves the value of the LaserBiasCurrent field
// or returns the existing field if it already exists.
func (s *Component_OpticalChannel) GetOrCreateLaserBiasCurrent() *Component_OpticalChannel_LaserBiasCurrent {
	if s.LaserBiasCurrent != nil {
		return s.LaserBiasCurrent
	}
	s.LaserBiasCurrent = &Component_OpticalChannel_LaserBiasCurrent{}
	return s.LaserBiasCurrent
}

// GetOrCreateOutputPower retrieves the value of the OutputPower field
// or returns the existing field if it already exists.
func (s *Component_OpticalChannel) GetOrCreateOutputPower() *Component_OpticalChannel_OutputPower {
	if s.OutputPower != nil {
		return s.OutputPower
	}
	s.OutputPower = &Component_OpticalChannel_OutputPower{}
	return s.OutputPower
}

// GetOrCreatePolarizationDependentLoss retrieves the value of the PolarizationDependentLoss field
// or returns the existing field if it already exists.
func (s *Component_OpticalChannel) GetOrCreatePolarizationDependentLoss() *Component_OpticalChannel_PolarizationDependentLoss {
	if s.PolarizationDependentLoss != nil {
		return s.PolarizationDependentLoss
	}
	s.PolarizationDependentLoss = &Component_OpticalChannel_PolarizationDependentLoss{}
	return s.PolarizationDependentLoss
}

// GetOrCreatePolarizationModeDispersion retrieves the value of the PolarizationModeDispersion field
// or returns the existing field if it already exists.
func (s *Component_OpticalChannel) GetOrCreatePolarizationModeDispersion() *Component_OpticalChannel_PolarizationModeDispersion {
	if s.PolarizationModeDispersion != nil {
		return s.PolarizationModeDispersion
	}
	s.PolarizationModeDispersion = &Component_OpticalChannel_PolarizationModeDispersion{}
	return s.PolarizationModeDispersion
}

// GetOrCreateSecondOrderPolarizationModeDispersion retrieves the value of the SecondOrderPolarizationModeDispersion field
// or returns the existing field if it already exists.
func (s *Component_OpticalChannel) GetOrCreateSecondOrderPolarizationModeDispersion() *Component_OpticalChannel_SecondOrderPolarizationModeDispersion {
	if s.SecondOrderPolarizationModeDispersion != nil {
		return s.SecondOrderPolarizationModeDispersion
	}
	s.SecondOrderPolarizationModeDispersion = &Component_OpticalChannel_SecondOrderPolarizationModeDispersion{}
	return s.SecondOrderPolarizationModeDispersion
}

// GetChromaticDispersion returns the value of the ChromaticDispersion struct pointer
// from Component_OpticalChannel. If the receiver or the field ChromaticDispersion is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_OpticalChannel) GetChromaticDispersion() *Component_OpticalChannel_ChromaticDispersion {
	if s != nil && s.ChromaticDispersion != nil {
		return s.ChromaticDispersion
	}
	return nil
}

// GetInputPower returns the value of the InputPower struct pointer
// from Component_OpticalChannel. If the receiver or the field InputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_OpticalChannel) GetInputPower() *Component_OpticalChannel_InputPower {
	if s != nil && s.InputPower != nil {
		return s.InputPower
	}
	return nil
}

// GetLaserBiasCurrent returns the value of the LaserBiasCurrent struct pointer
// from Component_OpticalChannel. If the receiver or the field LaserBiasCurrent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_OpticalChannel) GetLaserBiasCurrent() *Component_OpticalChannel_LaserBiasCurrent {
	if s != nil && s.LaserBiasCurrent != nil {
		return s.LaserBiasCurrent
	}
	return nil
}

// GetOutputPower returns the value of the OutputPower struct pointer
// from Component_OpticalChannel. If the receiver or the field OutputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_OpticalChannel) GetOutputPower() *Component_OpticalChannel_OutputPower {
	if s != nil && s.OutputPower != nil {
		return s.OutputPower
	}
	return nil
}

// GetPolarizationDependentLoss returns the value of the PolarizationDependentLoss struct pointer
// from Component_OpticalChannel. If the receiver or the field PolarizationDependentLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_OpticalChannel) GetPolarizationDependentLoss() *Component_OpticalChannel_PolarizationDependentLoss {
	if s != nil && s.PolarizationDependentLoss != nil {
		return s.PolarizationDependentLoss
	}
	return nil
}

// GetPolarizationModeDispersion returns the value of the PolarizationModeDispersion struct pointer
// from Component_OpticalChannel. If the receiver or the field PolarizationModeDispersion is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_OpticalChannel) GetPolarizationModeDispersion() *Component_OpticalChannel_PolarizationModeDispersion {
	if s != nil && s.PolarizationModeDispersion != nil {
		return s.PolarizationModeDispersion
	}
	return nil
}

// GetSecondOrderPolarizationModeDispersion returns the value of the SecondOrderPolarizationModeDispersion struct pointer
// from Component_OpticalChannel. If the receiver or the field SecondOrderPolarizationModeDispersion is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_OpticalChannel) GetSecondOrderPolarizationModeDispersion() *Component_OpticalChannel_SecondOrderPolarizationModeDispersion {
	if s != nil && s.SecondOrderPolarizationModeDispersion != nil {
		return s.SecondOrderPolarizationModeDispersion
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_OpticalChannel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_OpticalChannel_ChromaticDispersion) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_ChromaticDispersion"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_ChromaticDispersion) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_OpticalChannel_InputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_InputPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_InputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_OpticalChannel_LaserBiasCurrent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_LaserBiasCurrent"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_LaserBiasCurrent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_OpticalChannel_OutputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_OutputPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_OutputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_OpticalChannel_PolarizationDependentLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_PolarizationDependentLoss"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_PolarizationDependentLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_OpticalChannel_PolarizationModeDispersion) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_PolarizationModeDispersion"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_PolarizationModeDispersion) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_OpticalChannel_SecondOrderPolarizationModeDispersion) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalChannel_SecondOrderPolarizationModeDispersion"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalChannel_SecondOrderPolarizationModeDispersion) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInputPower retrieves the value of the InputPower field
// or returns the existing field if it already exists.
func (s *Component_OpticalPort) GetOrCreateInputPower() *Component_OpticalPort_InputPower {
	if s.InputPower != nil {
		return s.InputPower
	}
	s.InputPower = &Component_OpticalPort_InputPower{}
	return s.InputPower
}

// GetOrCreateOutputPower retrieves the value of the OutputPower field
// or returns the existing field if it already exists.
func (s *Component_OpticalPort) GetOrCreateOutputPower() *Component_OpticalPort_OutputPower {
	if s.OutputPower != nil {
		return s.OutputPower
	}
	s.OutputPower = &Component_OpticalPort_OutputPower{}
	return s.OutputPower
}

// GetInputPower returns the value of the InputPower struct pointer
// from Component_OpticalPort. If the receiver or the field InputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_OpticalPort) GetInputPower() *Component_OpticalPort_InputPower {
	if s != nil && s.InputPower != nil {
		return s.InputPower
	}
	return nil
}

// GetOutputPower returns the value of the OutputPower struct pointer
// from Component_OpticalPort. If the receiver or the field OutputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_OpticalPort) GetOutputPower() *Component_OpticalPort_OutputPower {
	if s != nil && s.OutputPower != nil {
		return s.OutputPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_OpticalPort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalPort"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalPort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_OpticalPort_InputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalPort_InputPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalPort_InputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_OpticalPort_OutputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_OpticalPort_OutputPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_OpticalPort_OutputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateBreakoutMode retrieves the value of the BreakoutMode field
// or returns the existing field if it already exists.
func (s *Component_Port) GetOrCreateBreakoutMode() *Component_Port_BreakoutMode {
	if s.BreakoutMode != nil {
		return s.BreakoutMode
	}
	s.BreakoutMode = &Component_Port_BreakoutMode{}
	return s.BreakoutMode
}

// GetBreakoutMode returns the value of the BreakoutMode struct pointer
// from Component_Port. If the receiver or the field BreakoutMode is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_Port) GetBreakoutMode() *Component_Port_BreakoutMode {
	if s != nil && s.BreakoutMode != nil {
		return s.BreakoutMode
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Port) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Port"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Port) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Port_BreakoutMode) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Port_BreakoutMode"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Port_BreakoutMode) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_PowerSupply) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_PowerSupply"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_PowerSupply) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Component_Property struct, which is a YANG list entry.
func (t *Component_Property) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Property) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Property"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Property) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Storage) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Storage"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Storage) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Component_Subcomponent struct, which is a YANG list entry.
func (t *Component_Subcomponent) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Subcomponent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Subcomponent"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Subcomponent) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Temperature) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Temperature"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Temperature) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewChannel creates a new entry in the Channel list of the
// Component_Transceiver struct. The keys of the list are populated from the input
// arguments.
func (t *Component_Transceiver) NewChannel(Index uint16) (*Component_Transceiver_Channel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Channel == nil {
		t.Channel = make(map[uint16]*Component_Transceiver_Channel)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Channel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Channel", key)
	}

	t.Channel[key] = &Component_Transceiver_Channel{
		Index: &Index,
	}

	return t.Channel[key], nil
}

// RenameChannel renames an entry in the list Channel within
// the Component_Transceiver struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Component_Transceiver) RenameChannel(oldK, newK uint16) error {
	if _, ok := t.Channel[newK]; ok {
		return fmt.Errorf("key %v already exists in Channel", newK)
	}

	e, ok := t.Channel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Channel", oldK)
	}
	e.Index = &newK

	t.Channel[newK] = e
	delete(t.Channel, oldK)
	return nil
}

// GetOrCreateChannel retrieves the value with the specified keys from
// the receiver Component_Transceiver. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Component_Transceiver) GetOrCreateChannel(Index uint16) *Component_Transceiver_Channel {

	key := Index

	if v, ok := t.Channel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewChannel(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateChannel got unexpected error: %v", err))
	}
	return v
}

// GetChannel retrieves the value with the specified key from
// the Channel map field of Component_Transceiver. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Component_Transceiver) GetChannel(Index uint16) *Component_Transceiver_Channel {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Channel[key]; ok {
		return lm
	}
	return nil
}

// AppendChannel appends the supplied Component_Transceiver_Channel struct to the
// list Channel of Component_Transceiver. If the key value(s) specified in
// the supplied Component_Transceiver_Channel already exist in the list, an error is
// returned.
func (t *Component_Transceiver) AppendChannel(v *Component_Transceiver_Channel) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Channel == nil {
		t.Channel = make(map[uint16]*Component_Transceiver_Channel)
	}

	if _, ok := t.Channel[key]; ok {
		return fmt.Errorf("duplicate key for list Channel %v", key)
	}

	t.Channel[key] = v
	return nil
}

// GetOrCreateInputPower retrieves the value of the InputPower field
// or returns the existing field if it already exists.
func (s *Component_Transceiver) GetOrCreateInputPower() *Component_Transceiver_InputPower {
	if s.InputPower != nil {
		return s.InputPower
	}
	s.InputPower = &Component_Transceiver_InputPower{}
	return s.InputPower
}

// GetOrCreateLaserBiasCurrent retrieves the value of the LaserBiasCurrent field
// or returns the existing field if it already exists.
func (s *Component_Transceiver) GetOrCreateLaserBiasCurrent() *Component_Transceiver_LaserBiasCurrent {
	if s.LaserBiasCurrent != nil {
		return s.LaserBiasCurrent
	}
	s.LaserBiasCurrent = &Component_Transceiver_LaserBiasCurrent{}
	return s.LaserBiasCurrent
}

// GetOrCreateOutputPower retrieves the value of the OutputPower field
// or returns the existing field if it already exists.
func (s *Component_Transceiver) GetOrCreateOutputPower() *Component_Transceiver_OutputPower {
	if s.OutputPower != nil {
		return s.OutputPower
	}
	s.OutputPower = &Component_Transceiver_OutputPower{}
	return s.OutputPower
}

// GetInputPower returns the value of the InputPower struct pointer
// from Component_Transceiver. If the receiver or the field InputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_Transceiver) GetInputPower() *Component_Transceiver_InputPower {
	if s != nil && s.InputPower != nil {
		return s.InputPower
	}
	return nil
}

// GetLaserBiasCurrent returns the value of the LaserBiasCurrent struct pointer
// from Component_Transceiver. If the receiver or the field LaserBiasCurrent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_Transceiver) GetLaserBiasCurrent() *Component_Transceiver_LaserBiasCurrent {
	if s != nil && s.LaserBiasCurrent != nil {
		return s.LaserBiasCurrent
	}
	return nil
}

// GetOutputPower returns the value of the OutputPower struct pointer
// from Component_Transceiver. If the receiver or the field OutputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_Transceiver) GetOutputPower() *Component_Transceiver_OutputPower {
	if s != nil && s.OutputPower != nil {
		return s.OutputPower
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Transceiver) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInputPower retrieves the value of the InputPower field
// or returns the existing field if it already exists.
func (s *Component_Transceiver_Channel) GetOrCreateInputPower() *Component_Transceiver_Channel_InputPower {
	if s.InputPower != nil {
		return s.InputPower
	}
	s.InputPower = &Component_Transceiver_Channel_InputPower{}
	return s.InputPower
}

// GetOrCreateLaserBiasCurrent retrieves the value of the LaserBiasCurrent field
// or returns the existing field if it already exists.
func (s *Component_Transceiver_Channel) GetOrCreateLaserBiasCurrent() *Component_Transceiver_Channel_LaserBiasCurrent {
	if s.LaserBiasCurrent != nil {
		return s.LaserBiasCurrent
	}
	s.LaserBiasCurrent = &Component_Transceiver_Channel_LaserBiasCurrent{}
	return s.LaserBiasCurrent
}

// GetOrCreateOutputPower retrieves the value of the OutputPower field
// or returns the existing field if it already exists.
func (s *Component_Transceiver_Channel) GetOrCreateOutputPower() *Component_Transceiver_Channel_OutputPower {
	if s.OutputPower != nil {
		return s.OutputPower
	}
	s.OutputPower = &Component_Transceiver_Channel_OutputPower{}
	return s.OutputPower
}

// GetInputPower returns the value of the InputPower struct pointer
// from Component_Transceiver_Channel. If the receiver or the field InputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_Transceiver_Channel) GetInputPower() *Component_Transceiver_Channel_InputPower {
	if s != nil && s.InputPower != nil {
		return s.InputPower
	}
	return nil
}

// GetLaserBiasCurrent returns the value of the LaserBiasCurrent struct pointer
// from Component_Transceiver_Channel. If the receiver or the field LaserBiasCurrent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_Transceiver_Channel) GetLaserBiasCurrent() *Component_Transceiver_Channel_LaserBiasCurrent {
	if s != nil && s.LaserBiasCurrent != nil {
		return s.LaserBiasCurrent
	}
	return nil
}

// GetOutputPower returns the value of the OutputPower struct pointer
// from Component_Transceiver_Channel. If the receiver or the field OutputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Component_Transceiver_Channel) GetOutputPower() *Component_Transceiver_Channel_OutputPower {
	if s != nil && s.OutputPower != nil {
		return s.OutputPower
	}
	return nil
}

// ΛListKeyMap returns the keys of the Component_Transceiver_Channel struct, which is a YANG list entry.
func (t *Component_Transceiver_Channel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Transceiver_Channel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_Channel"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_Channel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Transceiver_Channel_InputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_Channel_InputPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_Channel_InputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Transceiver_Channel_LaserBiasCurrent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_Channel_LaserBiasCurrent"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_Channel_LaserBiasCurrent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Transceiver_Channel_OutputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_Channel_OutputPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_Channel_OutputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Transceiver_InputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_InputPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_InputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Transceiver_LaserBiasCurrent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_LaserBiasCurrent"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_LaserBiasCurrent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Component_Transceiver_OutputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Component_Transceiver_OutputPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Component_Transceiver_OutputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewComponent creates a new entry in the Component list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewComponent(Name string) (*Component, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Component == nil {
		t.Component = make(map[string]*Component)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Component[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Component", key)
	}

	t.Component[key] = &Component{
		Name: &Name,
	}

	return t.Component[key], nil
}

// RenameComponent renames an entry in the list Component within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameComponent(oldK, newK string) error {
	if _, ok := t.Component[newK]; ok {
		return fmt.Errorf("key %v already exists in Component", newK)
	}

	e, ok := t.Component[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Component", oldK)
	}
	e.Name = &newK

	t.Component[newK] = e
	delete(t.Component, oldK)
	return nil
}

// GetOrCreateComponent retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateComponent(Name string) *Component {

	key := Name

	if v, ok := t.Component[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewComponent(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateComponent got unexpected error: %v", err))
	}
	return v
}

// GetComponent retrieves the value with the specified key from
// the Component map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetComponent(Name string) *Component {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Component[key]; ok {
		return lm
	}
	return nil
}

// AppendComponent appends the supplied Component struct to the
// list Component of Device. If the key value(s) specified in
// the supplied Component already exist in the list, an error is
// returned.
func (t *Device) AppendComponent(v *Component) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Component == nil {
		t.Component = make(map[string]*Component)
	}

	if _, ok := t.Component[key]; ok {
		return fmt.Errorf("duplicate key for list Component %v", key)
	}

	t.Component[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewInterface(Name string) (*Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateInterface(Name string) *Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetInterface(Name string) *Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Interface struct to the
// list Interface of Device. If the key value(s) specified in
// the supplied Interface already exist in the list, an error is
// returned.
func (t *Device) AppendInterface(v *Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewNetworkInstance(Name string) (*NetworkInstance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateNetworkInstance(Name string) *NetworkInstance {

	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetNetworkInstance(Name string) *NetworkInstance {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// AppendNetworkInstance appends the supplied NetworkInstance struct to the
// list NetworkInstance of Device. If the key value(s) specified in
// the supplied NetworkInstance already exist in the list, an error is
// returned.
func (t *Device) AppendNetworkInstance(v *NetworkInstance) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetOrCreateAps retrieves the value of the Aps field
// or returns the existing field if it already exists.
func (s *Device) GetOrCreateAps() *Aps {
	if s.Aps != nil {
		return s.Aps
	}
	s.Aps = &Aps{}
	return s.Aps
}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (s *Device) GetOrCreateBgp() *Bgp {
	if s.Bgp != nil {
		return s.Bgp
	}
	s.Bgp = &Bgp{}
	return s.Bgp
}

// GetOrCreateLacp retrieves the value of the Lacp field
// or returns the existing field if it already exists.
func (s *Device) GetOrCreateLacp() *Lacp {
	if s.Lacp != nil {
		return s.Lacp
	}
	s.Lacp = &Lacp{}
	return s.Lacp
}

// GetOrCreateLldp retrieves the value of the Lldp field
// or returns the existing field if it already exists.
func (s *Device) GetOrCreateLldp() *Lldp {
	if s.Lldp != nil {
		return s.Lldp
	}
	s.Lldp = &Lldp{}
	return s.Lldp
}

// GetOrCreateLocalRoutes retrieves the value of the LocalRoutes field
// or returns the existing field if it already exists.
func (s *Device) GetOrCreateLocalRoutes() *LocalRoutes {
	if s.LocalRoutes != nil {
		return s.LocalRoutes
	}
	s.LocalRoutes = &LocalRoutes{}
	return s.LocalRoutes
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (s *Device) GetOrCreateMpls() *Mpls {
	if s.Mpls != nil {
		return s.Mpls
	}
	s.Mpls = &Mpls{}
	return s.Mpls
}

// GetOrCreateOpticalAmplifier retrieves the value of the OpticalAmplifier field
// or returns the existing field if it already exists.
func (s *Device) GetOrCreateOpticalAmplifier() *OpticalAmplifier {
	if s.OpticalAmplifier != nil {
		return s.OpticalAmplifier
	}
	s.OpticalAmplifier = &OpticalAmplifier{}
	return s.OpticalAmplifier
}

// GetOrCreateRoutingPolicy retrieves the value of the RoutingPolicy field
// or returns the existing field if it already exists.
func (s *Device) GetOrCreateRoutingPolicy() *RoutingPolicy {
	if s.RoutingPolicy != nil {
		return s.RoutingPolicy
	}
	s.RoutingPolicy = &RoutingPolicy{}
	return s.RoutingPolicy
}

// GetOrCreateStp retrieves the value of the Stp field
// or returns the existing field if it already exists.
func (s *Device) GetOrCreateStp() *Stp {
	if s.Stp != nil {
		return s.Stp
	}
	s.Stp = &Stp{}
	return s.Stp
}

// GetOrCreateSystem retrieves the value of the System field
// or returns the existing field if it already exists.
func (s *Device) GetOrCreateSystem() *System {
	if s.System != nil {
		return s.System
	}
	s.System = &System{}
	return s.System
}

// GetOrCreateTerminalDevice retrieves the value of the TerminalDevice field
// or returns the existing field if it already exists.
func (s *Device) GetOrCreateTerminalDevice() *TerminalDevice {
	if s.TerminalDevice != nil {
		return s.TerminalDevice
	}
	s.TerminalDevice = &TerminalDevice{}
	return s.TerminalDevice
}

// GetAps returns the value of the Aps struct pointer
// from Device. If the receiver or the field Aps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Device) GetAps() *Aps {
	if s != nil && s.Aps != nil {
		return s.Aps
	}
	return nil
}

// GetBgp returns the value of the Bgp struct pointer
// from Device. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Device) GetBgp() *Bgp {
	if s != nil && s.Bgp != nil {
		return s.Bgp
	}
	return nil
}

// GetLacp returns the value of the Lacp struct pointer
// from Device. If the receiver or the field Lacp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Device) GetLacp() *Lacp {
	if s != nil && s.Lacp != nil {
		return s.Lacp
	}
	return nil
}

// GetLldp returns the value of the Lldp struct pointer
// from Device. If the receiver or the field Lldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Device) GetLldp() *Lldp {
	if s != nil && s.Lldp != nil {
		return s.Lldp
	}
	return nil
}

// GetLocalRoutes returns the value of the LocalRoutes struct pointer
// from Device. If the receiver or the field LocalRoutes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Device) GetLocalRoutes() *LocalRoutes {
	if s != nil && s.LocalRoutes != nil {
		return s.LocalRoutes
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from Device. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Device) GetMpls() *Mpls {
	if s != nil && s.Mpls != nil {
		return s.Mpls
	}
	return nil
}

// GetOpticalAmplifier returns the value of the OpticalAmplifier struct pointer
// from Device. If the receiver or the field OpticalAmplifier is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Device) GetOpticalAmplifier() *OpticalAmplifier {
	if s != nil && s.OpticalAmplifier != nil {
		return s.OpticalAmplifier
	}
	return nil
}

// GetRoutingPolicy returns the value of the RoutingPolicy struct pointer
// from Device. If the receiver or the field RoutingPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Device) GetRoutingPolicy() *RoutingPolicy {
	if s != nil && s.RoutingPolicy != nil {
		return s.RoutingPolicy
	}
	return nil
}

// GetStp returns the value of the Stp struct pointer
// from Device. If the receiver or the field Stp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Device) GetStp() *Stp {
	if s != nil && s.Stp != nil {
		return s.Stp
	}
	return nil
}

// GetSystem returns the value of the System struct pointer
// from Device. If the receiver or the field System is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Device) GetSystem() *System {
	if s != nil && s.System != nil {
		return s.System
	}
	return nil
}

// GetTerminalDevice returns the value of the TerminalDevice struct pointer
// from Device. If the receiver or the field TerminalDevice is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Device) GetTerminalDevice() *TerminalDevice {
	if s != nil && s.TerminalDevice != nil {
		return s.TerminalDevice
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Device) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Device"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Device) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewSubinterface creates a new entry in the Subinterface list of the
// Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Interface) NewSubinterface(Index uint32) (*Interface_Subinterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*Interface_Subinterface)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &Interface_Subinterface{
		Index: &Index,
	}

	return t.Subinterface[key], nil
}

// RenameSubinterface renames an entry in the list Subinterface within
// the Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface) RenameSubinterface(oldK, newK uint32) error {
	if _, ok := t.Subinterface[newK]; ok {
		return fmt.Errorf("key %v already exists in Subinterface", newK)
	}

	e, ok := t.Subinterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subinterface", oldK)
	}
	e.Index = &newK

	t.Subinterface[newK] = e
	delete(t.Subinterface, oldK)
	return nil
}

// GetOrCreateSubinterface retrieves the value with the specified keys from
// the receiver Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface) GetOrCreateSubinterface(Index uint32) *Interface_Subinterface {

	key := Index

	if v, ok := t.Subinterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubinterface(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubinterface got unexpected error: %v", err))
	}
	return v
}

// GetSubinterface retrieves the value with the specified key from
// the Subinterface map field of Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface) GetSubinterface(Index uint32) *Interface_Subinterface {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Subinterface[key]; ok {
		return lm
	}
	return nil
}

// AppendSubinterface appends the supplied Interface_Subinterface struct to the
// list Subinterface of Interface. If the key value(s) specified in
// the supplied Interface_Subinterface already exist in the list, an error is
// returned.
func (t *Interface) AppendSubinterface(v *Interface_Subinterface) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*Interface_Subinterface)
	}

	if _, ok := t.Subinterface[key]; ok {
		return fmt.Errorf("duplicate key for list Subinterface %v", key)
	}

	t.Subinterface[key] = v
	return nil
}

// GetOrCreateAggregation retrieves the value of the Aggregation field
// or returns the existing field if it already exists.
func (s *Interface) GetOrCreateAggregation() *Interface_Aggregation {
	if s.Aggregation != nil {
		return s.Aggregation
	}
	s.Aggregation = &Interface_Aggregation{}
	return s.Aggregation
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Interface) GetOrCreateCounters() *Interface_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Interface_Counters{}
	return s.Counters
}

// GetOrCreateEthernet retrieves the value of the Ethernet field
// or returns the existing field if it already exists.
func (s *Interface) GetOrCreateEthernet() *Interface_Ethernet {
	if s.Ethernet != nil {
		return s.Ethernet
	}
	s.Ethernet = &Interface_Ethernet{}
	return s.Ethernet
}

// GetOrCreateHoldTime retrieves the value of the HoldTime field
// or returns the existing field if it already exists.
func (s *Interface) GetOrCreateHoldTime() *Interface_HoldTime {
	if s.HoldTime != nil {
		return s.HoldTime
	}
	s.HoldTime = &Interface_HoldTime{}
	return s.HoldTime
}

// GetOrCreateRoutedVlan retrieves the value of the RoutedVlan field
// or returns the existing field if it already exists.
func (s *Interface) GetOrCreateRoutedVlan() *Interface_RoutedVlan {
	if s.RoutedVlan != nil {
		return s.RoutedVlan
	}
	s.RoutedVlan = &Interface_RoutedVlan{}
	return s.RoutedVlan
}

// GetOrCreateSonet retrieves the value of the Sonet field
// or returns the existing field if it already exists.
func (s *Interface) GetOrCreateSonet() *Interface_Sonet {
	if s.Sonet != nil {
		return s.Sonet
	}
	s.Sonet = &Interface_Sonet{}
	return s.Sonet
}

// GetAggregation returns the value of the Aggregation struct pointer
// from Interface. If the receiver or the field Aggregation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface) GetAggregation() *Interface_Aggregation {
	if s != nil && s.Aggregation != nil {
		return s.Aggregation
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface) GetCounters() *Interface_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetEthernet returns the value of the Ethernet struct pointer
// from Interface. If the receiver or the field Ethernet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface) GetEthernet() *Interface_Ethernet {
	if s != nil && s.Ethernet != nil {
		return s.Ethernet
	}
	return nil
}

// GetHoldTime returns the value of the HoldTime struct pointer
// from Interface. If the receiver or the field HoldTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface) GetHoldTime() *Interface_HoldTime {
	if s != nil && s.HoldTime != nil {
		return s.HoldTime
	}
	return nil
}

// GetRoutedVlan returns the value of the RoutedVlan struct pointer
// from Interface. If the receiver or the field RoutedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface) GetRoutedVlan() *Interface_RoutedVlan {
	if s != nil && s.RoutedVlan != nil {
		return s.RoutedVlan
	}
	return nil
}

// GetSonet returns the value of the Sonet struct pointer
// from Interface. If the receiver or the field Sonet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface) GetSonet() *Interface_Sonet {
	if s != nil && s.Sonet != nil {
		return s.Sonet
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface struct, which is a YANG list entry.
func (t *Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateSwitchedVlan retrieves the value of the SwitchedVlan field
// or returns the existing field if it already exists.
func (s *Interface_Aggregation) GetOrCreateSwitchedVlan() *Interface_Aggregation_SwitchedVlan {
	if s.SwitchedVlan != nil {
		return s.SwitchedVlan
	}
	s.SwitchedVlan = &Interface_Aggregation_SwitchedVlan{}
	return s.SwitchedVlan
}

// GetSwitchedVlan returns the value of the SwitchedVlan struct pointer
// from Interface_Aggregation. If the receiver or the field SwitchedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Aggregation) GetSwitchedVlan() *Interface_Aggregation_SwitchedVlan {
	if s != nil && s.SwitchedVlan != nil {
		return s.SwitchedVlan
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Aggregation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Aggregation"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Aggregation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Aggregation_SwitchedVlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Aggregation_SwitchedVlan"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Aggregation_SwitchedVlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Interface_Ethernet) GetOrCreateCounters() *Interface_Ethernet_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Interface_Ethernet_Counters{}
	return s.Counters
}

// GetOrCreateSwitchedVlan retrieves the value of the SwitchedVlan field
// or returns the existing field if it already exists.
func (s *Interface_Ethernet) GetOrCreateSwitchedVlan() *Interface_Ethernet_SwitchedVlan {
	if s.SwitchedVlan != nil {
		return s.SwitchedVlan
	}
	s.SwitchedVlan = &Interface_Ethernet_SwitchedVlan{}
	return s.SwitchedVlan
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Ethernet. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Ethernet) GetCounters() *Interface_Ethernet_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetSwitchedVlan returns the value of the SwitchedVlan struct pointer
// from Interface_Ethernet. If the receiver or the field SwitchedVlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Ethernet) GetSwitchedVlan() *Interface_Ethernet_SwitchedVlan {
	if s != nil && s.SwitchedVlan != nil {
		return s.SwitchedVlan
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Ethernet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Ethernet_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Ethernet_SwitchedVlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ethernet_SwitchedVlan"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ethernet_SwitchedVlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_HoldTime) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_HoldTime"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_HoldTime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan) GetOrCreateIpv4() *Interface_RoutedVlan_Ipv4 {
	if s.Ipv4 != nil {
		return s.Ipv4
	}
	s.Ipv4 = &Interface_RoutedVlan_Ipv4{}
	return s.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan) GetOrCreateIpv6() *Interface_RoutedVlan_Ipv6 {
	if s.Ipv6 != nil {
		return s.Ipv6
	}
	s.Ipv6 = &Interface_RoutedVlan_Ipv6{}
	return s.Ipv6
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Interface_RoutedVlan. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan) GetIpv4() *Interface_RoutedVlan_Ipv4 {
	if s != nil && s.Ipv4 != nil {
		return s.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Interface_RoutedVlan. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan) GetIpv6() *Interface_RoutedVlan_Ipv6 {
	if s != nil && s.Ipv6 != nil {
		return s.Ipv6
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAddress creates a new entry in the Address list of the
// Interface_RoutedVlan_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4) NewAddress(Ip string) (*Interface_RoutedVlan_Ipv4_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv4_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_RoutedVlan_Ipv4_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_RoutedVlan_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateAddress(Ip string) *Interface_RoutedVlan_Ipv4_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_RoutedVlan_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetAddress(Ip string) *Interface_RoutedVlan_Ipv4_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// AppendAddress appends the supplied Interface_RoutedVlan_Ipv4_Address struct to the
// list Address of Interface_RoutedVlan_Ipv4. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Address already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4) AppendAddress(v *Interface_RoutedVlan_Ipv4_Address) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_RoutedVlan_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4) NewNeighbor(Ip string) (*Interface_RoutedVlan_Ipv4_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv4_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_RoutedVlan_Ipv4_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_RoutedVlan_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateNeighbor(Ip string) *Interface_RoutedVlan_Ipv4_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_RoutedVlan_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetNeighbor(Ip string) *Interface_RoutedVlan_Ipv4_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied Interface_RoutedVlan_Ipv4_Neighbor struct to the
// list Neighbor of Interface_RoutedVlan_Ipv4. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4) AppendNeighbor(v *Interface_RoutedVlan_Ipv4_Neighbor) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv4_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan_Ipv4) GetOrCreateCounters() *Interface_RoutedVlan_Ipv4_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Interface_RoutedVlan_Ipv4_Counters{}
	return s.Counters
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan_Ipv4) GetOrCreateProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArp {
	if s.ProxyArp != nil {
		return s.ProxyArp
	}
	s.ProxyArp = &Interface_RoutedVlan_Ipv4_ProxyArp{}
	return s.ProxyArp
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan_Ipv4) GetOrCreateUnnumbered() *Interface_RoutedVlan_Ipv4_Unnumbered {
	if s.Unnumbered != nil {
		return s.Unnumbered
	}
	s.Unnumbered = &Interface_RoutedVlan_Ipv4_Unnumbered{}
	return s.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan_Ipv4) GetCounters() *Interface_RoutedVlan_Ipv4_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan_Ipv4) GetProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArp {
	if s != nil && s.ProxyArp != nil {
		return s.ProxyArp
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan_Ipv4) GetUnnumbered() *Interface_RoutedVlan_Ipv4_Unnumbered {
	if s != nil && s.Unnumbered != nil {
		return s.Unnumbered
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_RoutedVlan_Ipv4_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_RoutedVlan_Ipv4_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_RoutedVlan_Ipv4_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv4_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_RoutedVlan_Ipv4_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv4_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// AppendVrrpGroup appends the supplied Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_RoutedVlan_Ipv4_Address. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4_Address) AppendVrrpGroup(v *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) error {
	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Address struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if s.InterfaceTracking != nil {
		return s.InterfaceTracking
	}
	s.InterfaceTracking = &Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking{}
	return s.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_RoutedVlan_Ipv4_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetInterfaceTracking() *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if s != nil && s.InterfaceTracking != nil {
		return s.InterfaceTracking
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address_VrrpGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Neighbor struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv4_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv4_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_ProxyArp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan_Ipv4_Unnumbered) GetOrCreateInterfaceRef() *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_RoutedVlan_Ipv4_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan_Ipv4_Unnumbered) GetInterfaceRef() *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Unnumbered"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAddress creates a new entry in the Address list of the
// Interface_RoutedVlan_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6) NewAddress(Ip string) (*Interface_RoutedVlan_Ipv6_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv6_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_RoutedVlan_Ipv6_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_RoutedVlan_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateAddress(Ip string) *Interface_RoutedVlan_Ipv6_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_RoutedVlan_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetAddress(Ip string) *Interface_RoutedVlan_Ipv6_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// AppendAddress appends the supplied Interface_RoutedVlan_Ipv6_Address struct to the
// list Address of Interface_RoutedVlan_Ipv6. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Address already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6) AppendAddress(v *Interface_RoutedVlan_Ipv6_Address) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_RoutedVlan_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6) NewNeighbor(Ip string) (*Interface_RoutedVlan_Ipv6_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv6_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_RoutedVlan_Ipv6_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_RoutedVlan_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateNeighbor(Ip string) *Interface_RoutedVlan_Ipv6_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_RoutedVlan_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetNeighbor(Ip string) *Interface_RoutedVlan_Ipv6_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied Interface_RoutedVlan_Ipv6_Neighbor struct to the
// list Neighbor of Interface_RoutedVlan_Ipv6. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6) AppendNeighbor(v *Interface_RoutedVlan_Ipv6_Neighbor) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv6_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan_Ipv6) GetOrCreateCounters() *Interface_RoutedVlan_Ipv6_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Interface_RoutedVlan_Ipv6_Counters{}
	return s.Counters
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan_Ipv6) GetOrCreateRouterAdvertisement() *Interface_RoutedVlan_Ipv6_RouterAdvertisement {
	if s.RouterAdvertisement != nil {
		return s.RouterAdvertisement
	}
	s.RouterAdvertisement = &Interface_RoutedVlan_Ipv6_RouterAdvertisement{}
	return s.RouterAdvertisement
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan_Ipv6) GetOrCreateUnnumbered() *Interface_RoutedVlan_Ipv6_Unnumbered {
	if s.Unnumbered != nil {
		return s.Unnumbered
	}
	s.Unnumbered = &Interface_RoutedVlan_Ipv6_Unnumbered{}
	return s.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan_Ipv6) GetCounters() *Interface_RoutedVlan_Ipv6_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan_Ipv6) GetRouterAdvertisement() *Interface_RoutedVlan_Ipv6_RouterAdvertisement {
	if s != nil && s.RouterAdvertisement != nil {
		return s.RouterAdvertisement
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan_Ipv6) GetUnnumbered() *Interface_RoutedVlan_Ipv6_Unnumbered {
	if s != nil && s.Unnumbered != nil {
		return s.Unnumbered
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_RoutedVlan_Ipv6_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_RoutedVlan_Ipv6_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_RoutedVlan_Ipv6_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv6_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_RoutedVlan_Ipv6_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv6_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// AppendVrrpGroup appends the supplied Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_RoutedVlan_Ipv6_Address. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6_Address) AppendVrrpGroup(v *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) error {
	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Address struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if s.InterfaceTracking != nil {
		return s.InterfaceTracking
	}
	s.InterfaceTracking = &Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking{}
	return s.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_RoutedVlan_Ipv6_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetInterfaceTracking() *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if s != nil && s.InterfaceTracking != nil {
		return s.InterfaceTracking
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address_VrrpGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_RouterAdvertisement"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *Interface_RoutedVlan_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_RoutedVlan_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_RoutedVlan_Ipv6_Unnumbered) GetInterfaceRef() *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Unnumbered"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Sonet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Sonet"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Sonet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface) GetOrCreateCounters() *Interface_Subinterface_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Interface_Subinterface_Counters{}
	return s.Counters
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface) GetOrCreateIpv4() *Interface_Subinterface_Ipv4 {
	if s.Ipv4 != nil {
		return s.Ipv4
	}
	s.Ipv4 = &Interface_Subinterface_Ipv4{}
	return s.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface) GetOrCreateIpv6() *Interface_Subinterface_Ipv6 {
	if s.Ipv6 != nil {
		return s.Ipv6
	}
	s.Ipv6 = &Interface_Subinterface_Ipv6{}
	return s.Ipv6
}

// GetOrCreateVlan retrieves the value of the Vlan field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface) GetOrCreateVlan() *Interface_Subinterface_Vlan {
	if s.Vlan != nil {
		return s.Vlan
	}
	s.Vlan = &Interface_Subinterface_Vlan{}
	return s.Vlan
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface) GetCounters() *Interface_Subinterface_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Interface_Subinterface. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface) GetIpv4() *Interface_Subinterface_Ipv4 {
	if s != nil && s.Ipv4 != nil {
		return s.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Interface_Subinterface. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface) GetIpv6() *Interface_Subinterface_Ipv6 {
	if s != nil && s.Ipv6 != nil {
		return s.Ipv6
	}
	return nil
}

// GetVlan returns the value of the Vlan struct pointer
// from Interface_Subinterface. If the receiver or the field Vlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface) GetVlan() *Interface_Subinterface_Vlan {
	if s != nil && s.Vlan != nil {
		return s.Vlan
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface_Subinterface struct, which is a YANG list entry.
func (t *Interface_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAddress creates a new entry in the Address list of the
// Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4) NewAddress(Ip string) (*Interface_Subinterface_Ipv4_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv4_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Subinterface_Ipv4_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4) GetOrCreateAddress(Ip string) *Interface_Subinterface_Ipv4_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4) GetAddress(Ip string) *Interface_Subinterface_Ipv4_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// AppendAddress appends the supplied Interface_Subinterface_Ipv4_Address struct to the
// list Address of Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Address already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4) AppendAddress(v *Interface_Subinterface_Ipv4_Address) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4) NewNeighbor(Ip string) (*Interface_Subinterface_Ipv4_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv4_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Subinterface_Ipv4_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4) GetOrCreateNeighbor(Ip string) *Interface_Subinterface_Ipv4_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4) GetNeighbor(Ip string) *Interface_Subinterface_Ipv4_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied Interface_Subinterface_Ipv4_Neighbor struct to the
// list Neighbor of Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4) AppendNeighbor(v *Interface_Subinterface_Ipv4_Neighbor) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv4_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface_Ipv4) GetOrCreateCounters() *Interface_Subinterface_Ipv4_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Interface_Subinterface_Ipv4_Counters{}
	return s.Counters
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface_Ipv4) GetOrCreateProxyArp() *Interface_Subinterface_Ipv4_ProxyArp {
	if s.ProxyArp != nil {
		return s.ProxyArp
	}
	s.ProxyArp = &Interface_Subinterface_Ipv4_ProxyArp{}
	return s.ProxyArp
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface_Ipv4) GetOrCreateUnnumbered() *Interface_Subinterface_Ipv4_Unnumbered {
	if s.Unnumbered != nil {
		return s.Unnumbered
	}
	s.Unnumbered = &Interface_Subinterface_Ipv4_Unnumbered{}
	return s.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface_Ipv4) GetCounters() *Interface_Subinterface_Ipv4_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface_Ipv4) GetProxyArp() *Interface_Subinterface_Ipv4_ProxyArp {
	if s != nil && s.ProxyArp != nil {
		return s.ProxyArp
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface_Ipv4) GetUnnumbered() *Interface_Subinterface_Ipv4_Unnumbered {
	if s != nil && s.Unnumbered != nil {
		return s.Unnumbered
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_Subinterface_Ipv4_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_Subinterface_Ipv4_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_Subinterface_Ipv4_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_Subinterface_Ipv4_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv4_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_Subinterface_Ipv4_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv4_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// AppendVrrpGroup appends the supplied Interface_Subinterface_Ipv4_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_Subinterface_Ipv4_Address. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4_Address) AppendVrrpGroup(v *Interface_Subinterface_Ipv4_Address_VrrpGroup) error {
	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Address struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if s.InterfaceTracking != nil {
		return s.InterfaceTracking
	}
	s.InterfaceTracking = &Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking{}
	return s.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_Subinterface_Ipv4_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetInterfaceTracking() *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if s != nil && s.InterfaceTracking != nil {
		return s.InterfaceTracking
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv4_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address_VrrpGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Neighbor struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv4_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv4_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_ProxyArp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface_Ipv4_Unnumbered) GetOrCreateInterfaceRef() *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Subinterface_Ipv4_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface_Ipv4_Unnumbered) GetInterfaceRef() *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Unnumbered"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAddress creates a new entry in the Address list of the
// Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6) NewAddress(Ip string) (*Interface_Subinterface_Ipv6_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv6_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Subinterface_Ipv6_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6) GetOrCreateAddress(Ip string) *Interface_Subinterface_Ipv6_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6) GetAddress(Ip string) *Interface_Subinterface_Ipv6_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// AppendAddress appends the supplied Interface_Subinterface_Ipv6_Address struct to the
// list Address of Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Address already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6) AppendAddress(v *Interface_Subinterface_Ipv6_Address) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6) NewNeighbor(Ip string) (*Interface_Subinterface_Ipv6_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv6_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Subinterface_Ipv6_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6) GetOrCreateNeighbor(Ip string) *Interface_Subinterface_Ipv6_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6) GetNeighbor(Ip string) *Interface_Subinterface_Ipv6_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied Interface_Subinterface_Ipv6_Neighbor struct to the
// list Neighbor of Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6) AppendNeighbor(v *Interface_Subinterface_Ipv6_Neighbor) error {
	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv6_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateAutoconf retrieves the value of the Autoconf field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface_Ipv6) GetOrCreateAutoconf() *Interface_Subinterface_Ipv6_Autoconf {
	if s.Autoconf != nil {
		return s.Autoconf
	}
	s.Autoconf = &Interface_Subinterface_Ipv6_Autoconf{}
	return s.Autoconf
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface_Ipv6) GetOrCreateCounters() *Interface_Subinterface_Ipv6_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Interface_Subinterface_Ipv6_Counters{}
	return s.Counters
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface_Ipv6) GetOrCreateRouterAdvertisement() *Interface_Subinterface_Ipv6_RouterAdvertisement {
	if s.RouterAdvertisement != nil {
		return s.RouterAdvertisement
	}
	s.RouterAdvertisement = &Interface_Subinterface_Ipv6_RouterAdvertisement{}
	return s.RouterAdvertisement
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface_Ipv6) GetOrCreateUnnumbered() *Interface_Subinterface_Ipv6_Unnumbered {
	if s.Unnumbered != nil {
		return s.Unnumbered
	}
	s.Unnumbered = &Interface_Subinterface_Ipv6_Unnumbered{}
	return s.Unnumbered
}

// GetAutoconf returns the value of the Autoconf struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Autoconf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface_Ipv6) GetAutoconf() *Interface_Subinterface_Ipv6_Autoconf {
	if s != nil && s.Autoconf != nil {
		return s.Autoconf
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface_Ipv6) GetCounters() *Interface_Subinterface_Ipv6_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface_Ipv6) GetRouterAdvertisement() *Interface_Subinterface_Ipv6_RouterAdvertisement {
	if s != nil && s.RouterAdvertisement != nil {
		return s.RouterAdvertisement
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface_Ipv6) GetUnnumbered() *Interface_Subinterface_Ipv6_Unnumbered {
	if s != nil && s.Unnumbered != nil {
		return s.Unnumbered
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_Subinterface_Ipv6_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_Subinterface_Ipv6_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_Subinterface_Ipv6_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_Subinterface_Ipv6_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv6_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_Subinterface_Ipv6_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv6_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// AppendVrrpGroup appends the supplied Interface_Subinterface_Ipv6_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_Subinterface_Ipv6_Address. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6_Address) AppendVrrpGroup(v *Interface_Subinterface_Ipv6_Address_VrrpGroup) error {
	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Address struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if s.InterfaceTracking != nil {
		return s.InterfaceTracking
	}
	s.InterfaceTracking = &Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking{}
	return s.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_Subinterface_Ipv6_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if s != nil && s.InterfaceTracking != nil {
		return s.InterfaceTracking
	}
	return nil
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv6_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv6_Autoconf) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Autoconf"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Autoconf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_RouterAdvertisement"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *Interface_Subinterface_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Subinterface_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Interface_Subinterface_Ipv6_Unnumbered) GetInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Interface_Subinterface_Vlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// Lacp struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp) NewInterface(Name string) (*Lacp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lacp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lacp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lacp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp) GetOrCreateInterface(Name string) *Lacp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lacp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp) GetInterface(Name string) *Lacp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Lacp_Interface struct to the
// list Interface of Lacp. If the key value(s) specified in
// the supplied Lacp_Interface already exist in the list, an error is
// returned.
func (t *Lacp) AppendInterface(v *Lacp_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Lacp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewMember creates a new entry in the Member list of the
// Lacp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp_Interface) NewMember(Interface string) (*Lacp_Interface_Member, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Member[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Member", key)
	}

	t.Member[key] = &Lacp_Interface_Member{
		Interface: &Interface,
	}

	return t.Member[key], nil
}

// RenameMember renames an entry in the list Member within
// the Lacp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp_Interface) RenameMember(oldK, newK string) error {
	if _, ok := t.Member[newK]; ok {
		return fmt.Errorf("key %v already exists in Member", newK)
	}

	e, ok := t.Member[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Member", oldK)
	}
	e.Interface = &newK

	t.Member[newK] = e
	delete(t.Member, oldK)
	return nil
}

// GetOrCreateMember retrieves the value with the specified keys from
// the receiver Lacp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp_Interface) GetOrCreateMember(Interface string) *Lacp_Interface_Member {

	key := Interface

	if v, ok := t.Member[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMember(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMember got unexpected error: %v", err))
	}
	return v
}

// GetMember retrieves the value with the specified key from
// the Member map field of Lacp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp_Interface) GetMember(Interface string) *Lacp_Interface_Member {

	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.Member[key]; ok {
		return lm
	}
	return nil
}

// AppendMember appends the supplied Lacp_Interface_Member struct to the
// list Member of Lacp_Interface. If the key value(s) specified in
// the supplied Lacp_Interface_Member already exist in the list, an error is
// returned.
func (t *Lacp_Interface) AppendMember(v *Lacp_Interface_Member) error {
	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	if _, ok := t.Member[key]; ok {
		return fmt.Errorf("duplicate key for list Member %v", key)
	}

	t.Member[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Lacp_Interface struct, which is a YANG list entry.
func (t *Lacp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Lacp_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Lacp_Interface_Member) GetOrCreateCounters() *Lacp_Interface_Member_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Lacp_Interface_Member_Counters{}
	return s.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lacp_Interface_Member. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Lacp_Interface_Member) GetCounters() *Lacp_Interface_Member_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Lacp_Interface_Member struct, which is a YANG list entry.
func (t *Lacp_Interface_Member) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Lacp_Interface_Member) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Lacp_Interface_Member_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp) NewInterface(Name string) (*Lldp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lldp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp) GetOrCreateInterface(Name string) *Lldp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp) GetInterface(Name string) *Lldp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Lldp_Interface struct to the
// list Interface of Lldp. If the key value(s) specified in
// the supplied Lldp_Interface already exist in the list, an error is
// returned.
func (t *Lldp) AppendInterface(v *Lldp_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Lldp) GetOrCreateCounters() *Lldp_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Lldp_Counters{}
	return s.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Lldp) GetCounters() *Lldp_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Lldp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Lldp_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNeighbor creates a new entry in the Neighbor list of the
// Lldp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface) NewNeighbor(Id string) (*Lldp_Interface_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Lldp_Interface_Neighbor{
		Id: &Id,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Lldp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Id = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Lldp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface) GetOrCreateNeighbor(Id string) *Lldp_Interface_Neighbor {

	key := Id

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Lldp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface) GetNeighbor(Id string) *Lldp_Interface_Neighbor {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied Lldp_Interface_Neighbor struct to the
// list Neighbor of Lldp_Interface. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor already exist in the list, an error is
// returned.
func (t *Lldp_Interface) AppendNeighbor(v *Lldp_Interface_Neighbor) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Lldp_Interface) GetOrCreateCounters() *Lldp_Interface_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Lldp_Interface_Counters{}
	return s.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Lldp_Interface) GetCounters() *Lldp_Interface_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Lldp_Interface struct, which is a YANG list entry.
func (t *Lldp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Lldp_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Lldp_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewCapability creates a new entry in the Capability list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewCapability(Name E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY) (*Lldp_Interface_Neighbor_Capability, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Capability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Capability", key)
	}

	t.Capability[key] = &Lldp_Interface_Neighbor_Capability{
		Name: Name,
	}

	return t.Capability[key], nil
}

// RenameCapability renames an entry in the list Capability within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameCapability(oldK, newK E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY) error {
	if _, ok := t.Capability[newK]; ok {
		return fmt.Errorf("key %v already exists in Capability", newK)
	}

	e, ok := t.Capability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Capability", oldK)
	}
	e.Name = newK

	t.Capability[newK] = e
	delete(t.Capability, oldK)
	return nil
}

// GetOrCreateCapability retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateCapability(Name E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	key := Name

	if v, ok := t.Capability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCapability(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCapability got unexpected error: %v", err))
	}
	return v
}

// GetCapability retrieves the value with the specified key from
// the Capability map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetCapability(Name E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Capability[key]; ok {
		return lm
	}
	return nil
}

// AppendCapability appends the supplied Lldp_Interface_Neighbor_Capability struct to the
// list Capability of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Capability already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendCapability(v *Lldp_Interface_Neighbor_Capability) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_OpenconfigLldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	if _, ok := t.Capability[key]; ok {
		return fmt.Errorf("duplicate key for list Capability %v", key)
	}

	t.Capability[key] = v
	return nil
}

// NewTlv creates a new entry in the Tlv list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewTlv(Type int32, Oui string, OuiSubtype string) (*Lldp_Interface_Neighbor_Tlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tlv", key)
	}

	t.Tlv[key] = &Lldp_Interface_Neighbor_Tlv{
		Type:       &Type,
		Oui:        &Oui,
		OuiSubtype: &OuiSubtype,
	}

	return t.Tlv[key], nil
}

// RenameTlv renames an entry in the list Tlv within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameTlv(oldK, newK Lldp_Interface_Neighbor_Tlv_Key) error {
	if _, ok := t.Tlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Tlv", newK)
	}

	e, ok := t.Tlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tlv", oldK)
	}
	e.Type = &newK.Type
	e.Oui = &newK.Oui
	e.OuiSubtype = &newK.OuiSubtype

	t.Tlv[newK] = e
	delete(t.Tlv, oldK)
	return nil
}

// GetOrCreateTlv retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if v, ok := t.Tlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTlv(Type, Oui, OuiSubtype)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTlv got unexpected error: %v", err))
	}
	return v
}

// GetTlv retrieves the value with the specified key from
// the Tlv map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	if t == nil {
		return nil
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if lm, ok := t.Tlv[key]; ok {
		return lm
	}
	return nil
}

// AppendTlv appends the supplied Lldp_Interface_Neighbor_Tlv struct to the
// list Tlv of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Tlv already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendTlv(v *Lldp_Interface_Neighbor_Tlv) error {
	key := Lldp_Interface_Neighbor_Tlv_Key{Type: *v.Type, Oui: *v.Oui, OuiSubtype: *v.OuiSubtype}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	if _, ok := t.Tlv[key]; ok {
		return fmt.Errorf("duplicate key for list Tlv %v", key)
	}

	t.Tlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Lldp_Interface_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Capability struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Capability) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Lldp_Interface_Neighbor_Capability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Capability"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Capability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Tlv struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Tlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Oui == nil {
		return nil, fmt.Errorf("nil value for key Oui")
	}

	if t.OuiSubtype == nil {
		return nil, fmt.Errorf("nil value for key OuiSubtype")
	}

	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"oui":         *t.Oui,
		"oui-subtype": *t.OuiSubtype,
		"type":        *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Lldp_Interface_Neighbor_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Tlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Tlv) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAggregate creates a new entry in the Aggregate list of the
// LocalRoutes struct. The keys of the list are populated from the input
// arguments.
func (t *LocalRoutes) NewAggregate(Prefix string) (*LocalRoutes_Aggregate, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aggregate == nil {
		t.Aggregate = make(map[string]*LocalRoutes_Aggregate)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Aggregate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Aggregate", key)
	}

	t.Aggregate[key] = &LocalRoutes_Aggregate{
		Prefix: &Prefix,
	}

	return t.Aggregate[key], nil
}

// RenameAggregate renames an entry in the list Aggregate within
// the LocalRoutes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *LocalRoutes) RenameAggregate(oldK, newK string) error {
	if _, ok := t.Aggregate[newK]; ok {
		return fmt.Errorf("key %v already exists in Aggregate", newK)
	}

	e, ok := t.Aggregate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Aggregate", oldK)
	}
	e.Prefix = &newK

	t.Aggregate[newK] = e
	delete(t.Aggregate, oldK)
	return nil
}

// GetOrCreateAggregate retrieves the value with the specified keys from
// the receiver LocalRoutes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *LocalRoutes) GetOrCreateAggregate(Prefix string) *LocalRoutes_Aggregate {

	key := Prefix

	if v, ok := t.Aggregate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAggregate(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAggregate got unexpected error: %v", err))
	}
	return v
}

// GetAggregate retrieves the value with the specified key from
// the Aggregate map field of LocalRoutes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *LocalRoutes) GetAggregate(Prefix string) *LocalRoutes_Aggregate {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Aggregate[key]; ok {
		return lm
	}
	return nil
}

// AppendAggregate appends the supplied LocalRoutes_Aggregate struct to the
// list Aggregate of LocalRoutes. If the key value(s) specified in
// the supplied LocalRoutes_Aggregate already exist in the list, an error is
// returned.
func (t *LocalRoutes) AppendAggregate(v *LocalRoutes_Aggregate) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aggregate == nil {
		t.Aggregate = make(map[string]*LocalRoutes_Aggregate)
	}

	if _, ok := t.Aggregate[key]; ok {
		return fmt.Errorf("duplicate key for list Aggregate %v", key)
	}

	t.Aggregate[key] = v
	return nil
}

// NewStatic creates a new entry in the Static list of the
// LocalRoutes struct. The keys of the list are populated from the input
// arguments.
func (t *LocalRoutes) NewStatic(Prefix string) (*LocalRoutes_Static, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*LocalRoutes_Static)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Static[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Static", key)
	}

	t.Static[key] = &LocalRoutes_Static{
		Prefix: &Prefix,
	}

	return t.Static[key], nil
}

// RenameStatic renames an entry in the list Static within
// the LocalRoutes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *LocalRoutes) RenameStatic(oldK, newK string) error {
	if _, ok := t.Static[newK]; ok {
		return fmt.Errorf("key %v already exists in Static", newK)
	}

	e, ok := t.Static[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Static", oldK)
	}
	e.Prefix = &newK

	t.Static[newK] = e
	delete(t.Static, oldK)
	return nil
}

// GetOrCreateStatic retrieves the value with the specified keys from
// the receiver LocalRoutes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *LocalRoutes) GetOrCreateStatic(Prefix string) *LocalRoutes_Static {

	key := Prefix

	if v, ok := t.Static[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStatic(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStatic got unexpected error: %v", err))
	}
	return v
}

// GetStatic retrieves the value with the specified key from
// the Static map field of LocalRoutes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *LocalRoutes) GetStatic(Prefix string) *LocalRoutes_Static {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Static[key]; ok {
		return lm
	}
	return nil
}

// AppendStatic appends the supplied LocalRoutes_Static struct to the
// list Static of LocalRoutes. If the key value(s) specified in
// the supplied LocalRoutes_Static already exist in the list, an error is
// returned.
func (t *LocalRoutes) AppendStatic(v *LocalRoutes_Static) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*LocalRoutes_Static)
	}

	if _, ok := t.Static[key]; ok {
		return fmt.Errorf("duplicate key for list Static %v", key)
	}

	t.Static[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *LocalRoutes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["LocalRoutes"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *LocalRoutes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the LocalRoutes_Aggregate struct, which is a YANG list entry.
func (t *LocalRoutes_Aggregate) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *LocalRoutes_Aggregate) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["LocalRoutes_Aggregate"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *LocalRoutes_Aggregate) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNextHop creates a new entry in the NextHop list of the
// LocalRoutes_Static struct. The keys of the list are populated from the input
// arguments.
func (t *LocalRoutes_Static) NewNextHop(Index string) (*LocalRoutes_Static_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[string]*LocalRoutes_Static_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &LocalRoutes_Static_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the LocalRoutes_Static struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *LocalRoutes_Static) RenameNextHop(oldK, newK string) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver LocalRoutes_Static. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *LocalRoutes_Static) GetOrCreateNextHop(Index string) *LocalRoutes_Static_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of LocalRoutes_Static. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *LocalRoutes_Static) GetNextHop(Index string) *LocalRoutes_Static_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// AppendNextHop appends the supplied LocalRoutes_Static_NextHop struct to the
// list NextHop of LocalRoutes_Static. If the key value(s) specified in
// the supplied LocalRoutes_Static_NextHop already exist in the list, an error is
// returned.
func (t *LocalRoutes_Static) AppendNextHop(v *LocalRoutes_Static_NextHop) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[string]*LocalRoutes_Static_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the LocalRoutes_Static struct, which is a YANG list entry.
func (t *LocalRoutes_Static) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *LocalRoutes_Static) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["LocalRoutes_Static"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *LocalRoutes_Static) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *LocalRoutes_Static_NextHop) GetOrCreateInterfaceRef() *LocalRoutes_Static_NextHop_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &LocalRoutes_Static_NextHop_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from LocalRoutes_Static_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *LocalRoutes_Static_NextHop) GetInterfaceRef() *LocalRoutes_Static_NextHop_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the LocalRoutes_Static_NextHop struct, which is a YANG list entry.
func (t *LocalRoutes_Static_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *LocalRoutes_Static_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["LocalRoutes_Static_NextHop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *LocalRoutes_Static_NextHop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *LocalRoutes_Static_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["LocalRoutes_Static_NextHop_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *LocalRoutes_Static_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// Mpls struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls) NewInterface(InterfaceId string) (*Mpls_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Mpls_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Mpls_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Mpls struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Mpls. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls) GetOrCreateInterface(InterfaceId string) *Mpls_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Mpls. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls) GetInterface(InterfaceId string) *Mpls_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Mpls_Interface struct to the
// list Interface of Mpls. If the key value(s) specified in
// the supplied Mpls_Interface already exist in the list, an error is
// returned.
func (t *Mpls) AppendInterface(v *Mpls_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Mpls_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (s *Mpls) GetOrCreateGlobal() *Mpls_Global {
	if s.Global != nil {
		return s.Global
	}
	s.Global = &Mpls_Global{}
	return s.Global
}

// GetOrCreateLsps retrieves the value of the Lsps field
// or returns the existing field if it already exists.
func (s *Mpls) GetOrCreateLsps() *Mpls_Lsps {
	if s.Lsps != nil {
		return s.Lsps
	}
	s.Lsps = &Mpls_Lsps{}
	return s.Lsps
}

// GetOrCreateSignalingProtocols retrieves the value of the SignalingProtocols field
// or returns the existing field if it already exists.
func (s *Mpls) GetOrCreateSignalingProtocols() *Mpls_SignalingProtocols {
	if s.SignalingProtocols != nil {
		return s.SignalingProtocols
	}
	s.SignalingProtocols = &Mpls_SignalingProtocols{}
	return s.SignalingProtocols
}

// GetOrCreateTeGlobalAttributes retrieves the value of the TeGlobalAttributes field
// or returns the existing field if it already exists.
func (s *Mpls) GetOrCreateTeGlobalAttributes() *Mpls_TeGlobalAttributes {
	if s.TeGlobalAttributes != nil {
		return s.TeGlobalAttributes
	}
	s.TeGlobalAttributes = &Mpls_TeGlobalAttributes{}
	return s.TeGlobalAttributes
}

// GetGlobal returns the value of the Global struct pointer
// from Mpls. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls) GetGlobal() *Mpls_Global {
	if s != nil && s.Global != nil {
		return s.Global
	}
	return nil
}

// GetLsps returns the value of the Lsps struct pointer
// from Mpls. If the receiver or the field Lsps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls) GetLsps() *Mpls_Lsps {
	if s != nil && s.Lsps != nil {
		return s.Lsps
	}
	return nil
}

// GetSignalingProtocols returns the value of the SignalingProtocols struct pointer
// from Mpls. If the receiver or the field SignalingProtocols is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls) GetSignalingProtocols() *Mpls_SignalingProtocols {
	if s != nil && s.SignalingProtocols != nil {
		return s.SignalingProtocols
	}
	return nil
}

// GetTeGlobalAttributes returns the value of the TeGlobalAttributes struct pointer
// from Mpls. If the receiver or the field TeGlobalAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls) GetTeGlobalAttributes() *Mpls_TeGlobalAttributes {
	if s != nil && s.TeGlobalAttributes != nil {
		return s.TeGlobalAttributes
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_Global) NewInterface(InterfaceId string) (*Mpls_Global_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Mpls_Global_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Mpls_Global_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_Global) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_Global) GetOrCreateInterface(InterfaceId string) *Mpls_Global_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_Global) GetInterface(InterfaceId string) *Mpls_Global_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Mpls_Global_Interface struct to the
// list Interface of Mpls_Global. If the key value(s) specified in
// the supplied Mpls_Global_Interface already exist in the list, an error is
// returned.
func (t *Mpls_Global) AppendInterface(v *Mpls_Global_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Mpls_Global_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewReservedLabelBlock creates a new entry in the ReservedLabelBlock list of the
// Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_Global) NewReservedLabelBlock(LocalId string) (*Mpls_Global_ReservedLabelBlock, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*Mpls_Global_ReservedLabelBlock)
	}

	key := LocalId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ReservedLabelBlock[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ReservedLabelBlock", key)
	}

	t.ReservedLabelBlock[key] = &Mpls_Global_ReservedLabelBlock{
		LocalId: &LocalId,
	}

	return t.ReservedLabelBlock[key], nil
}

// RenameReservedLabelBlock renames an entry in the list ReservedLabelBlock within
// the Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_Global) RenameReservedLabelBlock(oldK, newK string) error {
	if _, ok := t.ReservedLabelBlock[newK]; ok {
		return fmt.Errorf("key %v already exists in ReservedLabelBlock", newK)
	}

	e, ok := t.ReservedLabelBlock[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ReservedLabelBlock", oldK)
	}
	e.LocalId = &newK

	t.ReservedLabelBlock[newK] = e
	delete(t.ReservedLabelBlock, oldK)
	return nil
}

// GetOrCreateReservedLabelBlock retrieves the value with the specified keys from
// the receiver Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_Global) GetOrCreateReservedLabelBlock(LocalId string) *Mpls_Global_ReservedLabelBlock {

	key := LocalId

	if v, ok := t.ReservedLabelBlock[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewReservedLabelBlock(LocalId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateReservedLabelBlock got unexpected error: %v", err))
	}
	return v
}

// GetReservedLabelBlock retrieves the value with the specified key from
// the ReservedLabelBlock map field of Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_Global) GetReservedLabelBlock(LocalId string) *Mpls_Global_ReservedLabelBlock {

	if t == nil {
		return nil
	}

	key := LocalId

	if lm, ok := t.ReservedLabelBlock[key]; ok {
		return lm
	}
	return nil
}

// AppendReservedLabelBlock appends the supplied Mpls_Global_ReservedLabelBlock struct to the
// list ReservedLabelBlock of Mpls_Global. If the key value(s) specified in
// the supplied Mpls_Global_ReservedLabelBlock already exist in the list, an error is
// returned.
func (t *Mpls_Global) AppendReservedLabelBlock(v *Mpls_Global_ReservedLabelBlock) error {
	key := *v.LocalId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*Mpls_Global_ReservedLabelBlock)
	}

	if _, ok := t.ReservedLabelBlock[key]; ok {
		return fmt.Errorf("duplicate key for list ReservedLabelBlock %v", key)
	}

	t.ReservedLabelBlock[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Global"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *Mpls_Global_Interface) GetOrCreateInterfaceRef() *Mpls_Global_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &Mpls_Global_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Mpls_Global_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Global_Interface) GetInterfaceRef() *Mpls_Global_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_Global_Interface struct, which is a YANG list entry.
func (t *Mpls_Global_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Global_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Global_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Global_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Global_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Global_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Global_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Mpls_Global_ReservedLabelBlock struct, which is a YANG list entry.
func (t *Mpls_Global_ReservedLabelBlock) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalId == nil {
		return nil, fmt.Errorf("nil value for key LocalId")
	}

	return map[string]interface{}{
		"local-id": *t.LocalId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Global_ReservedLabelBlock) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Global_ReservedLabelBlock"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Global_ReservedLabelBlock) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateIgpFloodingBandwidth retrieves the value of the IgpFloodingBandwidth field
// or returns the existing field if it already exists.
func (s *Mpls_Interface) GetOrCreateIgpFloodingBandwidth() *Mpls_Interface_IgpFloodingBandwidth {
	if s.IgpFloodingBandwidth != nil {
		return s.IgpFloodingBandwidth
	}
	s.IgpFloodingBandwidth = &Mpls_Interface_IgpFloodingBandwidth{}
	return s.IgpFloodingBandwidth
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *Mpls_Interface) GetOrCreateInterfaceRef() *Mpls_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &Mpls_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetIgpFloodingBandwidth returns the value of the IgpFloodingBandwidth struct pointer
// from Mpls_Interface. If the receiver or the field IgpFloodingBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Interface) GetIgpFloodingBandwidth() *Mpls_Interface_IgpFloodingBandwidth {
	if s != nil && s.IgpFloodingBandwidth != nil {
		return s.IgpFloodingBandwidth
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Mpls_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Interface) GetInterfaceRef() *Mpls_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_Interface struct, which is a YANG list entry.
func (t *Mpls_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Interface_IgpFloodingBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Interface_IgpFloodingBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Interface_IgpFloodingBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewStaticLsp creates a new entry in the StaticLsp list of the
// Mpls_Lsps struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_Lsps) NewStaticLsp(Name string) (*Mpls_Lsps_StaticLsp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*Mpls_Lsps_StaticLsp)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.StaticLsp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list StaticLsp", key)
	}

	t.StaticLsp[key] = &Mpls_Lsps_StaticLsp{
		Name: &Name,
	}

	return t.StaticLsp[key], nil
}

// RenameStaticLsp renames an entry in the list StaticLsp within
// the Mpls_Lsps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_Lsps) RenameStaticLsp(oldK, newK string) error {
	if _, ok := t.StaticLsp[newK]; ok {
		return fmt.Errorf("key %v already exists in StaticLsp", newK)
	}

	e, ok := t.StaticLsp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in StaticLsp", oldK)
	}
	e.Name = &newK

	t.StaticLsp[newK] = e
	delete(t.StaticLsp, oldK)
	return nil
}

// GetOrCreateStaticLsp retrieves the value with the specified keys from
// the receiver Mpls_Lsps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_Lsps) GetOrCreateStaticLsp(Name string) *Mpls_Lsps_StaticLsp {

	key := Name

	if v, ok := t.StaticLsp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStaticLsp(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStaticLsp got unexpected error: %v", err))
	}
	return v
}

// GetStaticLsp retrieves the value with the specified key from
// the StaticLsp map field of Mpls_Lsps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_Lsps) GetStaticLsp(Name string) *Mpls_Lsps_StaticLsp {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.StaticLsp[key]; ok {
		return lm
	}
	return nil
}

// AppendStaticLsp appends the supplied Mpls_Lsps_StaticLsp struct to the
// list StaticLsp of Mpls_Lsps. If the key value(s) specified in
// the supplied Mpls_Lsps_StaticLsp already exist in the list, an error is
// returned.
func (t *Mpls_Lsps) AppendStaticLsp(v *Mpls_Lsps_StaticLsp) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*Mpls_Lsps_StaticLsp)
	}

	if _, ok := t.StaticLsp[key]; ok {
		return fmt.Errorf("duplicate key for list StaticLsp %v", key)
	}

	t.StaticLsp[key] = v
	return nil
}

// GetOrCreateConstrainedPath retrieves the value of the ConstrainedPath field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps) GetOrCreateConstrainedPath() *Mpls_Lsps_ConstrainedPath {
	if s.ConstrainedPath != nil {
		return s.ConstrainedPath
	}
	s.ConstrainedPath = &Mpls_Lsps_ConstrainedPath{}
	return s.ConstrainedPath
}

// GetOrCreateUnconstrainedPath retrieves the value of the UnconstrainedPath field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps) GetOrCreateUnconstrainedPath() *Mpls_Lsps_UnconstrainedPath {
	if s.UnconstrainedPath != nil {
		return s.UnconstrainedPath
	}
	s.UnconstrainedPath = &Mpls_Lsps_UnconstrainedPath{}
	return s.UnconstrainedPath
}

// GetConstrainedPath returns the value of the ConstrainedPath struct pointer
// from Mpls_Lsps. If the receiver or the field ConstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps) GetConstrainedPath() *Mpls_Lsps_ConstrainedPath {
	if s != nil && s.ConstrainedPath != nil {
		return s.ConstrainedPath
	}
	return nil
}

// GetUnconstrainedPath returns the value of the UnconstrainedPath struct pointer
// from Mpls_Lsps. If the receiver or the field UnconstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps) GetUnconstrainedPath() *Mpls_Lsps_UnconstrainedPath {
	if s != nil && s.UnconstrainedPath != nil {
		return s.UnconstrainedPath
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNamedExplicitPath creates a new entry in the NamedExplicitPath list of the
// Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_Lsps_ConstrainedPath) NewNamedExplicitPath(Name string) (*Mpls_Lsps_ConstrainedPath_NamedExplicitPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NamedExplicitPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NamedExplicitPath", key)
	}

	t.NamedExplicitPath[key] = &Mpls_Lsps_ConstrainedPath_NamedExplicitPath{
		Name: &Name,
	}

	return t.NamedExplicitPath[key], nil
}

// RenameNamedExplicitPath renames an entry in the list NamedExplicitPath within
// the Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_Lsps_ConstrainedPath) RenameNamedExplicitPath(oldK, newK string) error {
	if _, ok := t.NamedExplicitPath[newK]; ok {
		return fmt.Errorf("key %v already exists in NamedExplicitPath", newK)
	}

	e, ok := t.NamedExplicitPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NamedExplicitPath", oldK)
	}
	e.Name = &newK

	t.NamedExplicitPath[newK] = e
	delete(t.NamedExplicitPath, oldK)
	return nil
}

// GetOrCreateNamedExplicitPath retrieves the value with the specified keys from
// the receiver Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_Lsps_ConstrainedPath) GetOrCreateNamedExplicitPath(Name string) *Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	key := Name

	if v, ok := t.NamedExplicitPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNamedExplicitPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNamedExplicitPath got unexpected error: %v", err))
	}
	return v
}

// GetNamedExplicitPath retrieves the value with the specified key from
// the NamedExplicitPath map field of Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_Lsps_ConstrainedPath) GetNamedExplicitPath(Name string) *Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NamedExplicitPath[key]; ok {
		return lm
	}
	return nil
}

// AppendNamedExplicitPath appends the supplied Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct to the
// list NamedExplicitPath of Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied Mpls_Lsps_ConstrainedPath_NamedExplicitPath already exist in the list, an error is
// returned.
func (t *Mpls_Lsps_ConstrainedPath) AppendNamedExplicitPath(v *Mpls_Lsps_ConstrainedPath_NamedExplicitPath) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	if _, ok := t.NamedExplicitPath[key]; ok {
		return fmt.Errorf("duplicate key for list NamedExplicitPath %v", key)
	}

	t.NamedExplicitPath[key] = v
	return nil
}

// NewTunnel creates a new entry in the Tunnel list of the
// Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_Lsps_ConstrainedPath) NewTunnel(Name string) (*Mpls_Lsps_ConstrainedPath_Tunnel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tunnel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tunnel", key)
	}

	t.Tunnel[key] = &Mpls_Lsps_ConstrainedPath_Tunnel{
		Name: &Name,
	}

	return t.Tunnel[key], nil
}

// RenameTunnel renames an entry in the list Tunnel within
// the Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_Lsps_ConstrainedPath) RenameTunnel(oldK, newK string) error {
	if _, ok := t.Tunnel[newK]; ok {
		return fmt.Errorf("key %v already exists in Tunnel", newK)
	}

	e, ok := t.Tunnel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tunnel", oldK)
	}
	e.Name = &newK

	t.Tunnel[newK] = e
	delete(t.Tunnel, oldK)
	return nil
}

// GetOrCreateTunnel retrieves the value with the specified keys from
// the receiver Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_Lsps_ConstrainedPath) GetOrCreateTunnel(Name string) *Mpls_Lsps_ConstrainedPath_Tunnel {

	key := Name

	if v, ok := t.Tunnel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTunnel(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTunnel got unexpected error: %v", err))
	}
	return v
}

// GetTunnel retrieves the value with the specified key from
// the Tunnel map field of Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_Lsps_ConstrainedPath) GetTunnel(Name string) *Mpls_Lsps_ConstrainedPath_Tunnel {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Tunnel[key]; ok {
		return lm
	}
	return nil
}

// AppendTunnel appends the supplied Mpls_Lsps_ConstrainedPath_Tunnel struct to the
// list Tunnel of Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied Mpls_Lsps_ConstrainedPath_Tunnel already exist in the list, an error is
// returned.
func (t *Mpls_Lsps_ConstrainedPath) AppendTunnel(v *Mpls_Lsps_ConstrainedPath_Tunnel) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	if _, ok := t.Tunnel[key]; ok {
		return fmt.Errorf("duplicate key for list Tunnel %v", key)
	}

	t.Tunnel[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewExplicitRouteObject creates a new entry in the ExplicitRouteObject list of the
// Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_Lsps_ConstrainedPath_NamedExplicitPath) NewExplicitRouteObject(Index uint8) (*Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExplicitRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExplicitRouteObject", key)
	}

	t.ExplicitRouteObject[key] = &Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{
		Index: &Index,
	}

	return t.ExplicitRouteObject[key], nil
}

// RenameExplicitRouteObject renames an entry in the list ExplicitRouteObject within
// the Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_Lsps_ConstrainedPath_NamedExplicitPath) RenameExplicitRouteObject(oldK, newK uint8) error {
	if _, ok := t.ExplicitRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in ExplicitRouteObject", newK)
	}

	e, ok := t.ExplicitRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExplicitRouteObject", oldK)
	}
	e.Index = &newK

	t.ExplicitRouteObject[newK] = e
	delete(t.ExplicitRouteObject, oldK)
	return nil
}

// GetOrCreateExplicitRouteObject retrieves the value with the specified keys from
// the receiver Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetOrCreateExplicitRouteObject(Index uint8) *Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	key := Index

	if v, ok := t.ExplicitRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExplicitRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExplicitRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetExplicitRouteObject retrieves the value with the specified key from
// the ExplicitRouteObject map field of Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetExplicitRouteObject(Index uint8) *Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.ExplicitRouteObject[key]; ok {
		return lm
	}
	return nil
}

// AppendExplicitRouteObject appends the supplied Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct to the
// list ExplicitRouteObject of Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the key value(s) specified in
// the supplied Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject already exist in the list, an error is
// returned.
func (t *Mpls_Lsps_ConstrainedPath_NamedExplicitPath) AppendExplicitRouteObject(v *Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	if _, ok := t.ExplicitRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list ExplicitRouteObject %v", key)
	}

	t.ExplicitRouteObject[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct, which is a YANG list entry.
func (t *Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_NamedExplicitPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_NamedExplicitPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct, which is a YANG list entry.
func (t *Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateBandwidth retrieves the value of the Bandwidth field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateBandwidth() *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if s.Bandwidth != nil {
		return s.Bandwidth
	}
	s.Bandwidth = &Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
	return s.Bandwidth
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateCounters() *Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	return s.Counters
}

// GetOrCreateP2PTunnelAttributes retrieves the value of the P2PTunnelAttributes field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateP2PTunnelAttributes() *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if s.P2PTunnelAttributes != nil {
		return s.P2PTunnelAttributes
	}
	s.P2PTunnelAttributes = &Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	return s.P2PTunnelAttributes
}

// GetBandwidth returns the value of the Bandwidth struct pointer
// from Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Bandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel) GetBandwidth() *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if s != nil && s.Bandwidth != nil {
		return s.Bandwidth
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel) GetCounters() *Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetP2PTunnelAttributes returns the value of the P2PTunnelAttributes struct pointer
// from Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field P2PTunnelAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel) GetP2PTunnelAttributes() *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if s != nil && s.P2PTunnelAttributes != nil {
		return s.P2PTunnelAttributes
	}
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_Lsps_ConstrainedPath_Tunnel struct, which is a YANG list entry.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAutoBandwidth retrieves the value of the AutoBandwidth field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetOrCreateAutoBandwidth() *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if s.AutoBandwidth != nil {
		return s.AutoBandwidth
	}
	s.AutoBandwidth = &Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	return s.AutoBandwidth
}

// GetAutoBandwidth returns the value of the AutoBandwidth struct pointer
// from Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth. If the receiver or the field AutoBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetAutoBandwidth() *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if s != nil && s.AutoBandwidth != nil {
		return s.AutoBandwidth
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOverflow retrieves the value of the Overflow field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateOverflow() *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if s.Overflow != nil {
		return s.Overflow
	}
	s.Overflow = &Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
	return s.Overflow
}

// GetOrCreateUnderflow retrieves the value of the Underflow field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateUnderflow() *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if s.Underflow != nil {
		return s.Underflow
	}
	s.Underflow = &Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
	return s.Underflow
}

// GetOverflow returns the value of the Overflow struct pointer
// from Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Overflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOverflow() *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if s != nil && s.Overflow != nil {
		return s.Overflow
	}
	return nil
}

// GetUnderflow returns the value of the Underflow struct pointer
// from Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Underflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetUnderflow() *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if s != nil && s.Underflow != nil {
		return s.Underflow
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewP2PPrimaryPath creates a new entry in the P2PPrimaryPath list of the
// Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) NewP2PPrimaryPath(Name string) (*Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PPrimaryPath == nil {
		t.P2PPrimaryPath = make(map[string]*Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.P2PPrimaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list P2PPrimaryPath", key)
	}

	t.P2PPrimaryPath[key] = &Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
		Name: &Name,
	}

	return t.P2PPrimaryPath[key], nil
}

// RenameP2PPrimaryPath renames an entry in the list P2PPrimaryPath within
// the Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) RenameP2PPrimaryPath(oldK, newK string) error {
	if _, ok := t.P2PPrimaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in P2PPrimaryPath", newK)
	}

	e, ok := t.P2PPrimaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in P2PPrimaryPath", oldK)
	}
	e.Name = &newK

	t.P2PPrimaryPath[newK] = e
	delete(t.P2PPrimaryPath, oldK)
	return nil
}

// GetOrCreateP2PPrimaryPath retrieves the value with the specified keys from
// the receiver Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PPrimaryPath(Name string) *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {

	key := Name

	if v, ok := t.P2PPrimaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewP2PPrimaryPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateP2PPrimaryPath got unexpected error: %v", err))
	}
	return v
}

// GetP2PPrimaryPath retrieves the value with the specified key from
// the P2PPrimaryPath map field of Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetP2PPrimaryPath(Name string) *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.P2PPrimaryPath[key]; ok {
		return lm
	}
	return nil
}

// AppendP2PPrimaryPath appends the supplied Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct to the
// list P2PPrimaryPath of Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the key value(s) specified in
// the supplied Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath already exist in the list, an error is
// returned.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) AppendP2PPrimaryPath(v *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PPrimaryPath == nil {
		t.P2PPrimaryPath = make(map[string]*Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
	}

	if _, ok := t.P2PPrimaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list P2PPrimaryPath %v", key)
	}

	t.P2PPrimaryPath[key] = v
	return nil
}

// NewP2PSecondaryPath creates a new entry in the P2PSecondaryPath list of the
// Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) NewP2PSecondaryPath(Name string) (*Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PSecondaryPath == nil {
		t.P2PSecondaryPath = make(map[string]*Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.P2PSecondaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list P2PSecondaryPath", key)
	}

	t.P2PSecondaryPath[key] = &Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
		Name: &Name,
	}

	return t.P2PSecondaryPath[key], nil
}

// RenameP2PSecondaryPath renames an entry in the list P2PSecondaryPath within
// the Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) RenameP2PSecondaryPath(oldK, newK string) error {
	if _, ok := t.P2PSecondaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in P2PSecondaryPath", newK)
	}

	e, ok := t.P2PSecondaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in P2PSecondaryPath", oldK)
	}
	e.Name = &newK

	t.P2PSecondaryPath[newK] = e
	delete(t.P2PSecondaryPath, oldK)
	return nil
}

// GetOrCreateP2PSecondaryPath retrieves the value with the specified keys from
// the receiver Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PSecondaryPath(Name string) *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {

	key := Name

	if v, ok := t.P2PSecondaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewP2PSecondaryPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateP2PSecondaryPath got unexpected error: %v", err))
	}
	return v
}

// GetP2PSecondaryPath retrieves the value with the specified key from
// the P2PSecondaryPath map field of Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetP2PSecondaryPath(Name string) *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.P2PSecondaryPath[key]; ok {
		return lm
	}
	return nil
}

// AppendP2PSecondaryPath appends the supplied Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct to the
// list P2PSecondaryPath of Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the key value(s) specified in
// the supplied Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath already exist in the list, an error is
// returned.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) AppendP2PSecondaryPath(v *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PSecondaryPath == nil {
		t.P2PSecondaryPath = make(map[string]*Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
	}

	if _, ok := t.P2PSecondaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list P2PSecondaryPath %v", key)
	}

	t.P2PSecondaryPath[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewCandidateSecondaryPath creates a new entry in the CandidateSecondaryPath list of the
// Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) NewCandidateSecondaryPath(SecondaryPath string) (*Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CandidateSecondaryPath == nil {
		t.CandidateSecondaryPath = make(map[string]*Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
	}

	key := SecondaryPath

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CandidateSecondaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CandidateSecondaryPath", key)
	}

	t.CandidateSecondaryPath[key] = &Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
		SecondaryPath: &SecondaryPath,
	}

	return t.CandidateSecondaryPath[key], nil
}

// RenameCandidateSecondaryPath renames an entry in the list CandidateSecondaryPath within
// the Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) RenameCandidateSecondaryPath(oldK, newK string) error {
	if _, ok := t.CandidateSecondaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in CandidateSecondaryPath", newK)
	}

	e, ok := t.CandidateSecondaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in CandidateSecondaryPath", oldK)
	}
	e.SecondaryPath = &newK

	t.CandidateSecondaryPath[newK] = e
	delete(t.CandidateSecondaryPath, oldK)
	return nil
}

// GetOrCreateCandidateSecondaryPath retrieves the value with the specified keys from
// the receiver Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreateCandidateSecondaryPath(SecondaryPath string) *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {

	key := SecondaryPath

	if v, ok := t.CandidateSecondaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCandidateSecondaryPath(SecondaryPath)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCandidateSecondaryPath got unexpected error: %v", err))
	}
	return v
}

// GetCandidateSecondaryPath retrieves the value with the specified key from
// the CandidateSecondaryPath map field of Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetCandidateSecondaryPath(SecondaryPath string) *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {

	if t == nil {
		return nil
	}

	key := SecondaryPath

	if lm, ok := t.CandidateSecondaryPath[key]; ok {
		return lm
	}
	return nil
}

// AppendCandidateSecondaryPath appends the supplied Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct to the
// list CandidateSecondaryPath of Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the key value(s) specified in
// the supplied Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath already exist in the list, an error is
// returned.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) AppendCandidateSecondaryPath(v *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) error {
	key := *v.SecondaryPath

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CandidateSecondaryPath == nil {
		t.CandidateSecondaryPath = make(map[string]*Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
	}

	if _, ok := t.CandidateSecondaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list CandidateSecondaryPath %v", key)
	}

	t.CandidateSecondaryPath[key] = v
	return nil
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreateAdminGroups() *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	if s.AdminGroups != nil {
		return s.AdminGroups
	}
	s.AdminGroups = &Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	return s.AdminGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetAdminGroups() *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	if s != nil && s.AdminGroups != nil {
		return s.AdminGroups
	}
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct, which is a YANG list entry.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct, which is a YANG list entry.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SecondaryPath == nil {
		return nil, fmt.Errorf("nil value for key SecondaryPath")
	}

	return map[string]interface{}{
		"secondary-path": *t.SecondaryPath,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetOrCreateAdminGroups() *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if s.AdminGroups != nil {
		return s.AdminGroups
	}
	s.AdminGroups = &Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	return s.AdminGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetAdminGroups() *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if s != nil && s.AdminGroups != nil {
		return s.AdminGroups
	}
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct, which is a YANG list entry.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEgress retrieves the value of the Egress field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_StaticLsp) GetOrCreateEgress() *Mpls_Lsps_StaticLsp_Egress {
	if s.Egress != nil {
		return s.Egress
	}
	s.Egress = &Mpls_Lsps_StaticLsp_Egress{}
	return s.Egress
}

// GetOrCreateIngress retrieves the value of the Ingress field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_StaticLsp) GetOrCreateIngress() *Mpls_Lsps_StaticLsp_Ingress {
	if s.Ingress != nil {
		return s.Ingress
	}
	s.Ingress = &Mpls_Lsps_StaticLsp_Ingress{}
	return s.Ingress
}

// GetOrCreateTransit retrieves the value of the Transit field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_StaticLsp) GetOrCreateTransit() *Mpls_Lsps_StaticLsp_Transit {
	if s.Transit != nil {
		return s.Transit
	}
	s.Transit = &Mpls_Lsps_StaticLsp_Transit{}
	return s.Transit
}

// GetEgress returns the value of the Egress struct pointer
// from Mpls_Lsps_StaticLsp. If the receiver or the field Egress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_StaticLsp) GetEgress() *Mpls_Lsps_StaticLsp_Egress {
	if s != nil && s.Egress != nil {
		return s.Egress
	}
	return nil
}

// GetIngress returns the value of the Ingress struct pointer
// from Mpls_Lsps_StaticLsp. If the receiver or the field Ingress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_StaticLsp) GetIngress() *Mpls_Lsps_StaticLsp_Ingress {
	if s != nil && s.Ingress != nil {
		return s.Ingress
	}
	return nil
}

// GetTransit returns the value of the Transit struct pointer
// from Mpls_Lsps_StaticLsp. If the receiver or the field Transit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_StaticLsp) GetTransit() *Mpls_Lsps_StaticLsp_Transit {
	if s != nil && s.Transit != nil {
		return s.Transit
	}
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_Lsps_StaticLsp struct, which is a YANG list entry.
func (t *Mpls_Lsps_StaticLsp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_StaticLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_StaticLsp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_StaticLsp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_StaticLsp_Egress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_StaticLsp_Egress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_StaticLsp_Egress) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_StaticLsp_Ingress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_StaticLsp_Ingress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_StaticLsp_Ingress) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_StaticLsp_Transit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_StaticLsp_Transit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_StaticLsp_Transit) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreatePathSetupProtocol retrieves the value of the PathSetupProtocol field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_UnconstrainedPath) GetOrCreatePathSetupProtocol() *Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if s.PathSetupProtocol != nil {
		return s.PathSetupProtocol
	}
	s.PathSetupProtocol = &Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	return s.PathSetupProtocol
}

// GetPathSetupProtocol returns the value of the PathSetupProtocol struct pointer
// from Mpls_Lsps_UnconstrainedPath. If the receiver or the field PathSetupProtocol is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_UnconstrainedPath) GetPathSetupProtocol() *Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if s != nil && s.PathSetupProtocol != nil {
		return s.PathSetupProtocol
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_UnconstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_UnconstrainedPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_UnconstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (s *Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetOrCreateLdp() *Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if s.Ldp != nil {
		return s.Ldp
	}
	s.Ldp = &Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	return s.Ldp
}

// GetLdp returns the value of the Ldp struct pointer
// from Mpls_Lsps_UnconstrainedPath_PathSetupProtocol. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetLdp() *Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if s != nil && s.Ldp != nil {
		return s.Ldp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_UnconstrainedPath_PathSetupProtocol"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols) GetOrCreateLdp() *Mpls_SignalingProtocols_Ldp {
	if s.Ldp != nil {
		return s.Ldp
	}
	s.Ldp = &Mpls_SignalingProtocols_Ldp{}
	return s.Ldp
}

// GetOrCreateRsvpTe retrieves the value of the RsvpTe field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols) GetOrCreateRsvpTe() *Mpls_SignalingProtocols_RsvpTe {
	if s.RsvpTe != nil {
		return s.RsvpTe
	}
	s.RsvpTe = &Mpls_SignalingProtocols_RsvpTe{}
	return s.RsvpTe
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols) GetOrCreateSegmentRouting() *Mpls_SignalingProtocols_SegmentRouting {
	if s.SegmentRouting != nil {
		return s.SegmentRouting
	}
	s.SegmentRouting = &Mpls_SignalingProtocols_SegmentRouting{}
	return s.SegmentRouting
}

// GetLdp returns the value of the Ldp struct pointer
// from Mpls_SignalingProtocols. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols) GetLdp() *Mpls_SignalingProtocols_Ldp {
	if s != nil && s.Ldp != nil {
		return s.Ldp
	}
	return nil
}

// GetRsvpTe returns the value of the RsvpTe struct pointer
// from Mpls_SignalingProtocols. If the receiver or the field RsvpTe is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols) GetRsvpTe() *Mpls_SignalingProtocols_RsvpTe {
	if s != nil && s.RsvpTe != nil {
		return s.RsvpTe
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from Mpls_SignalingProtocols. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols) GetSegmentRouting() *Mpls_SignalingProtocols_SegmentRouting {
	if s != nil && s.SegmentRouting != nil {
		return s.SegmentRouting
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_Ldp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_Ldp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_Ldp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_SignalingProtocols_RsvpTe) NewInterface(InterfaceId string) (*Mpls_SignalingProtocols_RsvpTe_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Mpls_SignalingProtocols_RsvpTe_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Mpls_SignalingProtocols_RsvpTe_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_SignalingProtocols_RsvpTe) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_SignalingProtocols_RsvpTe) GetOrCreateInterface(InterfaceId string) *Mpls_SignalingProtocols_RsvpTe_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_SignalingProtocols_RsvpTe) GetInterface(InterfaceId string) *Mpls_SignalingProtocols_RsvpTe_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Mpls_SignalingProtocols_RsvpTe_Interface struct to the
// list Interface of Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied Mpls_SignalingProtocols_RsvpTe_Interface already exist in the list, an error is
// returned.
func (t *Mpls_SignalingProtocols_RsvpTe) AppendInterface(v *Mpls_SignalingProtocols_RsvpTe_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Mpls_SignalingProtocols_RsvpTe_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_SignalingProtocols_RsvpTe) NewNeighbor(Address string) (*Mpls_SignalingProtocols_RsvpTe_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Mpls_SignalingProtocols_RsvpTe_Neighbor)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Mpls_SignalingProtocols_RsvpTe_Neighbor{
		Address: &Address,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_SignalingProtocols_RsvpTe) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Address = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_SignalingProtocols_RsvpTe) GetOrCreateNeighbor(Address string) *Mpls_SignalingProtocols_RsvpTe_Neighbor {

	key := Address

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_SignalingProtocols_RsvpTe) GetNeighbor(Address string) *Mpls_SignalingProtocols_RsvpTe_Neighbor {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied Mpls_SignalingProtocols_RsvpTe_Neighbor struct to the
// list Neighbor of Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied Mpls_SignalingProtocols_RsvpTe_Neighbor already exist in the list, an error is
// returned.
func (t *Mpls_SignalingProtocols_RsvpTe) AppendNeighbor(v *Mpls_SignalingProtocols_RsvpTe_Neighbor) error {
	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Mpls_SignalingProtocols_RsvpTe_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// NewSession creates a new entry in the Session list of the
// Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_SignalingProtocols_RsvpTe) NewSession(LocalIndex uint64) (*Mpls_SignalingProtocols_RsvpTe_Session, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[uint64]*Mpls_SignalingProtocols_RsvpTe_Session)
	}

	key := LocalIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Session[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Session", key)
	}

	t.Session[key] = &Mpls_SignalingProtocols_RsvpTe_Session{
		LocalIndex: &LocalIndex,
	}

	return t.Session[key], nil
}

// RenameSession renames an entry in the list Session within
// the Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_SignalingProtocols_RsvpTe) RenameSession(oldK, newK uint64) error {
	if _, ok := t.Session[newK]; ok {
		return fmt.Errorf("key %v already exists in Session", newK)
	}

	e, ok := t.Session[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Session", oldK)
	}
	e.LocalIndex = &newK

	t.Session[newK] = e
	delete(t.Session, oldK)
	return nil
}

// GetOrCreateSession retrieves the value with the specified keys from
// the receiver Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_SignalingProtocols_RsvpTe) GetOrCreateSession(LocalIndex uint64) *Mpls_SignalingProtocols_RsvpTe_Session {

	key := LocalIndex

	if v, ok := t.Session[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSession(LocalIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSession got unexpected error: %v", err))
	}
	return v
}

// GetSession retrieves the value with the specified key from
// the Session map field of Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_SignalingProtocols_RsvpTe) GetSession(LocalIndex uint64) *Mpls_SignalingProtocols_RsvpTe_Session {

	if t == nil {
		return nil
	}

	key := LocalIndex

	if lm, ok := t.Session[key]; ok {
		return lm
	}
	return nil
}

// AppendSession appends the supplied Mpls_SignalingProtocols_RsvpTe_Session struct to the
// list Session of Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied Mpls_SignalingProtocols_RsvpTe_Session already exist in the list, an error is
// returned.
func (t *Mpls_SignalingProtocols_RsvpTe) AppendSession(v *Mpls_SignalingProtocols_RsvpTe_Session) error {
	key := *v.LocalIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[uint64]*Mpls_SignalingProtocols_RsvpTe_Session)
	}

	if _, ok := t.Session[key]; ok {
		return fmt.Errorf("duplicate key for list Session %v", key)
	}

	t.Session[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe) GetOrCreateGlobal() *Mpls_SignalingProtocols_RsvpTe_Global {
	if s.Global != nil {
		return s.Global
	}
	s.Global = &Mpls_SignalingProtocols_RsvpTe_Global{}
	return s.Global
}

// GetGlobal returns the value of the Global struct pointer
// from Mpls_SignalingProtocols_RsvpTe. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe) GetGlobal() *Mpls_SignalingProtocols_RsvpTe_Global {
	if s != nil && s.Global != nil {
		return s.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateCounters() *Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	return s.Counters
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateGracefulRestart() *Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateHellos retrieves the value of the Hellos field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateHellos() *Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	if s.Hellos != nil {
		return s.Hellos
	}
	s.Hellos = &Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	return s.Hellos
}

// GetOrCreateSoftPreemption retrieves the value of the SoftPreemption field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateSoftPreemption() *Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	if s.SoftPreemption != nil {
		return s.SoftPreemption
	}
	s.SoftPreemption = &Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	return s.SoftPreemption
}

// GetCounters returns the value of the Counters struct pointer
// from Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe_Global) GetCounters() *Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe_Global) GetGracefulRestart() *Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetHellos returns the value of the Hellos struct pointer
// from Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field Hellos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe_Global) GetHellos() *Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	if s != nil && s.Hellos != nil {
		return s.Hellos
	}
	return nil
}

// GetSoftPreemption returns the value of the SoftPreemption struct pointer
// from Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field SoftPreemption is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe_Global) GetSoftPreemption() *Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	if s != nil && s.SoftPreemption != nil {
		return s.SoftPreemption
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Global"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Global_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Global_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Global_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Global_Hellos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Global_Hellos"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Global_Hellos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewBandwidthReservation creates a new entry in the BandwidthReservation list of the
// Mpls_SignalingProtocols_RsvpTe_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface) NewBandwidthReservation(Priority Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) (*Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthReservation == nil {
		t.BandwidthReservation = make(map[Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union]*Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthReservation[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthReservation", key)
	}

	t.BandwidthReservation[key] = &Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
		Priority: Priority,
	}

	return t.BandwidthReservation[key], nil
}

// RenameBandwidthReservation renames an entry in the list BandwidthReservation within
// the Mpls_SignalingProtocols_RsvpTe_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface) RenameBandwidthReservation(oldK, newK Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) error {
	if _, ok := t.BandwidthReservation[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthReservation", newK)
	}

	e, ok := t.BandwidthReservation[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthReservation", oldK)
	}
	e.Priority = newK

	t.BandwidthReservation[newK] = e
	delete(t.BandwidthReservation, oldK)
	return nil
}

// GetOrCreateBandwidthReservation retrieves the value with the specified keys from
// the receiver Mpls_SignalingProtocols_RsvpTe_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateBandwidthReservation(Priority Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) *Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {

	key := Priority

	if v, ok := t.BandwidthReservation[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthReservation(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthReservation got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthReservation retrieves the value with the specified key from
// the BandwidthReservation map field of Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface) GetBandwidthReservation(Priority Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) *Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.BandwidthReservation[key]; ok {
		return lm
	}
	return nil
}

// AppendBandwidthReservation appends the supplied Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation struct to the
// list BandwidthReservation of Mpls_SignalingProtocols_RsvpTe_Interface. If the key value(s) specified in
// the supplied Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation already exist in the list, an error is
// returned.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface) AppendBandwidthReservation(v *Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) error {
	key := v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthReservation == nil {
		t.BandwidthReservation = make(map[Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union]*Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)
	}

	if _, ok := t.BandwidthReservation[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthReservation %v", key)
	}

	t.BandwidthReservation[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateAuthentication() *Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	if s.Authentication != nil {
		return s.Authentication
	}
	s.Authentication = &Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	return s.Authentication
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateCounters() *Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	return s.Counters
}

// GetOrCreateHellos retrieves the value of the Hellos field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateHellos() *Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	if s.Hellos != nil {
		return s.Hellos
	}
	s.Hellos = &Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	return s.Hellos
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateInterfaceRef() *Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetOrCreateProtection retrieves the value of the Protection field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateProtection() *Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	if s.Protection != nil {
		return s.Protection
	}
	s.Protection = &Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	return s.Protection
}

// GetOrCreateSubscription retrieves the value of the Subscription field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateSubscription() *Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	if s.Subscription != nil {
		return s.Subscription
	}
	s.Subscription = &Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	return s.Subscription
}

// GetAuthentication returns the value of the Authentication struct pointer
// from Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetAuthentication() *Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	if s != nil && s.Authentication != nil {
		return s.Authentication
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetCounters() *Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetHellos returns the value of the Hellos struct pointer
// from Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Hellos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetHellos() *Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	if s != nil && s.Hellos != nil {
		return s.Hellos
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetInterfaceRef() *Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// GetProtection returns the value of the Protection struct pointer
// from Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Protection is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetProtection() *Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	if s != nil && s.Protection != nil {
		return s.Protection
	}
	return nil
}

// GetSubscription returns the value of the Subscription struct pointer
// from Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Subscription is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) GetSubscription() *Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	if s != nil && s.Subscription != nil {
		return s.Subscription
	}
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_SignalingProtocols_RsvpTe_Interface struct, which is a YANG list entry.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Interface_Authentication"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation struct, which is a YANG list entry.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"priority": t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Interface_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Interface_Hellos"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface_Protection) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Interface_Protection"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface_Protection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Interface_Subscription"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Mpls_SignalingProtocols_RsvpTe_Neighbor struct, which is a YANG list entry.
func (t *Mpls_SignalingProtocols_RsvpTe_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewRecordRouteObject creates a new entry in the RecordRouteObject list of the
// Mpls_SignalingProtocols_RsvpTe_Session struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_SignalingProtocols_RsvpTe_Session) NewRecordRouteObject(Index uint8) (*Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RecordRouteObject == nil {
		t.RecordRouteObject = make(map[uint8]*Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RecordRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RecordRouteObject", key)
	}

	t.RecordRouteObject[key] = &Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
		Index: &Index,
	}

	return t.RecordRouteObject[key], nil
}

// RenameRecordRouteObject renames an entry in the list RecordRouteObject within
// the Mpls_SignalingProtocols_RsvpTe_Session struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_SignalingProtocols_RsvpTe_Session) RenameRecordRouteObject(oldK, newK uint8) error {
	if _, ok := t.RecordRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in RecordRouteObject", newK)
	}

	e, ok := t.RecordRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RecordRouteObject", oldK)
	}
	e.Index = &newK

	t.RecordRouteObject[newK] = e
	delete(t.RecordRouteObject, oldK)
	return nil
}

// GetOrCreateRecordRouteObject retrieves the value with the specified keys from
// the receiver Mpls_SignalingProtocols_RsvpTe_Session. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_SignalingProtocols_RsvpTe_Session) GetOrCreateRecordRouteObject(Index uint8) *Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {

	key := Index

	if v, ok := t.RecordRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRecordRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRecordRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetRecordRouteObject retrieves the value with the specified key from
// the RecordRouteObject map field of Mpls_SignalingProtocols_RsvpTe_Session. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_SignalingProtocols_RsvpTe_Session) GetRecordRouteObject(Index uint8) *Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.RecordRouteObject[key]; ok {
		return lm
	}
	return nil
}

// AppendRecordRouteObject appends the supplied Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject struct to the
// list RecordRouteObject of Mpls_SignalingProtocols_RsvpTe_Session. If the key value(s) specified in
// the supplied Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject already exist in the list, an error is
// returned.
func (t *Mpls_SignalingProtocols_RsvpTe_Session) AppendRecordRouteObject(v *Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RecordRouteObject == nil {
		t.RecordRouteObject = make(map[uint8]*Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)
	}

	if _, ok := t.RecordRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list RecordRouteObject %v", key)
	}

	t.RecordRouteObject[key] = v
	return nil
}

// GetOrCreateSenderTspec retrieves the value of the SenderTspec field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_RsvpTe_Session) GetOrCreateSenderTspec() *Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	if s.SenderTspec != nil {
		return s.SenderTspec
	}
	s.SenderTspec = &Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	return s.SenderTspec
}

// GetSenderTspec returns the value of the SenderTspec struct pointer
// from Mpls_SignalingProtocols_RsvpTe_Session. If the receiver or the field SenderTspec is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_RsvpTe_Session) GetSenderTspec() *Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	if s != nil && s.SenderTspec != nil {
		return s.SenderTspec
	}
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_SignalingProtocols_RsvpTe_Session struct, which is a YANG list entry.
func (t *Mpls_SignalingProtocols_RsvpTe_Session) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalIndex == nil {
		return nil, fmt.Errorf("nil value for key LocalIndex")
	}

	return map[string]interface{}{
		"local-index": *t.LocalIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Session) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Session"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Session) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject struct, which is a YANG list entry.
func (t *Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAggregateSidCounter creates a new entry in the AggregateSidCounter list of the
// Mpls_SignalingProtocols_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_SignalingProtocols_SegmentRouting) NewAggregateSidCounter(MplsLabel Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) (*Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AggregateSidCounter == nil {
		t.AggregateSidCounter = make(map[Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union]*Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)
	}

	key := MplsLabel

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AggregateSidCounter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AggregateSidCounter", key)
	}

	t.AggregateSidCounter[key] = &Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
		MplsLabel: MplsLabel,
	}

	return t.AggregateSidCounter[key], nil
}

// RenameAggregateSidCounter renames an entry in the list AggregateSidCounter within
// the Mpls_SignalingProtocols_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_SignalingProtocols_SegmentRouting) RenameAggregateSidCounter(oldK, newK Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) error {
	if _, ok := t.AggregateSidCounter[newK]; ok {
		return fmt.Errorf("key %v already exists in AggregateSidCounter", newK)
	}

	e, ok := t.AggregateSidCounter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AggregateSidCounter", oldK)
	}
	e.MplsLabel = newK

	t.AggregateSidCounter[newK] = e
	delete(t.AggregateSidCounter, oldK)
	return nil
}

// GetOrCreateAggregateSidCounter retrieves the value with the specified keys from
// the receiver Mpls_SignalingProtocols_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_SignalingProtocols_SegmentRouting) GetOrCreateAggregateSidCounter(MplsLabel Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) *Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {

	key := MplsLabel

	if v, ok := t.AggregateSidCounter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAggregateSidCounter(MplsLabel)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAggregateSidCounter got unexpected error: %v", err))
	}
	return v
}

// GetAggregateSidCounter retrieves the value with the specified key from
// the AggregateSidCounter map field of Mpls_SignalingProtocols_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_SignalingProtocols_SegmentRouting) GetAggregateSidCounter(MplsLabel Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) *Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {

	if t == nil {
		return nil
	}

	key := MplsLabel

	if lm, ok := t.AggregateSidCounter[key]; ok {
		return lm
	}
	return nil
}

// AppendAggregateSidCounter appends the supplied Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter struct to the
// list AggregateSidCounter of Mpls_SignalingProtocols_SegmentRouting. If the key value(s) specified in
// the supplied Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter already exist in the list, an error is
// returned.
func (t *Mpls_SignalingProtocols_SegmentRouting) AppendAggregateSidCounter(v *Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) error {
	key := v.MplsLabel

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AggregateSidCounter == nil {
		t.AggregateSidCounter = make(map[Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union]*Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)
	}

	if _, ok := t.AggregateSidCounter[key]; ok {
		return fmt.Errorf("duplicate key for list AggregateSidCounter %v", key)
	}

	t.AggregateSidCounter[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// Mpls_SignalingProtocols_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_SignalingProtocols_SegmentRouting) NewInterface(InterfaceId string) (*Mpls_SignalingProtocols_SegmentRouting_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Mpls_SignalingProtocols_SegmentRouting_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Mpls_SignalingProtocols_SegmentRouting_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Mpls_SignalingProtocols_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_SignalingProtocols_SegmentRouting) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Mpls_SignalingProtocols_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_SignalingProtocols_SegmentRouting) GetOrCreateInterface(InterfaceId string) *Mpls_SignalingProtocols_SegmentRouting_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Mpls_SignalingProtocols_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_SignalingProtocols_SegmentRouting) GetInterface(InterfaceId string) *Mpls_SignalingProtocols_SegmentRouting_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Mpls_SignalingProtocols_SegmentRouting_Interface struct to the
// list Interface of Mpls_SignalingProtocols_SegmentRouting. If the key value(s) specified in
// the supplied Mpls_SignalingProtocols_SegmentRouting_Interface already exist in the list, an error is
// returned.
func (t *Mpls_SignalingProtocols_SegmentRouting) AppendInterface(v *Mpls_SignalingProtocols_SegmentRouting_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Mpls_SignalingProtocols_SegmentRouting_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_SegmentRouting"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter struct, which is a YANG list entry.
func (t *Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"mpls-label": t.MplsLabel,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSidCounter creates a new entry in the SidCounter list of the
// Mpls_SignalingProtocols_SegmentRouting_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface) NewSidCounter(MplsLabel Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) (*Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SidCounter == nil {
		t.SidCounter = make(map[Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union]*Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)
	}

	key := MplsLabel

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SidCounter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SidCounter", key)
	}

	t.SidCounter[key] = &Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
		MplsLabel: MplsLabel,
	}

	return t.SidCounter[key], nil
}

// RenameSidCounter renames an entry in the list SidCounter within
// the Mpls_SignalingProtocols_SegmentRouting_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface) RenameSidCounter(oldK, newK Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) error {
	if _, ok := t.SidCounter[newK]; ok {
		return fmt.Errorf("key %v already exists in SidCounter", newK)
	}

	e, ok := t.SidCounter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SidCounter", oldK)
	}
	e.MplsLabel = newK

	t.SidCounter[newK] = e
	delete(t.SidCounter, oldK)
	return nil
}

// GetOrCreateSidCounter retrieves the value with the specified keys from
// the receiver Mpls_SignalingProtocols_SegmentRouting_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface) GetOrCreateSidCounter(MplsLabel Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {

	key := MplsLabel

	if v, ok := t.SidCounter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSidCounter(MplsLabel)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSidCounter got unexpected error: %v", err))
	}
	return v
}

// GetSidCounter retrieves the value with the specified key from
// the SidCounter map field of Mpls_SignalingProtocols_SegmentRouting_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface) GetSidCounter(MplsLabel Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {

	if t == nil {
		return nil
	}

	key := MplsLabel

	if lm, ok := t.SidCounter[key]; ok {
		return lm
	}
	return nil
}

// AppendSidCounter appends the supplied Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct to the
// list SidCounter of Mpls_SignalingProtocols_SegmentRouting_Interface. If the key value(s) specified in
// the supplied Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter already exist in the list, an error is
// returned.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface) AppendSidCounter(v *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) error {
	key := v.MplsLabel

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SidCounter == nil {
		t.SidCounter = make(map[Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union]*Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)
	}

	if _, ok := t.SidCounter[key]; ok {
		return fmt.Errorf("duplicate key for list SidCounter %v", key)
	}

	t.SidCounter[key] = v
	return nil
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *Mpls_SignalingProtocols_SegmentRouting_Interface) GetOrCreateInterfaceRef() *Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Mpls_SignalingProtocols_SegmentRouting_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_SignalingProtocols_SegmentRouting_Interface) GetInterfaceRef() *Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_SignalingProtocols_SegmentRouting_Interface struct, which is a YANG list entry.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_SegmentRouting_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_SegmentRouting_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewForwardingClass creates a new entry in the ForwardingClass list of the
// Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) NewForwardingClass(Exp uint8) (*Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[uint8]*Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)
	}

	key := Exp

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingClass", key)
	}

	t.ForwardingClass[key] = &Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
		Exp: &Exp,
	}

	return t.ForwardingClass[key], nil
}

// RenameForwardingClass renames an entry in the list ForwardingClass within
// the Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) RenameForwardingClass(oldK, newK uint8) error {
	if _, ok := t.ForwardingClass[newK]; ok {
		return fmt.Errorf("key %v already exists in ForwardingClass", newK)
	}

	e, ok := t.ForwardingClass[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ForwardingClass", oldK)
	}
	e.Exp = &newK

	t.ForwardingClass[newK] = e
	delete(t.ForwardingClass, oldK)
	return nil
}

// GetOrCreateForwardingClass retrieves the value with the specified keys from
// the receiver Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetOrCreateForwardingClass(Exp uint8) *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {

	key := Exp

	if v, ok := t.ForwardingClass[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewForwardingClass(Exp)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateForwardingClass got unexpected error: %v", err))
	}
	return v
}

// GetForwardingClass retrieves the value with the specified key from
// the ForwardingClass map field of Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetForwardingClass(Exp uint8) *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {

	if t == nil {
		return nil
	}

	key := Exp

	if lm, ok := t.ForwardingClass[key]; ok {
		return lm
	}
	return nil
}

// AppendForwardingClass appends the supplied Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass struct to the
// list ForwardingClass of Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the key value(s) specified in
// the supplied Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass already exist in the list, an error is
// returned.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) AppendForwardingClass(v *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) error {
	key := *v.Exp

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[uint8]*Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)
	}

	if _, ok := t.ForwardingClass[key]; ok {
		return fmt.Errorf("duplicate key for list ForwardingClass %v", key)
	}

	t.ForwardingClass[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct, which is a YANG list entry.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"mpls-label": t.MplsLabel,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass struct, which is a YANG list entry.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Exp == nil {
		return nil, fmt.Errorf("nil value for key Exp")
	}

	return map[string]interface{}{
		"exp": *t.Exp,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdminGroup creates a new entry in the AdminGroup list of the
// Mpls_TeGlobalAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_TeGlobalAttributes) NewAdminGroup(AdminGroupName string) (*Mpls_TeGlobalAttributes_AdminGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[string]*Mpls_TeGlobalAttributes_AdminGroup)
	}

	key := AdminGroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdminGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdminGroup", key)
	}

	t.AdminGroup[key] = &Mpls_TeGlobalAttributes_AdminGroup{
		AdminGroupName: &AdminGroupName,
	}

	return t.AdminGroup[key], nil
}

// RenameAdminGroup renames an entry in the list AdminGroup within
// the Mpls_TeGlobalAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_TeGlobalAttributes) RenameAdminGroup(oldK, newK string) error {
	if _, ok := t.AdminGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in AdminGroup", newK)
	}

	e, ok := t.AdminGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdminGroup", oldK)
	}
	e.AdminGroupName = &newK

	t.AdminGroup[newK] = e
	delete(t.AdminGroup, oldK)
	return nil
}

// GetOrCreateAdminGroup retrieves the value with the specified keys from
// the receiver Mpls_TeGlobalAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_TeGlobalAttributes) GetOrCreateAdminGroup(AdminGroupName string) *Mpls_TeGlobalAttributes_AdminGroup {

	key := AdminGroupName

	if v, ok := t.AdminGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdminGroup(AdminGroupName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdminGroup got unexpected error: %v", err))
	}
	return v
}

// GetAdminGroup retrieves the value with the specified key from
// the AdminGroup map field of Mpls_TeGlobalAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_TeGlobalAttributes) GetAdminGroup(AdminGroupName string) *Mpls_TeGlobalAttributes_AdminGroup {

	if t == nil {
		return nil
	}

	key := AdminGroupName

	if lm, ok := t.AdminGroup[key]; ok {
		return lm
	}
	return nil
}

// AppendAdminGroup appends the supplied Mpls_TeGlobalAttributes_AdminGroup struct to the
// list AdminGroup of Mpls_TeGlobalAttributes. If the key value(s) specified in
// the supplied Mpls_TeGlobalAttributes_AdminGroup already exist in the list, an error is
// returned.
func (t *Mpls_TeGlobalAttributes) AppendAdminGroup(v *Mpls_TeGlobalAttributes_AdminGroup) error {
	key := *v.AdminGroupName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[string]*Mpls_TeGlobalAttributes_AdminGroup)
	}

	if _, ok := t.AdminGroup[key]; ok {
		return fmt.Errorf("duplicate key for list AdminGroup %v", key)
	}

	t.AdminGroup[key] = v
	return nil
}

// NewSrlg creates a new entry in the Srlg list of the
// Mpls_TeGlobalAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_TeGlobalAttributes) NewSrlg(Name string) (*Mpls_TeGlobalAttributes_Srlg, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlg == nil {
		t.Srlg = make(map[string]*Mpls_TeGlobalAttributes_Srlg)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Srlg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Srlg", key)
	}

	t.Srlg[key] = &Mpls_TeGlobalAttributes_Srlg{
		Name: &Name,
	}

	return t.Srlg[key], nil
}

// RenameSrlg renames an entry in the list Srlg within
// the Mpls_TeGlobalAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_TeGlobalAttributes) RenameSrlg(oldK, newK string) error {
	if _, ok := t.Srlg[newK]; ok {
		return fmt.Errorf("key %v already exists in Srlg", newK)
	}

	e, ok := t.Srlg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Srlg", oldK)
	}
	e.Name = &newK

	t.Srlg[newK] = e
	delete(t.Srlg, oldK)
	return nil
}

// GetOrCreateSrlg retrieves the value with the specified keys from
// the receiver Mpls_TeGlobalAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_TeGlobalAttributes) GetOrCreateSrlg(Name string) *Mpls_TeGlobalAttributes_Srlg {

	key := Name

	if v, ok := t.Srlg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrlg(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrlg got unexpected error: %v", err))
	}
	return v
}

// GetSrlg retrieves the value with the specified key from
// the Srlg map field of Mpls_TeGlobalAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_TeGlobalAttributes) GetSrlg(Name string) *Mpls_TeGlobalAttributes_Srlg {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Srlg[key]; ok {
		return lm
	}
	return nil
}

// AppendSrlg appends the supplied Mpls_TeGlobalAttributes_Srlg struct to the
// list Srlg of Mpls_TeGlobalAttributes. If the key value(s) specified in
// the supplied Mpls_TeGlobalAttributes_Srlg already exist in the list, an error is
// returned.
func (t *Mpls_TeGlobalAttributes) AppendSrlg(v *Mpls_TeGlobalAttributes_Srlg) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlg == nil {
		t.Srlg = make(map[string]*Mpls_TeGlobalAttributes_Srlg)
	}

	if _, ok := t.Srlg[key]; ok {
		return fmt.Errorf("duplicate key for list Srlg %v", key)
	}

	t.Srlg[key] = v
	return nil
}

// GetOrCreateTeLspTimers retrieves the value of the TeLspTimers field
// or returns the existing field if it already exists.
func (s *Mpls_TeGlobalAttributes) GetOrCreateTeLspTimers() *Mpls_TeGlobalAttributes_TeLspTimers {
	if s.TeLspTimers != nil {
		return s.TeLspTimers
	}
	s.TeLspTimers = &Mpls_TeGlobalAttributes_TeLspTimers{}
	return s.TeLspTimers
}

// GetTeLspTimers returns the value of the TeLspTimers struct pointer
// from Mpls_TeGlobalAttributes. If the receiver or the field TeLspTimers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Mpls_TeGlobalAttributes) GetTeLspTimers() *Mpls_TeGlobalAttributes_TeLspTimers {
	if s != nil && s.TeLspTimers != nil {
		return s.TeLspTimers
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_TeGlobalAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_TeGlobalAttributes"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_TeGlobalAttributes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Mpls_TeGlobalAttributes_AdminGroup struct, which is a YANG list entry.
func (t *Mpls_TeGlobalAttributes_AdminGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.AdminGroupName == nil {
		return nil, fmt.Errorf("nil value for key AdminGroupName")
	}

	return map[string]interface{}{
		"admin-group-name": *t.AdminGroupName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_TeGlobalAttributes_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_TeGlobalAttributes_AdminGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_TeGlobalAttributes_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewMembersList creates a new entry in the MembersList list of the
// Mpls_TeGlobalAttributes_Srlg struct. The keys of the list are populated from the input
// arguments.
func (t *Mpls_TeGlobalAttributes_Srlg) NewMembersList(FromAddress string) (*Mpls_TeGlobalAttributes_Srlg_MembersList, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MembersList == nil {
		t.MembersList = make(map[string]*Mpls_TeGlobalAttributes_Srlg_MembersList)
	}

	key := FromAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MembersList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MembersList", key)
	}

	t.MembersList[key] = &Mpls_TeGlobalAttributes_Srlg_MembersList{
		FromAddress: &FromAddress,
	}

	return t.MembersList[key], nil
}

// RenameMembersList renames an entry in the list MembersList within
// the Mpls_TeGlobalAttributes_Srlg struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Mpls_TeGlobalAttributes_Srlg) RenameMembersList(oldK, newK string) error {
	if _, ok := t.MembersList[newK]; ok {
		return fmt.Errorf("key %v already exists in MembersList", newK)
	}

	e, ok := t.MembersList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MembersList", oldK)
	}
	e.FromAddress = &newK

	t.MembersList[newK] = e
	delete(t.MembersList, oldK)
	return nil
}

// GetOrCreateMembersList retrieves the value with the specified keys from
// the receiver Mpls_TeGlobalAttributes_Srlg. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Mpls_TeGlobalAttributes_Srlg) GetOrCreateMembersList(FromAddress string) *Mpls_TeGlobalAttributes_Srlg_MembersList {

	key := FromAddress

	if v, ok := t.MembersList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMembersList(FromAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMembersList got unexpected error: %v", err))
	}
	return v
}

// GetMembersList retrieves the value with the specified key from
// the MembersList map field of Mpls_TeGlobalAttributes_Srlg. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Mpls_TeGlobalAttributes_Srlg) GetMembersList(FromAddress string) *Mpls_TeGlobalAttributes_Srlg_MembersList {

	if t == nil {
		return nil
	}

	key := FromAddress

	if lm, ok := t.MembersList[key]; ok {
		return lm
	}
	return nil
}

// AppendMembersList appends the supplied Mpls_TeGlobalAttributes_Srlg_MembersList struct to the
// list MembersList of Mpls_TeGlobalAttributes_Srlg. If the key value(s) specified in
// the supplied Mpls_TeGlobalAttributes_Srlg_MembersList already exist in the list, an error is
// returned.
func (t *Mpls_TeGlobalAttributes_Srlg) AppendMembersList(v *Mpls_TeGlobalAttributes_Srlg_MembersList) error {
	key := *v.FromAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MembersList == nil {
		t.MembersList = make(map[string]*Mpls_TeGlobalAttributes_Srlg_MembersList)
	}

	if _, ok := t.MembersList[key]; ok {
		return fmt.Errorf("duplicate key for list MembersList %v", key)
	}

	t.MembersList[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Mpls_TeGlobalAttributes_Srlg struct, which is a YANG list entry.
func (t *Mpls_TeGlobalAttributes_Srlg) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_TeGlobalAttributes_Srlg) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_TeGlobalAttributes_Srlg"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_TeGlobalAttributes_Srlg) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Mpls_TeGlobalAttributes_Srlg_MembersList struct, which is a YANG list entry.
func (t *Mpls_TeGlobalAttributes_Srlg_MembersList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FromAddress == nil {
		return nil, fmt.Errorf("nil value for key FromAddress")
	}

	return map[string]interface{}{
		"from-address": *t.FromAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_TeGlobalAttributes_Srlg_MembersList) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_TeGlobalAttributes_Srlg_MembersList"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_TeGlobalAttributes_Srlg_MembersList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Mpls_TeGlobalAttributes_TeLspTimers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Mpls_TeGlobalAttributes_TeLspTimers"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Mpls_TeGlobalAttributes_TeLspTimers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewConnectionPoint creates a new entry in the ConnectionPoint list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewConnectionPoint(ConnectionPointId string) (*NetworkInstance_ConnectionPoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	key := ConnectionPointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ConnectionPoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ConnectionPoint", key)
	}

	t.ConnectionPoint[key] = &NetworkInstance_ConnectionPoint{
		ConnectionPointId: &ConnectionPointId,
	}

	return t.ConnectionPoint[key], nil
}

// RenameConnectionPoint renames an entry in the list ConnectionPoint within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameConnectionPoint(oldK, newK string) error {
	if _, ok := t.ConnectionPoint[newK]; ok {
		return fmt.Errorf("key %v already exists in ConnectionPoint", newK)
	}

	e, ok := t.ConnectionPoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ConnectionPoint", oldK)
	}
	e.ConnectionPointId = &newK

	t.ConnectionPoint[newK] = e
	delete(t.ConnectionPoint, oldK)
	return nil
}

// GetOrCreateConnectionPoint retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	key := ConnectionPointId

	if v, ok := t.ConnectionPoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConnectionPoint(ConnectionPointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConnectionPoint got unexpected error: %v", err))
	}
	return v
}

// GetConnectionPoint retrieves the value with the specified key from
// the ConnectionPoint map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	if t == nil {
		return nil
	}

	key := ConnectionPointId

	if lm, ok := t.ConnectionPoint[key]; ok {
		return lm
	}
	return nil
}

// AppendConnectionPoint appends the supplied NetworkInstance_ConnectionPoint struct to the
// list ConnectionPoint of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendConnectionPoint(v *NetworkInstance_ConnectionPoint) error {
	key := *v.ConnectionPointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	if _, ok := t.ConnectionPoint[key]; ok {
		return fmt.Errorf("duplicate key for list ConnectionPoint %v", key)
	}

	t.ConnectionPoint[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewInterface(Id string) (*NetworkInstance_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Interface{
		Id: &Id,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Id = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateInterface(Id string) *NetworkInstance_Interface {

	key := Id

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetInterface(Id string) *NetworkInstance_Interface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied NetworkInstance_Interface struct to the
// list Interface of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendInterface(v *NetworkInstance_Interface) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewProtocol creates a new entry in the Protocol list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewProtocol(Identifier E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) (*NetworkInstance_Protocol, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Protocol[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Protocol", key)
	}

	t.Protocol[key] = &NetworkInstance_Protocol{
		Identifier: Identifier,
		Name:       &Name,
	}

	return t.Protocol[key], nil
}

// RenameProtocol renames an entry in the list Protocol within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameProtocol(oldK, newK NetworkInstance_Protocol_Key) error {
	if _, ok := t.Protocol[newK]; ok {
		return fmt.Errorf("key %v already exists in Protocol", newK)
	}

	e, ok := t.Protocol[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Protocol", oldK)
	}
	e.Identifier = newK.Identifier
	e.Name = &newK.Name

	t.Protocol[newK] = e
	delete(t.Protocol, oldK)
	return nil
}

// GetOrCreateProtocol retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateProtocol(Identifier E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if v, ok := t.Protocol[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProtocol(Identifier, Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProtocol got unexpected error: %v", err))
	}
	return v
}

// GetProtocol retrieves the value with the specified key from
// the Protocol map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetProtocol(Identifier E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if lm, ok := t.Protocol[key]; ok {
		return lm
	}
	return nil
}

// AppendProtocol appends the supplied NetworkInstance_Protocol struct to the
// list Protocol of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendProtocol(v *NetworkInstance_Protocol) error {
	key := NetworkInstance_Protocol_Key{Identifier: v.Identifier, Name: *v.Name}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	if _, ok := t.Protocol[key]; ok {
		return fmt.Errorf("duplicate key for list Protocol %v", key)
	}

	t.Protocol[key] = v
	return nil
}

// NewTable creates a new entry in the Table list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTable(Protocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) (*NetworkInstance_Table, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Table[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Table", key)
	}

	t.Table[key] = &NetworkInstance_Table{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	return t.Table[key], nil
}

// RenameTable renames an entry in the list Table within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTable(oldK, newK NetworkInstance_Table_Key) error {
	if _, ok := t.Table[newK]; ok {
		return fmt.Errorf("key %v already exists in Table", newK)
	}

	e, ok := t.Table[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Table", oldK)
	}
	e.Protocol = newK.Protocol
	e.AddressFamily = newK.AddressFamily

	t.Table[newK] = e
	delete(t.Table, oldK)
	return nil
}

// GetOrCreateTable retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTable(Protocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) *NetworkInstance_Table {

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.Table[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTable(Protocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTable got unexpected error: %v", err))
	}
	return v
}

// GetTable retrieves the value with the specified key from
// the Table map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTable(Protocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) *NetworkInstance_Table {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.Table[key]; ok {
		return lm
	}
	return nil
}

// AppendTable appends the supplied NetworkInstance_Table struct to the
// list Table of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Table already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTable(v *NetworkInstance_Table) error {
	key := NetworkInstance_Table_Key{Protocol: v.Protocol, AddressFamily: v.AddressFamily}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	if _, ok := t.Table[key]; ok {
		return fmt.Errorf("duplicate key for list Table %v", key)
	}

	t.Table[key] = v
	return nil
}

// NewTableConnection creates a new entry in the TableConnection list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTableConnection(SrcProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) (*NetworkInstance_TableConnection, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TableConnection[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TableConnection", key)
	}

	t.TableConnection[key] = &NetworkInstance_TableConnection{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	return t.TableConnection[key], nil
}

// RenameTableConnection renames an entry in the list TableConnection within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTableConnection(oldK, newK NetworkInstance_TableConnection_Key) error {
	if _, ok := t.TableConnection[newK]; ok {
		return fmt.Errorf("key %v already exists in TableConnection", newK)
	}

	e, ok := t.TableConnection[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TableConnection", oldK)
	}
	e.SrcProtocol = newK.SrcProtocol
	e.DstProtocol = newK.DstProtocol
	e.AddressFamily = newK.AddressFamily

	t.TableConnection[newK] = e
	delete(t.TableConnection, oldK)
	return nil
}

// GetOrCreateTableConnection retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTableConnection(SrcProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.TableConnection[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTableConnection(SrcProtocol, DstProtocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTableConnection got unexpected error: %v", err))
	}
	return v
}

// GetTableConnection retrieves the value with the specified key from
// the TableConnection map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTableConnection(SrcProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_OpenconfigTypes_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	if t == nil {
		return nil
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.TableConnection[key]; ok {
		return lm
	}
	return nil
}

// AppendTableConnection appends the supplied NetworkInstance_TableConnection struct to the
// list TableConnection of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_TableConnection already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTableConnection(v *NetworkInstance_TableConnection) error {
	key := NetworkInstance_TableConnection_Key{SrcProtocol: v.SrcProtocol, DstProtocol: v.DstProtocol, AddressFamily: v.AddressFamily}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	if _, ok := t.TableConnection[key]; ok {
		return fmt.Errorf("duplicate key for list TableConnection %v", key)
	}

	t.TableConnection[key] = v
	return nil
}

// NewVlan creates a new entry in the Vlan list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewVlan(VlanId uint16) (*NetworkInstance_Vlan, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	key := VlanId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vlan[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vlan", key)
	}

	t.Vlan[key] = &NetworkInstance_Vlan{
		VlanId: &VlanId,
	}

	return t.Vlan[key], nil
}

// RenameVlan renames an entry in the list Vlan within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameVlan(oldK, newK uint16) error {
	if _, ok := t.Vlan[newK]; ok {
		return fmt.Errorf("key %v already exists in Vlan", newK)
	}

	e, ok := t.Vlan[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vlan", oldK)
	}
	e.VlanId = &newK

	t.Vlan[newK] = e
	delete(t.Vlan, oldK)
	return nil
}

// GetOrCreateVlan retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateVlan(VlanId uint16) *NetworkInstance_Vlan {

	key := VlanId

	if v, ok := t.Vlan[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVlan(VlanId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVlan got unexpected error: %v", err))
	}
	return v
}

// GetVlan retrieves the value with the specified key from
// the Vlan map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetVlan(VlanId uint16) *NetworkInstance_Vlan {

	if t == nil {
		return nil
	}

	key := VlanId

	if lm, ok := t.Vlan[key]; ok {
		return lm
	}
	return nil
}

// AppendVlan appends the supplied NetworkInstance_Vlan struct to the
// list Vlan of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Vlan already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendVlan(v *NetworkInstance_Vlan) error {
	key := *v.VlanId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	if _, ok := t.Vlan[key]; ok {
		return fmt.Errorf("duplicate key for list Vlan %v", key)
	}

	t.Vlan[key] = v
	return nil
}

// GetOrCreateAfts retrieves the value of the Afts field
// or returns the existing field if it already exists.
func (s *NetworkInstance) GetOrCreateAfts() *NetworkInstance_Afts {
	if s.Afts != nil {
		return s.Afts
	}
	s.Afts = &NetworkInstance_Afts{}
	return s.Afts
}

// GetOrCreateEncapsulation retrieves the value of the Encapsulation field
// or returns the existing field if it already exists.
func (s *NetworkInstance) GetOrCreateEncapsulation() *NetworkInstance_Encapsulation {
	if s.Encapsulation != nil {
		return s.Encapsulation
	}
	s.Encapsulation = &NetworkInstance_Encapsulation{}
	return s.Encapsulation
}

// GetOrCreateFdb retrieves the value of the Fdb field
// or returns the existing field if it already exists.
func (s *NetworkInstance) GetOrCreateFdb() *NetworkInstance_Fdb {
	if s.Fdb != nil {
		return s.Fdb
	}
	s.Fdb = &NetworkInstance_Fdb{}
	return s.Fdb
}

// GetOrCreateInterInstancePolicies retrieves the value of the InterInstancePolicies field
// or returns the existing field if it already exists.
func (s *NetworkInstance) GetOrCreateInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if s.InterInstancePolicies != nil {
		return s.InterInstancePolicies
	}
	s.InterInstancePolicies = &NetworkInstance_InterInstancePolicies{}
	return s.InterInstancePolicies
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (s *NetworkInstance) GetOrCreateMpls() *NetworkInstance_Mpls {
	if s.Mpls != nil {
		return s.Mpls
	}
	s.Mpls = &NetworkInstance_Mpls{}
	return s.Mpls
}

// GetOrCreatePolicyForwarding retrieves the value of the PolicyForwarding field
// or returns the existing field if it already exists.
func (s *NetworkInstance) GetOrCreatePolicyForwarding() *NetworkInstance_PolicyForwarding {
	if s.PolicyForwarding != nil {
		return s.PolicyForwarding
	}
	s.PolicyForwarding = &NetworkInstance_PolicyForwarding{}
	return s.PolicyForwarding
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (s *NetworkInstance) GetOrCreateSegmentRouting() *NetworkInstance_SegmentRouting {
	if s.SegmentRouting != nil {
		return s.SegmentRouting
	}
	s.SegmentRouting = &NetworkInstance_SegmentRouting{}
	return s.SegmentRouting
}

// GetAfts returns the value of the Afts struct pointer
// from NetworkInstance. If the receiver or the field Afts is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance) GetAfts() *NetworkInstance_Afts {
	if s != nil && s.Afts != nil {
		return s.Afts
	}
	return nil
}

// GetEncapsulation returns the value of the Encapsulation struct pointer
// from NetworkInstance. If the receiver or the field Encapsulation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance) GetEncapsulation() *NetworkInstance_Encapsulation {
	if s != nil && s.Encapsulation != nil {
		return s.Encapsulation
	}
	return nil
}

// GetFdb returns the value of the Fdb struct pointer
// from NetworkInstance. If the receiver or the field Fdb is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance) GetFdb() *NetworkInstance_Fdb {
	if s != nil && s.Fdb != nil {
		return s.Fdb
	}
	return nil
}

// GetInterInstancePolicies returns the value of the InterInstancePolicies struct pointer
// from NetworkInstance. If the receiver or the field InterInstancePolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance) GetInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if s != nil && s.InterInstancePolicies != nil {
		return s.InterInstancePolicies
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance) GetMpls() *NetworkInstance_Mpls {
	if s != nil && s.Mpls != nil {
		return s.Mpls
	}
	return nil
}

// GetPolicyForwarding returns the value of the PolicyForwarding struct pointer
// from NetworkInstance. If the receiver or the field PolicyForwarding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance) GetPolicyForwarding() *NetworkInstance_PolicyForwarding {
	if s != nil && s.PolicyForwarding != nil {
		return s.PolicyForwarding
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance) GetSegmentRouting() *NetworkInstance_SegmentRouting {
	if s != nil && s.SegmentRouting != nil {
		return s.SegmentRouting
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance struct, which is a YANG list entry.
func (t *NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewIpv4Entry creates a new entry in the Ipv4Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv4Entry(Prefix string) (*NetworkInstance_Afts_Ipv4Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Entry", key)
	}

	t.Ipv4Entry[key] = &NetworkInstance_Afts_Ipv4Entry{
		Prefix: &Prefix,
	}

	return t.Ipv4Entry[key], nil
}

// RenameIpv4Entry renames an entry in the list Ipv4Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv4Entry(oldK, newK string) error {
	if _, ok := t.Ipv4Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Entry", newK)
	}

	e, ok := t.Ipv4Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv4Entry[newK] = e
	delete(t.Ipv4Entry, oldK)
	return nil
}

// GetOrCreateIpv4Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	key := Prefix

	if v, ok := t.Ipv4Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Entry retrieves the value with the specified key from
// the Ipv4Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv4Entry[key]; ok {
		return lm
	}
	return nil
}

// AppendIpv4Entry appends the supplied NetworkInstance_Afts_Ipv4Entry struct to the
// list Ipv4Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv4Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv4Entry(v *NetworkInstance_Afts_Ipv4Entry) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	if _, ok := t.Ipv4Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Entry %v", key)
	}

	t.Ipv4Entry[key] = v
	return nil
}

// NewIpv6Entry creates a new entry in the Ipv6Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv6Entry(Prefix string) (*NetworkInstance_Afts_Ipv6Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Entry", key)
	}

	t.Ipv6Entry[key] = &NetworkInstance_Afts_Ipv6Entry{
		Prefix: &Prefix,
	}

	return t.Ipv6Entry[key], nil
}

// RenameIpv6Entry renames an entry in the list Ipv6Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv6Entry(oldK, newK string) error {
	if _, ok := t.Ipv6Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Entry", newK)
	}

	e, ok := t.Ipv6Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv6Entry[newK] = e
	delete(t.Ipv6Entry, oldK)
	return nil
}

// GetOrCreateIpv6Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	key := Prefix

	if v, ok := t.Ipv6Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Entry retrieves the value with the specified key from
// the Ipv6Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv6Entry[key]; ok {
		return lm
	}
	return nil
}

// AppendIpv6Entry appends the supplied NetworkInstance_Afts_Ipv6Entry struct to the
// list Ipv6Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv6Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv6Entry(v *NetworkInstance_Afts_Ipv6Entry) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	if _, ok := t.Ipv6Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Entry %v", key)
	}

	t.Ipv6Entry[key] = v
	return nil
}

// NewLabelEntry creates a new entry in the LabelEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) (*NetworkInstance_Afts_LabelEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	key := Label

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LabelEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LabelEntry", key)
	}

	t.LabelEntry[key] = &NetworkInstance_Afts_LabelEntry{
		Label: Label,
	}

	return t.LabelEntry[key], nil
}

// RenameLabelEntry renames an entry in the list LabelEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameLabelEntry(oldK, newK NetworkInstance_Afts_LabelEntry_Label_Union) error {
	if _, ok := t.LabelEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in LabelEntry", newK)
	}

	e, ok := t.LabelEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LabelEntry", oldK)
	}
	e.Label = newK

	t.LabelEntry[newK] = e
	delete(t.LabelEntry, oldK)
	return nil
}

// GetOrCreateLabelEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	key := Label

	if v, ok := t.LabelEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLabelEntry(Label)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLabelEntry got unexpected error: %v", err))
	}
	return v
}

// GetLabelEntry retrieves the value with the specified key from
// the LabelEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	if t == nil {
		return nil
	}

	key := Label

	if lm, ok := t.LabelEntry[key]; ok {
		return lm
	}
	return nil
}

// AppendLabelEntry appends the supplied NetworkInstance_Afts_LabelEntry struct to the
// list LabelEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_LabelEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendLabelEntry(v *NetworkInstance_Afts_LabelEntry) error {
	key := v.Label

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	if _, ok := t.LabelEntry[key]; ok {
		return fmt.Errorf("duplicate key for list LabelEntry %v", key)
	}

	t.LabelEntry[key] = v
	return nil
}

// NewMacEntry creates a new entry in the MacEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewMacEntry(MacAddress string) (*NetworkInstance_Afts_MacEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	key := MacAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MacEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MacEntry", key)
	}

	t.MacEntry[key] = &NetworkInstance_Afts_MacEntry{
		MacAddress: &MacAddress,
	}

	return t.MacEntry[key], nil
}

// RenameMacEntry renames an entry in the list MacEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameMacEntry(oldK, newK string) error {
	if _, ok := t.MacEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in MacEntry", newK)
	}

	e, ok := t.MacEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MacEntry", oldK)
	}
	e.MacAddress = &newK

	t.MacEntry[newK] = e
	delete(t.MacEntry, oldK)
	return nil
}

// GetOrCreateMacEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	key := MacAddress

	if v, ok := t.MacEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMacEntry(MacAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMacEntry got unexpected error: %v", err))
	}
	return v
}

// GetMacEntry retrieves the value with the specified key from
// the MacEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	if t == nil {
		return nil
	}

	key := MacAddress

	if lm, ok := t.MacEntry[key]; ok {
		return lm
	}
	return nil
}

// AppendMacEntry appends the supplied NetworkInstance_Afts_MacEntry struct to the
// list MacEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_MacEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendMacEntry(v *NetworkInstance_Afts_MacEntry) error {
	key := *v.MacAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	if _, ok := t.MacEntry[key]; ok {
		return fmt.Errorf("duplicate key for list MacEntry %v", key)
	}

	t.MacEntry[key] = v
	return nil
}

// NewPolicyForwardingEntry creates a new entry in the PolicyForwardingEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewPolicyForwardingEntry(Index uint64) (*NetworkInstance_Afts_PolicyForwardingEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PolicyForwardingEntry", key)
	}

	t.PolicyForwardingEntry[key] = &NetworkInstance_Afts_PolicyForwardingEntry{
		Index: &Index,
	}

	return t.PolicyForwardingEntry[key], nil
}

// RenamePolicyForwardingEntry renames an entry in the list PolicyForwardingEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenamePolicyForwardingEntry(oldK, newK uint64) error {
	if _, ok := t.PolicyForwardingEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in PolicyForwardingEntry", newK)
	}

	e, ok := t.PolicyForwardingEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PolicyForwardingEntry", oldK)
	}
	e.Index = &newK

	t.PolicyForwardingEntry[newK] = e
	delete(t.PolicyForwardingEntry, oldK)
	return nil
}

// GetOrCreatePolicyForwardingEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreatePolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	key := Index

	if v, ok := t.PolicyForwardingEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicyForwardingEntry(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicyForwardingEntry got unexpected error: %v", err))
	}
	return v
}

// GetPolicyForwardingEntry retrieves the value with the specified key from
// the PolicyForwardingEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetPolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.PolicyForwardingEntry[key]; ok {
		return lm
	}
	return nil
}

// AppendPolicyForwardingEntry appends the supplied NetworkInstance_Afts_PolicyForwardingEntry struct to the
// list PolicyForwardingEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_PolicyForwardingEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendPolicyForwardingEntry(v *NetworkInstance_Afts_PolicyForwardingEntry) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return fmt.Errorf("duplicate key for list PolicyForwardingEntry %v", key)
	}

	t.PolicyForwardingEntry[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts_Ipv4Entry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_Ipv4Entry) NewNextHop(Index uint64) (*NetworkInstance_Afts_Ipv4Entry_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_Ipv4Entry_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_Ipv4Entry_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts_Ipv4Entry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_Ipv4Entry) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_Ipv4Entry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_Ipv4Entry_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts_Ipv4Entry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_Ipv4Entry) GetNextHop(Index uint64) *NetworkInstance_Afts_Ipv4Entry_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// AppendNextHop appends the supplied NetworkInstance_Afts_Ipv4Entry_NextHop struct to the
// list NextHop of NetworkInstance_Afts_Ipv4Entry. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv4Entry_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_Ipv4Entry) AppendNextHop(v *NetworkInstance_Afts_Ipv4Entry_NextHop) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_Ipv4Entry_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv4Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_Ipv4Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Afts_Ipv4Entry_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Afts_Ipv4Entry_NextHop_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Afts_Ipv4Entry_NextHop_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Afts_Ipv4Entry_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Afts_Ipv4Entry_NextHop) GetInterfaceRef() *NetworkInstance_Afts_Ipv4Entry_NextHop_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv4Entry_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv4Entry_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_Ipv4Entry_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry_NextHop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_Ipv4Entry_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry_NextHop_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts_Ipv6Entry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_Ipv6Entry) NewNextHop(Index uint64) (*NetworkInstance_Afts_Ipv6Entry_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_Ipv6Entry_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_Ipv6Entry_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts_Ipv6Entry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_Ipv6Entry) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_Ipv6Entry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_Ipv6Entry_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts_Ipv6Entry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_Ipv6Entry) GetNextHop(Index uint64) *NetworkInstance_Afts_Ipv6Entry_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// AppendNextHop appends the supplied NetworkInstance_Afts_Ipv6Entry_NextHop struct to the
// list NextHop of NetworkInstance_Afts_Ipv6Entry. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv6Entry_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_Ipv6Entry) AppendNextHop(v *NetworkInstance_Afts_Ipv6Entry_NextHop) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_Ipv6Entry_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv6Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_Ipv6Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Afts_Ipv6Entry_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Afts_Ipv6Entry_NextHop_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Afts_Ipv6Entry_NextHop_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Afts_Ipv6Entry_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Afts_Ipv6Entry_NextHop) GetInterfaceRef() *NetworkInstance_Afts_Ipv6Entry_NextHop_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv6Entry_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv6Entry_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_Ipv6Entry_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry_NextHop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_Ipv6Entry_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry_NextHop_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts_LabelEntry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_LabelEntry) NewNextHop(Index uint64) (*NetworkInstance_Afts_LabelEntry_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_LabelEntry_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_LabelEntry_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts_LabelEntry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_LabelEntry) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_LabelEntry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_LabelEntry) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_LabelEntry_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts_LabelEntry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_LabelEntry) GetNextHop(Index uint64) *NetworkInstance_Afts_LabelEntry_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// AppendNextHop appends the supplied NetworkInstance_Afts_LabelEntry_NextHop struct to the
// list NextHop of NetworkInstance_Afts_LabelEntry. If the key value(s) specified in
// the supplied NetworkInstance_Afts_LabelEntry_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_LabelEntry) AppendNextHop(v *NetworkInstance_Afts_LabelEntry_NextHop) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_LabelEntry_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_LabelEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_LabelEntry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"label": t.Label,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_LabelEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Afts_LabelEntry_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Afts_LabelEntry_NextHop_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Afts_LabelEntry_NextHop_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Afts_LabelEntry_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Afts_LabelEntry_NextHop) GetInterfaceRef() *NetworkInstance_Afts_LabelEntry_NextHop_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_LabelEntry_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_LabelEntry_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_LabelEntry_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry_NextHop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_LabelEntry_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry_NextHop_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts_MacEntry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_MacEntry) NewNextHop(Index uint64) (*NetworkInstance_Afts_MacEntry_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_MacEntry_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_MacEntry_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts_MacEntry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_MacEntry) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_MacEntry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_MacEntry) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_MacEntry_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts_MacEntry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_MacEntry) GetNextHop(Index uint64) *NetworkInstance_Afts_MacEntry_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// AppendNextHop appends the supplied NetworkInstance_Afts_MacEntry_NextHop struct to the
// list NextHop of NetworkInstance_Afts_MacEntry. If the key value(s) specified in
// the supplied NetworkInstance_Afts_MacEntry_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_MacEntry) AppendNextHop(v *NetworkInstance_Afts_MacEntry_NextHop) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_MacEntry_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_MacEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_MacEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_MacEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Afts_MacEntry_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Afts_MacEntry_NextHop_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Afts_MacEntry_NextHop_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Afts_MacEntry_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Afts_MacEntry_NextHop) GetInterfaceRef() *NetworkInstance_Afts_MacEntry_NextHop_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_MacEntry_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_MacEntry_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_MacEntry_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry_NextHop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_MacEntry_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry_NextHop_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts_PolicyForwardingEntry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) NewNextHop(Index uint64) (*NetworkInstance_Afts_PolicyForwardingEntry_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_PolicyForwardingEntry_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts_PolicyForwardingEntry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_PolicyForwardingEntry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts_PolicyForwardingEntry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetNextHop(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// AppendNextHop appends the supplied NetworkInstance_Afts_PolicyForwardingEntry_NextHop struct to the
// list NextHop of NetworkInstance_Afts_PolicyForwardingEntry. If the key value(s) specified in
// the supplied NetworkInstance_Afts_PolicyForwardingEntry_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) AppendNextHop(v *NetworkInstance_Afts_PolicyForwardingEntry_NextHop) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_PolicyForwardingEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_PolicyForwardingEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Afts_PolicyForwardingEntry_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Afts_PolicyForwardingEntry_NextHop_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Afts_PolicyForwardingEntry_NextHop_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Afts_PolicyForwardingEntry_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Afts_PolicyForwardingEntry_NextHop) GetInterfaceRef() *NetworkInstance_Afts_PolicyForwardingEntry_NextHop_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_PolicyForwardingEntry_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_PolicyForwardingEntry_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry_NextHop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Afts_PolicyForwardingEntry_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry_NextHop_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewEndpoint creates a new entry in the Endpoint list of the
// NetworkInstance_ConnectionPoint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint) NewEndpoint(EndpointId string) (*NetworkInstance_ConnectionPoint_Endpoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	key := EndpointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Endpoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Endpoint", key)
	}

	t.Endpoint[key] = &NetworkInstance_ConnectionPoint_Endpoint{
		EndpointId: &EndpointId,
	}

	return t.Endpoint[key], nil
}

// RenameEndpoint renames an entry in the list Endpoint within
// the NetworkInstance_ConnectionPoint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint) RenameEndpoint(oldK, newK string) error {
	if _, ok := t.Endpoint[newK]; ok {
		return fmt.Errorf("key %v already exists in Endpoint", newK)
	}

	e, ok := t.Endpoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Endpoint", oldK)
	}
	e.EndpointId = &newK

	t.Endpoint[newK] = e
	delete(t.Endpoint, oldK)
	return nil
}

// GetOrCreateEndpoint retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint) GetOrCreateEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	key := EndpointId

	if v, ok := t.Endpoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpoint(EndpointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpoint got unexpected error: %v", err))
	}
	return v
}

// GetEndpoint retrieves the value with the specified key from
// the Endpoint map field of NetworkInstance_ConnectionPoint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint) GetEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	if t == nil {
		return nil
	}

	key := EndpointId

	if lm, ok := t.Endpoint[key]; ok {
		return lm
	}
	return nil
}

// AppendEndpoint appends the supplied NetworkInstance_ConnectionPoint_Endpoint struct to the
// list Endpoint of NetworkInstance_ConnectionPoint. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint) AppendEndpoint(v *NetworkInstance_ConnectionPoint_Endpoint) error {
	key := *v.EndpointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	if _, ok := t.Endpoint[key]; ok {
		return fmt.Errorf("duplicate key for list Endpoint %v", key)
	}

	t.Endpoint[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConnectionPointId == nil {
		return nil, fmt.Errorf("nil value for key ConnectionPointId")
	}

	return map[string]interface{}{
		"connection-point-id": *t.ConnectionPointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_ConnectionPoint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLocal retrieves the value of the Local field
// or returns the existing field if it already exists.
func (s *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if s.Local != nil {
		return s.Local
	}
	s.Local = &NetworkInstance_ConnectionPoint_Endpoint_Local{}
	return s.Local
}

// GetOrCreateRemote retrieves the value of the Remote field
// or returns the existing field if it already exists.
func (s *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if s.Remote != nil {
		return s.Remote
	}
	s.Remote = &NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	return s.Remote
}

// GetLocal returns the value of the Local struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Local is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_ConnectionPoint_Endpoint) GetLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if s != nil && s.Local != nil {
		return s.Local
	}
	return nil
}

// GetRemote returns the value of the Remote struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Remote is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_ConnectionPoint_Endpoint) GetRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if s != nil && s.Remote != nil {
		return s.Remote
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.EndpointId == nil {
		return nil, fmt.Errorf("nil value for key EndpointId")
	}

	return map[string]interface{}{
		"endpoint-id": *t.EndpointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_ConnectionPoint_Endpoint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_ConnectionPoint_Endpoint_Local) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Local"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_ConnectionPoint_Endpoint_Remote) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Remote"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Encapsulation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Encapsulation"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Encapsulation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateMacTable retrieves the value of the MacTable field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Fdb) GetOrCreateMacTable() *NetworkInstance_Fdb_MacTable {
	if s.MacTable != nil {
		return s.MacTable
	}
	s.MacTable = &NetworkInstance_Fdb_MacTable{}
	return s.MacTable
}

// GetMacTable returns the value of the MacTable struct pointer
// from NetworkInstance_Fdb. If the receiver or the field MacTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Fdb) GetMacTable() *NetworkInstance_Fdb_MacTable {
	if s != nil && s.MacTable != nil {
		return s.MacTable
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Fdb) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_MacTable) NewEntry(MacAddress string) (*NetworkInstance_Fdb_MacTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[string]*NetworkInstance_Fdb_MacTable_Entry)
	}

	key := MacAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_MacTable_Entry{
		MacAddress: &MacAddress,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_MacTable) RenameEntry(oldK, newK string) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_MacTable) GetOrCreateEntry(MacAddress string) *NetworkInstance_Fdb_MacTable_Entry {

	key := MacAddress

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_MacTable) GetEntry(MacAddress string) *NetworkInstance_Fdb_MacTable_Entry {

	if t == nil {
		return nil
	}

	key := MacAddress

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// AppendEntry appends the supplied NetworkInstance_Fdb_MacTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_MacTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_MacTable) AppendEntry(v *NetworkInstance_Fdb_MacTable_Entry) error {
	key := *v.MacAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[string]*NetworkInstance_Fdb_MacTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Fdb_MacTable) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterface retrieves the value of the Interface field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Fdb_MacTable_Entry) GetOrCreateInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if s.Interface != nil {
		return s.Interface
	}
	s.Interface = &NetworkInstance_Fdb_MacTable_Entry_Interface{}
	return s.Interface
}

// GetInterface returns the value of the Interface struct pointer
// from NetworkInstance_Fdb_MacTable_Entry. If the receiver or the field Interface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Fdb_MacTable_Entry) GetInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if s != nil && s.Interface != nil {
		return s.Interface
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_MacTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Fdb_MacTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Fdb_MacTable_Entry_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Fdb_MacTable_Entry_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Fdb_MacTable_Entry_Interface) GetInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Fdb_MacTable_Entry_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (s *NetworkInstance_InterInstancePolicies) GetOrCreateApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	s.ApplyPolicy = &NetworkInstance_InterInstancePolicies_ApplyPolicy{}
	return s.ApplyPolicy
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_InterInstancePolicies. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_InterInstancePolicies) GetApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if s != nil && s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_InterInstancePolicies) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_InterInstancePolicies_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies_ApplyPolicy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Interface struct to the
// list Interface of NetworkInstance_Mpls. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls) AppendInterface(v *NetworkInstance_Mpls_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls) GetOrCreateGlobal() *NetworkInstance_Mpls_Global {
	if s.Global != nil {
		return s.Global
	}
	s.Global = &NetworkInstance_Mpls_Global{}
	return s.Global
}

// GetOrCreateLsps retrieves the value of the Lsps field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls) GetOrCreateLsps() *NetworkInstance_Mpls_Lsps {
	if s.Lsps != nil {
		return s.Lsps
	}
	s.Lsps = &NetworkInstance_Mpls_Lsps{}
	return s.Lsps
}

// GetOrCreateSignalingProtocols retrieves the value of the SignalingProtocols field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls) GetOrCreateSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if s.SignalingProtocols != nil {
		return s.SignalingProtocols
	}
	s.SignalingProtocols = &NetworkInstance_Mpls_SignalingProtocols{}
	return s.SignalingProtocols
}

// GetOrCreateTeGlobalAttributes retrieves the value of the TeGlobalAttributes field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls) GetOrCreateTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if s.TeGlobalAttributes != nil {
		return s.TeGlobalAttributes
	}
	s.TeGlobalAttributes = &NetworkInstance_Mpls_TeGlobalAttributes{}
	return s.TeGlobalAttributes
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls) GetGlobal() *NetworkInstance_Mpls_Global {
	if s != nil && s.Global != nil {
		return s.Global
	}
	return nil
}

// GetLsps returns the value of the Lsps struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Lsps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls) GetLsps() *NetworkInstance_Mpls_Lsps {
	if s != nil && s.Lsps != nil {
		return s.Lsps
	}
	return nil
}

// GetSignalingProtocols returns the value of the SignalingProtocols struct pointer
// from NetworkInstance_Mpls. If the receiver or the field SignalingProtocols is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls) GetSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if s != nil && s.SignalingProtocols != nil {
		return s.SignalingProtocols
	}
	return nil
}

// GetTeGlobalAttributes returns the value of the TeGlobalAttributes struct pointer
// from NetworkInstance_Mpls. If the receiver or the field TeGlobalAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls) GetTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if s != nil && s.TeGlobalAttributes != nil {
		return s.TeGlobalAttributes
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Global_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Global_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Global_Interface struct to the
// list Interface of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendInterface(v *NetworkInstance_Mpls_Global_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewReservedLabelBlock creates a new entry in the ReservedLabelBlock list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewReservedLabelBlock(LocalId string) (*NetworkInstance_Mpls_Global_ReservedLabelBlock, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	key := LocalId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ReservedLabelBlock[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ReservedLabelBlock", key)
	}

	t.ReservedLabelBlock[key] = &NetworkInstance_Mpls_Global_ReservedLabelBlock{
		LocalId: &LocalId,
	}

	return t.ReservedLabelBlock[key], nil
}

// RenameReservedLabelBlock renames an entry in the list ReservedLabelBlock within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameReservedLabelBlock(oldK, newK string) error {
	if _, ok := t.ReservedLabelBlock[newK]; ok {
		return fmt.Errorf("key %v already exists in ReservedLabelBlock", newK)
	}

	e, ok := t.ReservedLabelBlock[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ReservedLabelBlock", oldK)
	}
	e.LocalId = &newK

	t.ReservedLabelBlock[newK] = e
	delete(t.ReservedLabelBlock, oldK)
	return nil
}

// GetOrCreateReservedLabelBlock retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	key := LocalId

	if v, ok := t.ReservedLabelBlock[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewReservedLabelBlock(LocalId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateReservedLabelBlock got unexpected error: %v", err))
	}
	return v
}

// GetReservedLabelBlock retrieves the value with the specified key from
// the ReservedLabelBlock map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	if t == nil {
		return nil
	}

	key := LocalId

	if lm, ok := t.ReservedLabelBlock[key]; ok {
		return lm
	}
	return nil
}

// AppendReservedLabelBlock appends the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock struct to the
// list ReservedLabelBlock of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendReservedLabelBlock(v *NetworkInstance_Mpls_Global_ReservedLabelBlock) error {
	key := *v.LocalId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	if _, ok := t.ReservedLabelBlock[key]; ok {
		return fmt.Errorf("duplicate key for list ReservedLabelBlock %v", key)
	}

	t.ReservedLabelBlock[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Global_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Global_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Global_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Global_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Global_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_ReservedLabelBlock struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalId == nil {
		return nil, fmt.Errorf("nil value for key LocalId")
	}

	return map[string]interface{}{
		"local-id": *t.LocalId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Global_ReservedLabelBlock) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_ReservedLabelBlock"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateIgpFloodingBandwidth retrieves the value of the IgpFloodingBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Interface) GetOrCreateIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if s.IgpFloodingBandwidth != nil {
		return s.IgpFloodingBandwidth
	}
	s.IgpFloodingBandwidth = &NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	return s.IgpFloodingBandwidth
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Mpls_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetIgpFloodingBandwidth returns the value of the IgpFloodingBandwidth struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field IgpFloodingBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Interface) GetIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if s != nil && s.IgpFloodingBandwidth != nil {
		return s.IgpFloodingBandwidth
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_IgpFloodingBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewStaticLsp creates a new entry in the StaticLsp list of the
// NetworkInstance_Mpls_Lsps struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps) NewStaticLsp(Name string) (*NetworkInstance_Mpls_Lsps_StaticLsp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.StaticLsp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list StaticLsp", key)
	}

	t.StaticLsp[key] = &NetworkInstance_Mpls_Lsps_StaticLsp{
		Name: &Name,
	}

	return t.StaticLsp[key], nil
}

// RenameStaticLsp renames an entry in the list StaticLsp within
// the NetworkInstance_Mpls_Lsps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps) RenameStaticLsp(oldK, newK string) error {
	if _, ok := t.StaticLsp[newK]; ok {
		return fmt.Errorf("key %v already exists in StaticLsp", newK)
	}

	e, ok := t.StaticLsp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in StaticLsp", oldK)
	}
	e.Name = &newK

	t.StaticLsp[newK] = e
	delete(t.StaticLsp, oldK)
	return nil
}

// GetOrCreateStaticLsp retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	key := Name

	if v, ok := t.StaticLsp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStaticLsp(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStaticLsp got unexpected error: %v", err))
	}
	return v
}

// GetStaticLsp retrieves the value with the specified key from
// the StaticLsp map field of NetworkInstance_Mpls_Lsps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.StaticLsp[key]; ok {
		return lm
	}
	return nil
}

// AppendStaticLsp appends the supplied NetworkInstance_Mpls_Lsps_StaticLsp struct to the
// list StaticLsp of NetworkInstance_Mpls_Lsps. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_StaticLsp already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps) AppendStaticLsp(v *NetworkInstance_Mpls_Lsps_StaticLsp) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	if _, ok := t.StaticLsp[key]; ok {
		return fmt.Errorf("duplicate key for list StaticLsp %v", key)
	}

	t.StaticLsp[key] = v
	return nil
}

// GetOrCreateConstrainedPath retrieves the value of the ConstrainedPath field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps) GetOrCreateConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if s.ConstrainedPath != nil {
		return s.ConstrainedPath
	}
	s.ConstrainedPath = &NetworkInstance_Mpls_Lsps_ConstrainedPath{}
	return s.ConstrainedPath
}

// GetOrCreateUnconstrainedPath retrieves the value of the UnconstrainedPath field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps) GetOrCreateUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if s.UnconstrainedPath != nil {
		return s.UnconstrainedPath
	}
	s.UnconstrainedPath = &NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	return s.UnconstrainedPath
}

// GetConstrainedPath returns the value of the ConstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field ConstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps) GetConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if s != nil && s.ConstrainedPath != nil {
		return s.ConstrainedPath
	}
	return nil
}

// GetUnconstrainedPath returns the value of the UnconstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field UnconstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps) GetUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if s != nil && s.UnconstrainedPath != nil {
		return s.UnconstrainedPath
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNamedExplicitPath creates a new entry in the NamedExplicitPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewNamedExplicitPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NamedExplicitPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NamedExplicitPath", key)
	}

	t.NamedExplicitPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{
		Name: &Name,
	}

	return t.NamedExplicitPath[key], nil
}

// RenameNamedExplicitPath renames an entry in the list NamedExplicitPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameNamedExplicitPath(oldK, newK string) error {
	if _, ok := t.NamedExplicitPath[newK]; ok {
		return fmt.Errorf("key %v already exists in NamedExplicitPath", newK)
	}

	e, ok := t.NamedExplicitPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NamedExplicitPath", oldK)
	}
	e.Name = &newK

	t.NamedExplicitPath[newK] = e
	delete(t.NamedExplicitPath, oldK)
	return nil
}

// GetOrCreateNamedExplicitPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	key := Name

	if v, ok := t.NamedExplicitPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNamedExplicitPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNamedExplicitPath got unexpected error: %v", err))
	}
	return v
}

// GetNamedExplicitPath retrieves the value with the specified key from
// the NamedExplicitPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NamedExplicitPath[key]; ok {
		return lm
	}
	return nil
}

// AppendNamedExplicitPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct to the
// list NamedExplicitPath of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendNamedExplicitPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	if _, ok := t.NamedExplicitPath[key]; ok {
		return fmt.Errorf("duplicate key for list NamedExplicitPath %v", key)
	}

	t.NamedExplicitPath[key] = v
	return nil
}

// NewTunnel creates a new entry in the Tunnel list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewTunnel(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tunnel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tunnel", key)
	}

	t.Tunnel[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{
		Name: &Name,
	}

	return t.Tunnel[key], nil
}

// RenameTunnel renames an entry in the list Tunnel within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameTunnel(oldK, newK string) error {
	if _, ok := t.Tunnel[newK]; ok {
		return fmt.Errorf("key %v already exists in Tunnel", newK)
	}

	e, ok := t.Tunnel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tunnel", oldK)
	}
	e.Name = &newK

	t.Tunnel[newK] = e
	delete(t.Tunnel, oldK)
	return nil
}

// GetOrCreateTunnel retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	key := Name

	if v, ok := t.Tunnel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTunnel(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTunnel got unexpected error: %v", err))
	}
	return v
}

// GetTunnel retrieves the value with the specified key from
// the Tunnel map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Tunnel[key]; ok {
		return lm
	}
	return nil
}

// AppendTunnel appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct to the
// list Tunnel of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendTunnel(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	if _, ok := t.Tunnel[key]; ok {
		return fmt.Errorf("duplicate key for list Tunnel %v", key)
	}

	t.Tunnel[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewExplicitRouteObject creates a new entry in the ExplicitRouteObject list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) NewExplicitRouteObject(Index uint8) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExplicitRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExplicitRouteObject", key)
	}

	t.ExplicitRouteObject[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{
		Index: &Index,
	}

	return t.ExplicitRouteObject[key], nil
}

// RenameExplicitRouteObject renames an entry in the list ExplicitRouteObject within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) RenameExplicitRouteObject(oldK, newK uint8) error {
	if _, ok := t.ExplicitRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in ExplicitRouteObject", newK)
	}

	e, ok := t.ExplicitRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExplicitRouteObject", oldK)
	}
	e.Index = &newK

	t.ExplicitRouteObject[newK] = e
	delete(t.ExplicitRouteObject, oldK)
	return nil
}

// GetOrCreateExplicitRouteObject retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetOrCreateExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	key := Index

	if v, ok := t.ExplicitRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExplicitRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExplicitRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetExplicitRouteObject retrieves the value with the specified key from
// the ExplicitRouteObject map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.ExplicitRouteObject[key]; ok {
		return lm
	}
	return nil
}

// AppendExplicitRouteObject appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct to the
// list ExplicitRouteObject of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) AppendExplicitRouteObject(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	if _, ok := t.ExplicitRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list ExplicitRouteObject %v", key)
	}

	t.ExplicitRouteObject[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateBandwidth retrieves the value of the Bandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if s.Bandwidth != nil {
		return s.Bandwidth
	}
	s.Bandwidth = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
	return s.Bandwidth
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	return s.Counters
}

// GetOrCreateP2PTunnelAttributes retrieves the value of the P2PTunnelAttributes field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if s.P2PTunnelAttributes != nil {
		return s.P2PTunnelAttributes
	}
	s.P2PTunnelAttributes = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	return s.P2PTunnelAttributes
}

// GetBandwidth returns the value of the Bandwidth struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Bandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if s != nil && s.Bandwidth != nil {
		return s.Bandwidth
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetP2PTunnelAttributes returns the value of the P2PTunnelAttributes struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field P2PTunnelAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if s != nil && s.P2PTunnelAttributes != nil {
		return s.P2PTunnelAttributes
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAutoBandwidth retrieves the value of the AutoBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetOrCreateAutoBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if s.AutoBandwidth != nil {
		return s.AutoBandwidth
	}
	s.AutoBandwidth = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	return s.AutoBandwidth
}

// GetAutoBandwidth returns the value of the AutoBandwidth struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth. If the receiver or the field AutoBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetAutoBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if s != nil && s.AutoBandwidth != nil {
		return s.AutoBandwidth
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateOverflow retrieves the value of the Overflow field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateOverflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if s.Overflow != nil {
		return s.Overflow
	}
	s.Overflow = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
	return s.Overflow
}

// GetOrCreateUnderflow retrieves the value of the Underflow field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateUnderflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if s.Underflow != nil {
		return s.Underflow
	}
	s.Underflow = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
	return s.Underflow
}

// GetOverflow returns the value of the Overflow struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Overflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOverflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if s != nil && s.Overflow != nil {
		return s.Overflow
	}
	return nil
}

// GetUnderflow returns the value of the Underflow struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Underflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetUnderflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if s != nil && s.Underflow != nil {
		return s.Underflow
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewP2PPrimaryPath creates a new entry in the P2PPrimaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) NewP2PPrimaryPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PPrimaryPath == nil {
		t.P2PPrimaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.P2PPrimaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list P2PPrimaryPath", key)
	}

	t.P2PPrimaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
		Name: &Name,
	}

	return t.P2PPrimaryPath[key], nil
}

// RenameP2PPrimaryPath renames an entry in the list P2PPrimaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) RenameP2PPrimaryPath(oldK, newK string) error {
	if _, ok := t.P2PPrimaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in P2PPrimaryPath", newK)
	}

	e, ok := t.P2PPrimaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in P2PPrimaryPath", oldK)
	}
	e.Name = &newK

	t.P2PPrimaryPath[newK] = e
	delete(t.P2PPrimaryPath, oldK)
	return nil
}

// GetOrCreateP2PPrimaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PPrimaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {

	key := Name

	if v, ok := t.P2PPrimaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewP2PPrimaryPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateP2PPrimaryPath got unexpected error: %v", err))
	}
	return v
}

// GetP2PPrimaryPath retrieves the value with the specified key from
// the P2PPrimaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetP2PPrimaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.P2PPrimaryPath[key]; ok {
		return lm
	}
	return nil
}

// AppendP2PPrimaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct to the
// list P2PPrimaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) AppendP2PPrimaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PPrimaryPath == nil {
		t.P2PPrimaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
	}

	if _, ok := t.P2PPrimaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list P2PPrimaryPath %v", key)
	}

	t.P2PPrimaryPath[key] = v
	return nil
}

// NewP2PSecondaryPath creates a new entry in the P2PSecondaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) NewP2PSecondaryPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PSecondaryPath == nil {
		t.P2PSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.P2PSecondaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list P2PSecondaryPath", key)
	}

	t.P2PSecondaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
		Name: &Name,
	}

	return t.P2PSecondaryPath[key], nil
}

// RenameP2PSecondaryPath renames an entry in the list P2PSecondaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) RenameP2PSecondaryPath(oldK, newK string) error {
	if _, ok := t.P2PSecondaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in P2PSecondaryPath", newK)
	}

	e, ok := t.P2PSecondaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in P2PSecondaryPath", oldK)
	}
	e.Name = &newK

	t.P2PSecondaryPath[newK] = e
	delete(t.P2PSecondaryPath, oldK)
	return nil
}

// GetOrCreateP2PSecondaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PSecondaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {

	key := Name

	if v, ok := t.P2PSecondaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewP2PSecondaryPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateP2PSecondaryPath got unexpected error: %v", err))
	}
	return v
}

// GetP2PSecondaryPath retrieves the value with the specified key from
// the P2PSecondaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetP2PSecondaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.P2PSecondaryPath[key]; ok {
		return lm
	}
	return nil
}

// AppendP2PSecondaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct to the
// list P2PSecondaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) AppendP2PSecondaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PSecondaryPath == nil {
		t.P2PSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
	}

	if _, ok := t.P2PSecondaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list P2PSecondaryPath %v", key)
	}

	t.P2PSecondaryPath[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewCandidateSecondaryPath creates a new entry in the CandidateSecondaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) NewCandidateSecondaryPath(SecondaryPath string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CandidateSecondaryPath == nil {
		t.CandidateSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
	}

	key := SecondaryPath

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CandidateSecondaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CandidateSecondaryPath", key)
	}

	t.CandidateSecondaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
		SecondaryPath: &SecondaryPath,
	}

	return t.CandidateSecondaryPath[key], nil
}

// RenameCandidateSecondaryPath renames an entry in the list CandidateSecondaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) RenameCandidateSecondaryPath(oldK, newK string) error {
	if _, ok := t.CandidateSecondaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in CandidateSecondaryPath", newK)
	}

	e, ok := t.CandidateSecondaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in CandidateSecondaryPath", oldK)
	}
	e.SecondaryPath = &newK

	t.CandidateSecondaryPath[newK] = e
	delete(t.CandidateSecondaryPath, oldK)
	return nil
}

// GetOrCreateCandidateSecondaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreateCandidateSecondaryPath(SecondaryPath string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {

	key := SecondaryPath

	if v, ok := t.CandidateSecondaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCandidateSecondaryPath(SecondaryPath)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCandidateSecondaryPath got unexpected error: %v", err))
	}
	return v
}

// GetCandidateSecondaryPath retrieves the value with the specified key from
// the CandidateSecondaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetCandidateSecondaryPath(SecondaryPath string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {

	if t == nil {
		return nil
	}

	key := SecondaryPath

	if lm, ok := t.CandidateSecondaryPath[key]; ok {
		return lm
	}
	return nil
}

// AppendCandidateSecondaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct to the
// list CandidateSecondaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) AppendCandidateSecondaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) error {
	key := *v.SecondaryPath

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CandidateSecondaryPath == nil {
		t.CandidateSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
	}

	if _, ok := t.CandidateSecondaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list CandidateSecondaryPath %v", key)
	}

	t.CandidateSecondaryPath[key] = v
	return nil
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreateAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	if s.AdminGroups != nil {
		return s.AdminGroups
	}
	s.AdminGroups = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	return s.AdminGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	if s != nil && s.AdminGroups != nil {
		return s.AdminGroups
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SecondaryPath == nil {
		return nil, fmt.Errorf("nil value for key SecondaryPath")
	}

	return map[string]interface{}{
		"secondary-path": *t.SecondaryPath,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetOrCreateAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if s.AdminGroups != nil {
		return s.AdminGroups
	}
	s.AdminGroups = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	return s.AdminGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if s != nil && s.AdminGroups != nil {
		return s.AdminGroups
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEgress retrieves the value of the Egress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateEgress() *NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	if s.Egress != nil {
		return s.Egress
	}
	s.Egress = &NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	return s.Egress
}

// GetOrCreateIngress retrieves the value of the Ingress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateIngress() *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	if s.Ingress != nil {
		return s.Ingress
	}
	s.Ingress = &NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	return s.Ingress
}

// GetOrCreateTransit retrieves the value of the Transit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateTransit() *NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	if s.Transit != nil {
		return s.Transit
	}
	s.Transit = &NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	return s.Transit
}

// GetEgress returns the value of the Egress struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Egress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_StaticLsp) GetEgress() *NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	if s != nil && s.Egress != nil {
		return s.Egress
	}
	return nil
}

// GetIngress returns the value of the Ingress struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Ingress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_StaticLsp) GetIngress() *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	if s != nil && s.Ingress != nil {
		return s.Ingress
	}
	return nil
}

// GetTransit returns the value of the Transit struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Transit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_StaticLsp) GetTransit() *NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	if s != nil && s.Transit != nil {
		return s.Transit
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_StaticLsp struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_StaticLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Egress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Ingress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Transit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePathSetupProtocol retrieves the value of the PathSetupProtocol field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_UnconstrainedPath) GetOrCreatePathSetupProtocol() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if s.PathSetupProtocol != nil {
		return s.PathSetupProtocol
	}
	s.PathSetupProtocol = &NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	return s.PathSetupProtocol
}

// GetPathSetupProtocol returns the value of the PathSetupProtocol struct pointer
// from NetworkInstance_Mpls_Lsps_UnconstrainedPath. If the receiver or the field PathSetupProtocol is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_UnconstrainedPath) GetPathSetupProtocol() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if s != nil && s.PathSetupProtocol != nil {
		return s.PathSetupProtocol
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_UnconstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetOrCreateLdp() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if s.Ldp != nil {
		return s.Ldp
	}
	s.Ldp = &NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	return s.Ldp
}

// GetLdp returns the value of the Ldp struct pointer
// from NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetLdp() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if s != nil && s.Ldp != nil {
		return s.Ldp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateLdp() *NetworkInstance_Mpls_SignalingProtocols_Ldp {
	if s.Ldp != nil {
		return s.Ldp
	}
	s.Ldp = &NetworkInstance_Mpls_SignalingProtocols_Ldp{}
	return s.Ldp
}

// GetOrCreateRsvpTe retrieves the value of the RsvpTe field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateRsvpTe() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	if s.RsvpTe != nil {
		return s.RsvpTe
	}
	s.RsvpTe = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	return s.RsvpTe
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateSegmentRouting() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	if s.SegmentRouting != nil {
		return s.SegmentRouting
	}
	s.SegmentRouting = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	return s.SegmentRouting
}

// GetLdp returns the value of the Ldp struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols) GetLdp() *NetworkInstance_Mpls_SignalingProtocols_Ldp {
	if s != nil && s.Ldp != nil {
		return s.Ldp
	}
	return nil
}

// GetRsvpTe returns the value of the RsvpTe struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field RsvpTe is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols) GetRsvpTe() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	if s != nil && s.RsvpTe != nil {
		return s.RsvpTe
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols) GetSegmentRouting() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	if s != nil && s.SegmentRouting != nil {
		return s.SegmentRouting
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_Ldp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct to the
// list Interface of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) AppendInterface(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) NewNeighbor(Address string) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
		Address: &Address,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Address = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateNeighbor(Address string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {

	key := Address

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetNeighbor(Address string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor struct to the
// list Neighbor of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) AppendNeighbor(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) error {
	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// NewSession creates a new entry in the Session list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) NewSession(LocalIndex uint64) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session)
	}

	key := LocalIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Session[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Session", key)
	}

	t.Session[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
		LocalIndex: &LocalIndex,
	}

	return t.Session[key], nil
}

// RenameSession renames an entry in the list Session within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) RenameSession(oldK, newK uint64) error {
	if _, ok := t.Session[newK]; ok {
		return fmt.Errorf("key %v already exists in Session", newK)
	}

	e, ok := t.Session[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Session", oldK)
	}
	e.LocalIndex = &newK

	t.Session[newK] = e
	delete(t.Session, oldK)
	return nil
}

// GetOrCreateSession retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateSession(LocalIndex uint64) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {

	key := LocalIndex

	if v, ok := t.Session[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSession(LocalIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSession got unexpected error: %v", err))
	}
	return v
}

// GetSession retrieves the value with the specified key from
// the Session map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetSession(LocalIndex uint64) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {

	if t == nil {
		return nil
	}

	key := LocalIndex

	if lm, ok := t.Session[key]; ok {
		return lm
	}
	return nil
}

// AppendSession appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct to the
// list Session of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) AppendSession(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) error {
	key := *v.LocalIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session)
	}

	if _, ok := t.Session[key]; ok {
		return fmt.Errorf("duplicate key for list Session %v", key)
	}

	t.Session[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateGlobal() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	if s.Global != nil {
		return s.Global
	}
	s.Global = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	return s.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetGlobal() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	if s != nil && s.Global != nil {
		return s.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	return s.Counters
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateHellos retrieves the value of the Hellos field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	if s.Hellos != nil {
		return s.Hellos
	}
	s.Hellos = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	return s.Hellos
}

// GetOrCreateSoftPreemption retrieves the value of the SoftPreemption field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateSoftPreemption() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	if s.SoftPreemption != nil {
		return s.SoftPreemption
	}
	s.SoftPreemption = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	return s.SoftPreemption
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetHellos returns the value of the Hellos struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field Hellos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	if s != nil && s.Hellos != nil {
		return s.Hellos
	}
	return nil
}

// GetSoftPreemption returns the value of the SoftPreemption struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field SoftPreemption is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetSoftPreemption() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	if s != nil && s.SoftPreemption != nil {
		return s.SoftPreemption
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewBandwidthReservation creates a new entry in the BandwidthReservation list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) NewBandwidthReservation(Priority NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthReservation == nil {
		t.BandwidthReservation = make(map[NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthReservation[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthReservation", key)
	}

	t.BandwidthReservation[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
		Priority: Priority,
	}

	return t.BandwidthReservation[key], nil
}

// RenameBandwidthReservation renames an entry in the list BandwidthReservation within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) RenameBandwidthReservation(oldK, newK NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) error {
	if _, ok := t.BandwidthReservation[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthReservation", newK)
	}

	e, ok := t.BandwidthReservation[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthReservation", oldK)
	}
	e.Priority = newK

	t.BandwidthReservation[newK] = e
	delete(t.BandwidthReservation, oldK)
	return nil
}

// GetOrCreateBandwidthReservation retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateBandwidthReservation(Priority NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {

	key := Priority

	if v, ok := t.BandwidthReservation[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthReservation(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthReservation got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthReservation retrieves the value with the specified key from
// the BandwidthReservation map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetBandwidthReservation(Priority NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.BandwidthReservation[key]; ok {
		return lm
	}
	return nil
}

// AppendBandwidthReservation appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation struct to the
// list BandwidthReservation of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) AppendBandwidthReservation(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) error {
	key := v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthReservation == nil {
		t.BandwidthReservation = make(map[NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)
	}

	if _, ok := t.BandwidthReservation[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthReservation %v", key)
	}

	t.BandwidthReservation[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateAuthentication() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	if s.Authentication != nil {
		return s.Authentication
	}
	s.Authentication = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	return s.Authentication
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	return s.Counters
}

// GetOrCreateHellos retrieves the value of the Hellos field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	if s.Hellos != nil {
		return s.Hellos
	}
	s.Hellos = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	return s.Hellos
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetOrCreateProtection retrieves the value of the Protection field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateProtection() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	if s.Protection != nil {
		return s.Protection
	}
	s.Protection = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	return s.Protection
}

// GetOrCreateSubscription retrieves the value of the Subscription field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateSubscription() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	if s.Subscription != nil {
		return s.Subscription
	}
	s.Subscription = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	return s.Subscription
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetAuthentication() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	if s != nil && s.Authentication != nil {
		return s.Authentication
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// GetHellos returns the value of the Hellos struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Hellos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	if s != nil && s.Hellos != nil {
		return s.Hellos
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// GetProtection returns the value of the Protection struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Protection is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetProtection() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	if s != nil && s.Protection != nil {
		return s.Protection
	}
	return nil
}

// GetSubscription returns the value of the Subscription struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Subscription is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetSubscription() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	if s != nil && s.Subscription != nil {
		return s.Subscription
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"priority": t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewRecordRouteObject creates a new entry in the RecordRouteObject list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) NewRecordRouteObject(Index uint8) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RecordRouteObject == nil {
		t.RecordRouteObject = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RecordRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RecordRouteObject", key)
	}

	t.RecordRouteObject[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
		Index: &Index,
	}

	return t.RecordRouteObject[key], nil
}

// RenameRecordRouteObject renames an entry in the list RecordRouteObject within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) RenameRecordRouteObject(oldK, newK uint8) error {
	if _, ok := t.RecordRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in RecordRouteObject", newK)
	}

	e, ok := t.RecordRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RecordRouteObject", oldK)
	}
	e.Index = &newK

	t.RecordRouteObject[newK] = e
	delete(t.RecordRouteObject, oldK)
	return nil
}

// GetOrCreateRecordRouteObject retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetOrCreateRecordRouteObject(Index uint8) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {

	key := Index

	if v, ok := t.RecordRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRecordRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRecordRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetRecordRouteObject retrieves the value with the specified key from
// the RecordRouteObject map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetRecordRouteObject(Index uint8) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.RecordRouteObject[key]; ok {
		return lm
	}
	return nil
}

// AppendRecordRouteObject appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject struct to the
// list RecordRouteObject of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) AppendRecordRouteObject(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RecordRouteObject == nil {
		t.RecordRouteObject = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)
	}

	if _, ok := t.RecordRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list RecordRouteObject %v", key)
	}

	t.RecordRouteObject[key] = v
	return nil
}

// GetOrCreateSenderTspec retrieves the value of the SenderTspec field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetOrCreateSenderTspec() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	if s.SenderTspec != nil {
		return s.SenderTspec
	}
	s.SenderTspec = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	return s.SenderTspec
}

// GetSenderTspec returns the value of the SenderTspec struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the receiver or the field SenderTspec is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetSenderTspec() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	if s != nil && s.SenderTspec != nil {
		return s.SenderTspec
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalIndex == nil {
		return nil, fmt.Errorf("nil value for key LocalIndex")
	}

	return map[string]interface{}{
		"local-index": *t.LocalIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAggregateSidCounter creates a new entry in the AggregateSidCounter list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) NewAggregateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AggregateSidCounter == nil {
		t.AggregateSidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)
	}

	key := MplsLabel

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AggregateSidCounter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AggregateSidCounter", key)
	}

	t.AggregateSidCounter[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
		MplsLabel: MplsLabel,
	}

	return t.AggregateSidCounter[key], nil
}

// RenameAggregateSidCounter renames an entry in the list AggregateSidCounter within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) RenameAggregateSidCounter(oldK, newK NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) error {
	if _, ok := t.AggregateSidCounter[newK]; ok {
		return fmt.Errorf("key %v already exists in AggregateSidCounter", newK)
	}

	e, ok := t.AggregateSidCounter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AggregateSidCounter", oldK)
	}
	e.MplsLabel = newK

	t.AggregateSidCounter[newK] = e
	delete(t.AggregateSidCounter, oldK)
	return nil
}

// GetOrCreateAggregateSidCounter retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetOrCreateAggregateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {

	key := MplsLabel

	if v, ok := t.AggregateSidCounter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAggregateSidCounter(MplsLabel)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAggregateSidCounter got unexpected error: %v", err))
	}
	return v
}

// GetAggregateSidCounter retrieves the value with the specified key from
// the AggregateSidCounter map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetAggregateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {

	if t == nil {
		return nil
	}

	key := MplsLabel

	if lm, ok := t.AggregateSidCounter[key]; ok {
		return lm
	}
	return nil
}

// AppendAggregateSidCounter appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter struct to the
// list AggregateSidCounter of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) AppendAggregateSidCounter(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) error {
	key := v.MplsLabel

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AggregateSidCounter == nil {
		t.AggregateSidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)
	}

	if _, ok := t.AggregateSidCounter[key]; ok {
		return fmt.Errorf("duplicate key for list AggregateSidCounter %v", key)
	}

	t.AggregateSidCounter[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct to the
// list Interface of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) AppendInterface(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"mpls-label": t.MplsLabel,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSidCounter creates a new entry in the SidCounter list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) NewSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SidCounter == nil {
		t.SidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)
	}

	key := MplsLabel

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SidCounter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SidCounter", key)
	}

	t.SidCounter[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
		MplsLabel: MplsLabel,
	}

	return t.SidCounter[key], nil
}

// RenameSidCounter renames an entry in the list SidCounter within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) RenameSidCounter(oldK, newK NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) error {
	if _, ok := t.SidCounter[newK]; ok {
		return fmt.Errorf("key %v already exists in SidCounter", newK)
	}

	e, ok := t.SidCounter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SidCounter", oldK)
	}
	e.MplsLabel = newK

	t.SidCounter[newK] = e
	delete(t.SidCounter, oldK)
	return nil
}

// GetOrCreateSidCounter retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetOrCreateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {

	key := MplsLabel

	if v, ok := t.SidCounter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSidCounter(MplsLabel)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSidCounter got unexpected error: %v", err))
	}
	return v
}

// GetSidCounter retrieves the value with the specified key from
// the SidCounter map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {

	if t == nil {
		return nil
	}

	key := MplsLabel

	if lm, ok := t.SidCounter[key]; ok {
		return lm
	}
	return nil
}

// AppendSidCounter appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct to the
// list SidCounter of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) AppendSidCounter(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) error {
	key := v.MplsLabel

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SidCounter == nil {
		t.SidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)
	}

	if _, ok := t.SidCounter[key]; ok {
		return fmt.Errorf("duplicate key for list SidCounter %v", key)
	}

	t.SidCounter[key] = v
	return nil
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewForwardingClass creates a new entry in the ForwardingClass list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) NewForwardingClass(Exp uint8) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)
	}

	key := Exp

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingClass", key)
	}

	t.ForwardingClass[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
		Exp: &Exp,
	}

	return t.ForwardingClass[key], nil
}

// RenameForwardingClass renames an entry in the list ForwardingClass within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) RenameForwardingClass(oldK, newK uint8) error {
	if _, ok := t.ForwardingClass[newK]; ok {
		return fmt.Errorf("key %v already exists in ForwardingClass", newK)
	}

	e, ok := t.ForwardingClass[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ForwardingClass", oldK)
	}
	e.Exp = &newK

	t.ForwardingClass[newK] = e
	delete(t.ForwardingClass, oldK)
	return nil
}

// GetOrCreateForwardingClass retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetOrCreateForwardingClass(Exp uint8) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {

	key := Exp

	if v, ok := t.ForwardingClass[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewForwardingClass(Exp)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateForwardingClass got unexpected error: %v", err))
	}
	return v
}

// GetForwardingClass retrieves the value with the specified key from
// the ForwardingClass map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetForwardingClass(Exp uint8) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {

	if t == nil {
		return nil
	}

	key := Exp

	if lm, ok := t.ForwardingClass[key]; ok {
		return lm
	}
	return nil
}

// AppendForwardingClass appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass struct to the
// list ForwardingClass of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) AppendForwardingClass(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) error {
	key := *v.Exp

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)
	}

	if _, ok := t.ForwardingClass[key]; ok {
		return fmt.Errorf("duplicate key for list ForwardingClass %v", key)
	}

	t.ForwardingClass[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"mpls-label": t.MplsLabel,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Exp == nil {
		return nil, fmt.Errorf("nil value for key Exp")
	}

	return map[string]interface{}{
		"exp": *t.Exp,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdminGroup creates a new entry in the AdminGroup list of the
// NetworkInstance_Mpls_TeGlobalAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) NewAdminGroup(AdminGroupName string) (*NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup)
	}

	key := AdminGroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdminGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdminGroup", key)
	}

	t.AdminGroup[key] = &NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{
		AdminGroupName: &AdminGroupName,
	}

	return t.AdminGroup[key], nil
}

// RenameAdminGroup renames an entry in the list AdminGroup within
// the NetworkInstance_Mpls_TeGlobalAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) RenameAdminGroup(oldK, newK string) error {
	if _, ok := t.AdminGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in AdminGroup", newK)
	}

	e, ok := t.AdminGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdminGroup", oldK)
	}
	e.AdminGroupName = &newK

	t.AdminGroup[newK] = e
	delete(t.AdminGroup, oldK)
	return nil
}

// GetOrCreateAdminGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetOrCreateAdminGroup(AdminGroupName string) *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {

	key := AdminGroupName

	if v, ok := t.AdminGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdminGroup(AdminGroupName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdminGroup got unexpected error: %v", err))
	}
	return v
}

// GetAdminGroup retrieves the value with the specified key from
// the AdminGroup map field of NetworkInstance_Mpls_TeGlobalAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetAdminGroup(AdminGroupName string) *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {

	if t == nil {
		return nil
	}

	key := AdminGroupName

	if lm, ok := t.AdminGroup[key]; ok {
		return lm
	}
	return nil
}

// AppendAdminGroup appends the supplied NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup struct to the
// list AdminGroup of NetworkInstance_Mpls_TeGlobalAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) AppendAdminGroup(v *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) error {
	key := *v.AdminGroupName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup)
	}

	if _, ok := t.AdminGroup[key]; ok {
		return fmt.Errorf("duplicate key for list AdminGroup %v", key)
	}

	t.AdminGroup[key] = v
	return nil
}

// NewSrlg creates a new entry in the Srlg list of the
// NetworkInstance_Mpls_TeGlobalAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) NewSrlg(Name string) (*NetworkInstance_Mpls_TeGlobalAttributes_Srlg, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlg == nil {
		t.Srlg = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Srlg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Srlg", key)
	}

	t.Srlg[key] = &NetworkInstance_Mpls_TeGlobalAttributes_Srlg{
		Name: &Name,
	}

	return t.Srlg[key], nil
}

// RenameSrlg renames an entry in the list Srlg within
// the NetworkInstance_Mpls_TeGlobalAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) RenameSrlg(oldK, newK string) error {
	if _, ok := t.Srlg[newK]; ok {
		return fmt.Errorf("key %v already exists in Srlg", newK)
	}

	e, ok := t.Srlg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Srlg", oldK)
	}
	e.Name = &newK

	t.Srlg[newK] = e
	delete(t.Srlg, oldK)
	return nil
}

// GetOrCreateSrlg retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetOrCreateSrlg(Name string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg {

	key := Name

	if v, ok := t.Srlg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrlg(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrlg got unexpected error: %v", err))
	}
	return v
}

// GetSrlg retrieves the value with the specified key from
// the Srlg map field of NetworkInstance_Mpls_TeGlobalAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetSrlg(Name string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Srlg[key]; ok {
		return lm
	}
	return nil
}

// AppendSrlg appends the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct to the
// list Srlg of NetworkInstance_Mpls_TeGlobalAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) AppendSrlg(v *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlg == nil {
		t.Srlg = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg)
	}

	if _, ok := t.Srlg[key]; ok {
		return fmt.Errorf("duplicate key for list Srlg %v", key)
	}

	t.Srlg[key] = v
	return nil
}

// GetOrCreateTeLspTimers retrieves the value of the TeLspTimers field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Mpls_TeGlobalAttributes) GetOrCreateTeLspTimers() *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	if s.TeLspTimers != nil {
		return s.TeLspTimers
	}
	s.TeLspTimers = &NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	return s.TeLspTimers
}

// GetTeLspTimers returns the value of the TeLspTimers struct pointer
// from NetworkInstance_Mpls_TeGlobalAttributes. If the receiver or the field TeLspTimers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Mpls_TeGlobalAttributes) GetTeLspTimers() *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	if s != nil && s.TeLspTimers != nil {
		return s.TeLspTimers
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_TeGlobalAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.AdminGroupName == nil {
		return nil, fmt.Errorf("nil value for key AdminGroupName")
	}

	return map[string]interface{}{
		"admin-group-name": *t.AdminGroupName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewMembersList creates a new entry in the MembersList list of the
// NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) NewMembersList(FromAddress string) (*NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MembersList == nil {
		t.MembersList = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList)
	}

	key := FromAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MembersList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MembersList", key)
	}

	t.MembersList[key] = &NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{
		FromAddress: &FromAddress,
	}

	return t.MembersList[key], nil
}

// RenameMembersList renames an entry in the list MembersList within
// the NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) RenameMembersList(oldK, newK string) error {
	if _, ok := t.MembersList[newK]; ok {
		return fmt.Errorf("key %v already exists in MembersList", newK)
	}

	e, ok := t.MembersList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MembersList", oldK)
	}
	e.FromAddress = &newK

	t.MembersList[newK] = e
	delete(t.MembersList, oldK)
	return nil
}

// GetOrCreateMembersList retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes_Srlg. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) GetOrCreateMembersList(FromAddress string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {

	key := FromAddress

	if v, ok := t.MembersList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMembersList(FromAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMembersList got unexpected error: %v", err))
	}
	return v
}

// GetMembersList retrieves the value with the specified key from
// the MembersList map field of NetworkInstance_Mpls_TeGlobalAttributes_Srlg. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) GetMembersList(FromAddress string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {

	if t == nil {
		return nil
	}

	key := FromAddress

	if lm, ok := t.MembersList[key]; ok {
		return lm
	}
	return nil
}

// AppendMembersList appends the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList struct to the
// list MembersList of NetworkInstance_Mpls_TeGlobalAttributes_Srlg. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) AppendMembersList(v *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) error {
	key := *v.FromAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MembersList == nil {
		t.MembersList = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList)
	}

	if _, ok := t.MembersList[key]; ok {
		return fmt.Errorf("duplicate key for list MembersList %v", key)
	}

	t.MembersList[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_Srlg"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FromAddress == nil {
		return nil, fmt.Errorf("nil value for key FromAddress")
	}

	return map[string]interface{}{
		"from-address": *t.FromAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_PolicyForwarding struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding) NewInterface(InterfaceId string) (*NetworkInstance_PolicyForwarding_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_PolicyForwarding_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_PolicyForwarding_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_PolicyForwarding struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding) GetOrCreateInterface(InterfaceId string) *NetworkInstance_PolicyForwarding_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_PolicyForwarding. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding) GetInterface(InterfaceId string) *NetworkInstance_PolicyForwarding_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied NetworkInstance_PolicyForwarding_Interface struct to the
// list Interface of NetworkInstance_PolicyForwarding. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding) AppendInterface(v *NetworkInstance_PolicyForwarding_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_PolicyForwarding_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewPathSelectionGroup creates a new entry in the PathSelectionGroup list of the
// NetworkInstance_PolicyForwarding struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding) NewPathSelectionGroup(GroupId string) (*NetworkInstance_PolicyForwarding_PathSelectionGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathSelectionGroup == nil {
		t.PathSelectionGroup = make(map[string]*NetworkInstance_PolicyForwarding_PathSelectionGroup)
	}

	key := GroupId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PathSelectionGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PathSelectionGroup", key)
	}

	t.PathSelectionGroup[key] = &NetworkInstance_PolicyForwarding_PathSelectionGroup{
		GroupId: &GroupId,
	}

	return t.PathSelectionGroup[key], nil
}

// RenamePathSelectionGroup renames an entry in the list PathSelectionGroup within
// the NetworkInstance_PolicyForwarding struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding) RenamePathSelectionGroup(oldK, newK string) error {
	if _, ok := t.PathSelectionGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in PathSelectionGroup", newK)
	}

	e, ok := t.PathSelectionGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PathSelectionGroup", oldK)
	}
	e.GroupId = &newK

	t.PathSelectionGroup[newK] = e
	delete(t.PathSelectionGroup, oldK)
	return nil
}

// GetOrCreatePathSelectionGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding) GetOrCreatePathSelectionGroup(GroupId string) *NetworkInstance_PolicyForwarding_PathSelectionGroup {

	key := GroupId

	if v, ok := t.PathSelectionGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPathSelectionGroup(GroupId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePathSelectionGroup got unexpected error: %v", err))
	}
	return v
}

// GetPathSelectionGroup retrieves the value with the specified key from
// the PathSelectionGroup map field of NetworkInstance_PolicyForwarding. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding) GetPathSelectionGroup(GroupId string) *NetworkInstance_PolicyForwarding_PathSelectionGroup {

	if t == nil {
		return nil
	}

	key := GroupId

	if lm, ok := t.PathSelectionGroup[key]; ok {
		return lm
	}
	return nil
}

// AppendPathSelectionGroup appends the supplied NetworkInstance_PolicyForwarding_PathSelectionGroup struct to the
// list PathSelectionGroup of NetworkInstance_PolicyForwarding. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_PathSelectionGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding) AppendPathSelectionGroup(v *NetworkInstance_PolicyForwarding_PathSelectionGroup) error {
	key := *v.GroupId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathSelectionGroup == nil {
		t.PathSelectionGroup = make(map[string]*NetworkInstance_PolicyForwarding_PathSelectionGroup)
	}

	if _, ok := t.PathSelectionGroup[key]; ok {
		return fmt.Errorf("duplicate key for list PathSelectionGroup %v", key)
	}

	t.PathSelectionGroup[key] = v
	return nil
}

// NewPolicy creates a new entry in the Policy list of the
// NetworkInstance_PolicyForwarding struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding) NewPolicy(PolicyId string) (*NetworkInstance_PolicyForwarding_Policy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*NetworkInstance_PolicyForwarding_Policy)
	}

	key := PolicyId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policy", key)
	}

	t.Policy[key] = &NetworkInstance_PolicyForwarding_Policy{
		PolicyId: &PolicyId,
	}

	return t.Policy[key], nil
}

// RenamePolicy renames an entry in the list Policy within
// the NetworkInstance_PolicyForwarding struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding) RenamePolicy(oldK, newK string) error {
	if _, ok := t.Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Policy", newK)
	}

	e, ok := t.Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policy", oldK)
	}
	e.PolicyId = &newK

	t.Policy[newK] = e
	delete(t.Policy, oldK)
	return nil
}

// GetOrCreatePolicy retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding) GetOrCreatePolicy(PolicyId string) *NetworkInstance_PolicyForwarding_Policy {

	key := PolicyId

	if v, ok := t.Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicy(PolicyId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicy got unexpected error: %v", err))
	}
	return v
}

// GetPolicy retrieves the value with the specified key from
// the Policy map field of NetworkInstance_PolicyForwarding. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding) GetPolicy(PolicyId string) *NetworkInstance_PolicyForwarding_Policy {

	if t == nil {
		return nil
	}

	key := PolicyId

	if lm, ok := t.Policy[key]; ok {
		return lm
	}
	return nil
}

// AppendPolicy appends the supplied NetworkInstance_PolicyForwarding_Policy struct to the
// list Policy of NetworkInstance_PolicyForwarding. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Policy already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding) AppendPolicy(v *NetworkInstance_PolicyForwarding_Policy) error {
	key := *v.PolicyId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*NetworkInstance_PolicyForwarding_Policy)
	}

	if _, ok := t.Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Policy %v", key)
	}

	t.Policy[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_PolicyForwarding_Interface) GetOrCreateInterfaceRef() *NetworkInstance_PolicyForwarding_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_PolicyForwarding_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_PolicyForwarding_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_PolicyForwarding_Interface) GetInterfaceRef() *NetworkInstance_PolicyForwarding_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_PathSelectionGroup struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_PathSelectionGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.GroupId == nil {
		return nil, fmt.Errorf("nil value for key GroupId")
	}

	return map[string]interface{}{
		"group-id": *t.GroupId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_PathSelectionGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_PathSelectionGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_PathSelectionGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewRule creates a new entry in the Rule list of the
// NetworkInstance_PolicyForwarding_Policy struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding_Policy) NewRule(SequenceId uint32) (*NetworkInstance_PolicyForwarding_Policy_Rule, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rule == nil {
		t.Rule = make(map[uint32]*NetworkInstance_PolicyForwarding_Policy_Rule)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Rule[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Rule", key)
	}

	t.Rule[key] = &NetworkInstance_PolicyForwarding_Policy_Rule{
		SequenceId: &SequenceId,
	}

	return t.Rule[key], nil
}

// RenameRule renames an entry in the list Rule within
// the NetworkInstance_PolicyForwarding_Policy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding_Policy) RenameRule(oldK, newK uint32) error {
	if _, ok := t.Rule[newK]; ok {
		return fmt.Errorf("key %v already exists in Rule", newK)
	}

	e, ok := t.Rule[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Rule", oldK)
	}
	e.SequenceId = &newK

	t.Rule[newK] = e
	delete(t.Rule, oldK)
	return nil
}

// GetOrCreateRule retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding_Policy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding_Policy) GetOrCreateRule(SequenceId uint32) *NetworkInstance_PolicyForwarding_Policy_Rule {

	key := SequenceId

	if v, ok := t.Rule[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRule(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRule got unexpected error: %v", err))
	}
	return v
}

// GetRule retrieves the value with the specified key from
// the Rule map field of NetworkInstance_PolicyForwarding_Policy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy) GetRule(SequenceId uint32) *NetworkInstance_PolicyForwarding_Policy_Rule {

	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Rule[key]; ok {
		return lm
	}
	return nil
}

// AppendRule appends the supplied NetworkInstance_PolicyForwarding_Policy_Rule struct to the
// list Rule of NetworkInstance_PolicyForwarding_Policy. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Policy_Rule already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding_Policy) AppendRule(v *NetworkInstance_PolicyForwarding_Policy_Rule) error {
	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rule == nil {
		t.Rule = make(map[uint32]*NetworkInstance_PolicyForwarding_Policy_Rule)
	}

	if _, ok := t.Rule[key]; ok {
		return fmt.Errorf("duplicate key for list Rule %v", key)
	}

	t.Rule[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Policy struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PolicyId == nil {
		return nil, fmt.Errorf("nil value for key PolicyId")
	}

	return map[string]interface{}{
		"policy-id": *t.PolicyId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_Policy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateAction() *NetworkInstance_PolicyForwarding_Policy_Rule_Action {
	if s.Action != nil {
		return s.Action
	}
	s.Action = &NetworkInstance_PolicyForwarding_Policy_Rule_Action{}
	return s.Action
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateIpv4() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4 {
	if s.Ipv4 != nil {
		return s.Ipv4
	}
	s.Ipv4 = &NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4{}
	return s.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateIpv6() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6 {
	if s.Ipv6 != nil {
		return s.Ipv6
	}
	s.Ipv6 = &NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6{}
	return s.Ipv6
}

// GetOrCreateL2 retrieves the value of the L2 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateL2() *NetworkInstance_PolicyForwarding_Policy_Rule_L2 {
	if s.L2 != nil {
		return s.L2
	}
	s.L2 = &NetworkInstance_PolicyForwarding_Policy_Rule_L2{}
	return s.L2
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateTransport() *NetworkInstance_PolicyForwarding_Policy_Rule_Transport {
	if s.Transport != nil {
		return s.Transport
	}
	s.Transport = &NetworkInstance_PolicyForwarding_Policy_Rule_Transport{}
	return s.Transport
}

// GetAction returns the value of the Action struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule) GetAction() *NetworkInstance_PolicyForwarding_Policy_Rule_Action {
	if s != nil && s.Action != nil {
		return s.Action
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule) GetIpv4() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4 {
	if s != nil && s.Ipv4 != nil {
		return s.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule) GetIpv6() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6 {
	if s != nil && s.Ipv6 != nil {
		return s.Ipv6
	}
	return nil
}

// GetL2 returns the value of the L2 struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field L2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule) GetL2() *NetworkInstance_PolicyForwarding_Policy_Rule_L2 {
	if s != nil && s.L2 != nil {
		return s.L2
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule) GetTransport() *NetworkInstance_PolicyForwarding_Policy_Rule_Transport {
	if s != nil && s.Transport != nil {
		return s.Transport
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Policy_Rule struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEncapsulateGre retrieves the value of the EncapsulateGre field
// or returns the existing field if it already exists.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetOrCreateEncapsulateGre() *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre {
	if s.EncapsulateGre != nil {
		return s.EncapsulateGre
	}
	s.EncapsulateGre = &NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre{}
	return s.EncapsulateGre
}

// GetEncapsulateGre returns the value of the EncapsulateGre struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule_Action. If the receiver or the field EncapsulateGre is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetEncapsulateGre() *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre {
	if s != nil && s.EncapsulateGre != nil {
		return s.EncapsulateGre
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule_Action) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Action"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTarget creates a new entry in the Target list of the
// NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) NewTarget(Id string) (*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Target[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Target", key)
	}

	t.Target[key] = &NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target{
		Id: &Id,
	}

	return t.Target[key], nil
}

// RenameTarget renames an entry in the list Target within
// the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) RenameTarget(oldK, newK string) error {
	if _, ok := t.Target[newK]; ok {
		return fmt.Errorf("key %v already exists in Target", newK)
	}

	e, ok := t.Target[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Target", oldK)
	}
	e.Id = &newK

	t.Target[newK] = e
	delete(t.Target, oldK)
	return nil
}

// GetOrCreateTarget retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) GetOrCreateTarget(Id string) *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target {

	key := Id

	if v, ok := t.Target[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTarget(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTarget got unexpected error: %v", err))
	}
	return v
}

// GetTarget retrieves the value with the specified key from
// the Target map field of NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) GetTarget(Id string) *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Target[key]; ok {
		return lm
	}
	return nil
}

// AppendTarget appends the supplied NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target struct to the
// list Target of NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) AppendTarget(v *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target)
	}

	if _, ok := t.Target[key]; ok {
		return fmt.Errorf("duplicate key for list Target %v", key)
	}

	t.Target[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule_L2) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_L2"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Transport"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAggregate creates a new entry in the Aggregate list of the
// NetworkInstance_Protocol struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol) NewAggregate(Prefix string) (*NetworkInstance_Protocol_Aggregate, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aggregate == nil {
		t.Aggregate = make(map[string]*NetworkInstance_Protocol_Aggregate)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Aggregate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Aggregate", key)
	}

	t.Aggregate[key] = &NetworkInstance_Protocol_Aggregate{
		Prefix: &Prefix,
	}

	return t.Aggregate[key], nil
}

// RenameAggregate renames an entry in the list Aggregate within
// the NetworkInstance_Protocol struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol) RenameAggregate(oldK, newK string) error {
	if _, ok := t.Aggregate[newK]; ok {
		return fmt.Errorf("key %v already exists in Aggregate", newK)
	}

	e, ok := t.Aggregate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Aggregate", oldK)
	}
	e.Prefix = &newK

	t.Aggregate[newK] = e
	delete(t.Aggregate, oldK)
	return nil
}

// GetOrCreateAggregate retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol) GetOrCreateAggregate(Prefix string) *NetworkInstance_Protocol_Aggregate {

	key := Prefix

	if v, ok := t.Aggregate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAggregate(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAggregate got unexpected error: %v", err))
	}
	return v
}

// GetAggregate retrieves the value with the specified key from
// the Aggregate map field of NetworkInstance_Protocol. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol) GetAggregate(Prefix string) *NetworkInstance_Protocol_Aggregate {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Aggregate[key]; ok {
		return lm
	}
	return nil
}

// AppendAggregate appends the supplied NetworkInstance_Protocol_Aggregate struct to the
// list Aggregate of NetworkInstance_Protocol. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Aggregate already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol) AppendAggregate(v *NetworkInstance_Protocol_Aggregate) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aggregate == nil {
		t.Aggregate = make(map[string]*NetworkInstance_Protocol_Aggregate)
	}

	if _, ok := t.Aggregate[key]; ok {
		return fmt.Errorf("duplicate key for list Aggregate %v", key)
	}

	t.Aggregate[key] = v
	return nil
}

// NewStatic creates a new entry in the Static list of the
// NetworkInstance_Protocol struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol) NewStatic(Prefix string) (*NetworkInstance_Protocol_Static, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*NetworkInstance_Protocol_Static)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Static[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Static", key)
	}

	t.Static[key] = &NetworkInstance_Protocol_Static{
		Prefix: &Prefix,
	}

	return t.Static[key], nil
}

// RenameStatic renames an entry in the list Static within
// the NetworkInstance_Protocol struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol) RenameStatic(oldK, newK string) error {
	if _, ok := t.Static[newK]; ok {
		return fmt.Errorf("key %v already exists in Static", newK)
	}

	e, ok := t.Static[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Static", oldK)
	}
	e.Prefix = &newK

	t.Static[newK] = e
	delete(t.Static, oldK)
	return nil
}

// GetOrCreateStatic retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol) GetOrCreateStatic(Prefix string) *NetworkInstance_Protocol_Static {

	key := Prefix

	if v, ok := t.Static[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStatic(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStatic got unexpected error: %v", err))
	}
	return v
}

// GetStatic retrieves the value with the specified key from
// the Static map field of NetworkInstance_Protocol. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol) GetStatic(Prefix string) *NetworkInstance_Protocol_Static {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Static[key]; ok {
		return lm
	}
	return nil
}

// AppendStatic appends the supplied NetworkInstance_Protocol_Static struct to the
// list Static of NetworkInstance_Protocol. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Static already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol) AppendStatic(v *NetworkInstance_Protocol_Static) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*NetworkInstance_Protocol_Static)
	}

	if _, ok := t.Static[key]; ok {
		return fmt.Errorf("duplicate key for list Static %v", key)
	}

	t.Static[key] = v
	return nil
}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol) GetOrCreateBgp() *NetworkInstance_Protocol_Bgp {
	if s.Bgp != nil {
		return s.Bgp
	}
	s.Bgp = &NetworkInstance_Protocol_Bgp{}
	return s.Bgp
}

// GetOrCreateIsis retrieves the value of the Isis field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol) GetOrCreateIsis() *NetworkInstance_Protocol_Isis {
	if s.Isis != nil {
		return s.Isis
	}
	s.Isis = &NetworkInstance_Protocol_Isis{}
	return s.Isis
}

// GetOrCreateOspfv2 retrieves the value of the Ospfv2 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol) GetOrCreateOspfv2() *NetworkInstance_Protocol_Ospfv2 {
	if s.Ospfv2 != nil {
		return s.Ospfv2
	}
	s.Ospfv2 = &NetworkInstance_Protocol_Ospfv2{}
	return s.Ospfv2
}

// GetBgp returns the value of the Bgp struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol) GetBgp() *NetworkInstance_Protocol_Bgp {
	if s != nil && s.Bgp != nil {
		return s.Bgp
	}
	return nil
}

// GetIsis returns the value of the Isis struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Isis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol) GetIsis() *NetworkInstance_Protocol_Isis {
	if s != nil && s.Isis != nil {
		return s.Isis
	}
	return nil
}

// GetOspfv2 returns the value of the Ospfv2 struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Ospfv2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol) GetOspfv2() *NetworkInstance_Protocol_Ospfv2 {
	if s != nil && s.Ospfv2 != nil {
		return s.Ospfv2
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol) ΛListKeyMap() (map[string]interface{}, error) {

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"identifier": t.Identifier,
		"name":       *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Aggregate struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Aggregate) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Aggregate) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Aggregate"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Aggregate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp) NewNeighbor(NeighborAddress string) (*NetworkInstance_Protocol_Bgp_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Bgp_Neighbor)
	}

	key := NeighborAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Bgp_Neighbor{
		NeighborAddress: &NeighborAddress,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.NeighborAddress = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp) GetOrCreateNeighbor(NeighborAddress string) *NetworkInstance_Protocol_Bgp_Neighbor {

	key := NeighborAddress

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(NeighborAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp) GetNeighbor(NeighborAddress string) *NetworkInstance_Protocol_Bgp_Neighbor {

	if t == nil {
		return nil
	}

	key := NeighborAddress

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Bgp_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Bgp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp) AppendNeighbor(v *NetworkInstance_Protocol_Bgp_Neighbor) error {
	key := *v.NeighborAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Bgp_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// NewPeerGroup creates a new entry in the PeerGroup list of the
// NetworkInstance_Protocol_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp) NewPeerGroup(PeerGroupName string) (*NetworkInstance_Protocol_Bgp_PeerGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PeerGroup == nil {
		t.PeerGroup = make(map[string]*NetworkInstance_Protocol_Bgp_PeerGroup)
	}

	key := PeerGroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PeerGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PeerGroup", key)
	}

	t.PeerGroup[key] = &NetworkInstance_Protocol_Bgp_PeerGroup{
		PeerGroupName: &PeerGroupName,
	}

	return t.PeerGroup[key], nil
}

// RenamePeerGroup renames an entry in the list PeerGroup within
// the NetworkInstance_Protocol_Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp) RenamePeerGroup(oldK, newK string) error {
	if _, ok := t.PeerGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in PeerGroup", newK)
	}

	e, ok := t.PeerGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PeerGroup", oldK)
	}
	e.PeerGroupName = &newK

	t.PeerGroup[newK] = e
	delete(t.PeerGroup, oldK)
	return nil
}

// GetOrCreatePeerGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp) GetOrCreatePeerGroup(PeerGroupName string) *NetworkInstance_Protocol_Bgp_PeerGroup {

	key := PeerGroupName

	if v, ok := t.PeerGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPeerGroup(PeerGroupName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePeerGroup got unexpected error: %v", err))
	}
	return v
}

// GetPeerGroup retrieves the value with the specified key from
// the PeerGroup map field of NetworkInstance_Protocol_Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp) GetPeerGroup(PeerGroupName string) *NetworkInstance_Protocol_Bgp_PeerGroup {

	if t == nil {
		return nil
	}

	key := PeerGroupName

	if lm, ok := t.PeerGroup[key]; ok {
		return lm
	}
	return nil
}

// AppendPeerGroup appends the supplied NetworkInstance_Protocol_Bgp_PeerGroup struct to the
// list PeerGroup of NetworkInstance_Protocol_Bgp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_PeerGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp) AppendPeerGroup(v *NetworkInstance_Protocol_Bgp_PeerGroup) error {
	key := *v.PeerGroupName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PeerGroup == nil {
		t.PeerGroup = make(map[string]*NetworkInstance_Protocol_Bgp_PeerGroup)
	}

	if _, ok := t.PeerGroup[key]; ok {
		return fmt.Errorf("duplicate key for list PeerGroup %v", key)
	}

	t.PeerGroup[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp) GetOrCreateGlobal() *NetworkInstance_Protocol_Bgp_Global {
	if s.Global != nil {
		return s.Global
	}
	s.Global = &NetworkInstance_Protocol_Bgp_Global{}
	return s.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Protocol_Bgp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp) GetGlobal() *NetworkInstance_Protocol_Bgp_Global {
	if s != nil && s.Global != nil {
		return s.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAfiSafi creates a new entry in the AfiSafi list of the
// NetworkInstance_Protocol_Bgp_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp_Global) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*NetworkInstance_Protocol_Bgp_Global_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_Global_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &NetworkInstance_Protocol_Bgp_Global_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the NetworkInstance_Protocol_Bgp_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp_Global) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_Global_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of NetworkInstance_Protocol_Bgp_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_Global_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// AppendAfiSafi appends the supplied NetworkInstance_Protocol_Bgp_Global_AfiSafi struct to the
// list AfiSafi of NetworkInstance_Protocol_Bgp_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_Global_AfiSafi already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp_Global) AppendAfiSafi(v *NetworkInstance_Protocol_Bgp_Global_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_Global_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// NewDynamicNeighborPrefix creates a new entry in the DynamicNeighborPrefix list of the
// NetworkInstance_Protocol_Bgp_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp_Global) NewDynamicNeighborPrefix(Prefix string) (*NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DynamicNeighborPrefix == nil {
		t.DynamicNeighborPrefix = make(map[string]*NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DynamicNeighborPrefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DynamicNeighborPrefix", key)
	}

	t.DynamicNeighborPrefix[key] = &NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix{
		Prefix: &Prefix,
	}

	return t.DynamicNeighborPrefix[key], nil
}

// RenameDynamicNeighborPrefix renames an entry in the list DynamicNeighborPrefix within
// the NetworkInstance_Protocol_Bgp_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp_Global) RenameDynamicNeighborPrefix(oldK, newK string) error {
	if _, ok := t.DynamicNeighborPrefix[newK]; ok {
		return fmt.Errorf("key %v already exists in DynamicNeighborPrefix", newK)
	}

	e, ok := t.DynamicNeighborPrefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DynamicNeighborPrefix", oldK)
	}
	e.Prefix = &newK

	t.DynamicNeighborPrefix[newK] = e
	delete(t.DynamicNeighborPrefix, oldK)
	return nil
}

// GetOrCreateDynamicNeighborPrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateDynamicNeighborPrefix(Prefix string) *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix {

	key := Prefix

	if v, ok := t.DynamicNeighborPrefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDynamicNeighborPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDynamicNeighborPrefix got unexpected error: %v", err))
	}
	return v
}

// GetDynamicNeighborPrefix retrieves the value with the specified key from
// the DynamicNeighborPrefix map field of NetworkInstance_Protocol_Bgp_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetDynamicNeighborPrefix(Prefix string) *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.DynamicNeighborPrefix[key]; ok {
		return lm
	}
	return nil
}

// AppendDynamicNeighborPrefix appends the supplied NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix struct to the
// list DynamicNeighborPrefix of NetworkInstance_Protocol_Bgp_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp_Global) AppendDynamicNeighborPrefix(v *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DynamicNeighborPrefix == nil {
		t.DynamicNeighborPrefix = make(map[string]*NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix)
	}

	if _, ok := t.DynamicNeighborPrefix[key]; ok {
		return fmt.Errorf("duplicate key for list DynamicNeighborPrefix %v", key)
	}

	t.DynamicNeighborPrefix[key] = v
	return nil
}

// GetOrCreateConfederation retrieves the value of the Confederation field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global) GetOrCreateConfederation() *NetworkInstance_Protocol_Bgp_Global_Confederation {
	if s.Confederation != nil {
		return s.Confederation
	}
	s.Confederation = &NetworkInstance_Protocol_Bgp_Global_Confederation{}
	return s.Confederation
}

// GetOrCreateDefaultRouteDistance retrieves the value of the DefaultRouteDistance field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global) GetOrCreateDefaultRouteDistance() *NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance {
	if s.DefaultRouteDistance != nil {
		return s.DefaultRouteDistance
	}
	s.DefaultRouteDistance = &NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance{}
	return s.DefaultRouteDistance
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &NetworkInstance_Protocol_Bgp_Global_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateRouteSelectionOptions retrieves the value of the RouteSelectionOptions field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global) GetOrCreateRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions {
	if s.RouteSelectionOptions != nil {
		return s.RouteSelectionOptions
	}
	s.RouteSelectionOptions = &NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions{}
	return s.RouteSelectionOptions
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetConfederation returns the value of the Confederation struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field Confederation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global) GetConfederation() *NetworkInstance_Protocol_Bgp_Global_Confederation {
	if s != nil && s.Confederation != nil {
		return s.Confederation
	}
	return nil
}

// GetDefaultRouteDistance returns the value of the DefaultRouteDistance struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field DefaultRouteDistance is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global) GetDefaultRouteDistance() *NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance {
	if s != nil && s.DefaultRouteDistance != nil {
		return s.DefaultRouteDistance
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetRouteSelectionOptions returns the value of the RouteSelectionOptions struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field RouteSelectionOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global) GetRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions {
	if s != nil && s.RouteSelectionOptions != nil {
		return s.RouteSelectionOptions
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateAddPaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths {
	if s.AddPaths != nil {
		return s.AddPaths
	}
	s.AddPaths = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths{}
	return s.AddPaths
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast {
	if s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	s.Ipv4LabeledUnicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast{}
	return s.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast {
	if s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	s.Ipv4Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast{}
	return s.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast {
	if s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	s.Ipv6LabeledUnicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast{}
	return s.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast {
	if s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	s.Ipv6Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast{}
	return s.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL2VpnEvpn() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn {
	if s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	s.L2VpnEvpn = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn{}
	return s.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL2VpnVpls() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls {
	if s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	s.L2VpnVpls = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls{}
	return s.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast {
	if s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	s.L3VpnIpv4Multicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast{}
	return s.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast {
	if s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	s.L3VpnIpv4Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast{}
	return s.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast {
	if s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	s.L3VpnIpv6Multicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast{}
	return s.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast {
	if s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	s.L3VpnIpv6Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast{}
	return s.L3VpnIpv6Unicast
}

// GetOrCreateRouteSelectionOptions retrieves the value of the RouteSelectionOptions field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions {
	if s.RouteSelectionOptions != nil {
		return s.RouteSelectionOptions
	}
	s.RouteSelectionOptions = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions{}
	return s.RouteSelectionOptions
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4 {
	if s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	s.SrtePolicyIpv4 = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4{}
	return s.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6 {
	if s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	s.SrtePolicyIpv6 = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6{}
	return s.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetAddPaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths {
	if s != nil && s.AddPaths != nil {
		return s.AddPaths
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast {
	if s != nil && s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast {
	if s != nil && s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast {
	if s != nil && s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast {
	if s != nil && s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL2VpnEvpn() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn {
	if s != nil && s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL2VpnVpls() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls {
	if s != nil && s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast {
	if s != nil && s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast {
	if s != nil && s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast {
	if s != nil && s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast {
	if s != nil && s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	return nil
}

// GetRouteSelectionOptions returns the value of the RouteSelectionOptions struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field RouteSelectionOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions {
	if s != nil && s.RouteSelectionOptions != nil {
		return s.RouteSelectionOptions
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4 {
	if s != nil && s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6 {
	if s != nil && s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_Global_AfiSafi struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) GetOrCreateIbgp() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp {
	if s.Ibgp != nil {
		return s.Ibgp
	}
	s.Ibgp = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp{}
	return s.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) GetIbgp() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp {
	if s != nil && s.Ibgp != nil {
		return s.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_Confederation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_Confederation"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_Confederation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) GetOrCreateIbgp() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp {
	if s.Ibgp != nil {
		return s.Ibgp
	}
	s.Ibgp = &NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp{}
	return s.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) GetIbgp() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp {
	if s != nil && s.Ibgp != nil {
		return s.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAfiSafi creates a new entry in the AfiSafi list of the
// NetworkInstance_Protocol_Bgp_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the NetworkInstance_Protocol_Bgp_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of NetworkInstance_Protocol_Bgp_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// AppendAfiSafi appends the supplied NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi struct to the
// list AfiSafi of NetworkInstance_Protocol_Bgp_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) AppendAfiSafi(v *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateApplyPolicy() *NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy {
	if s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	s.ApplyPolicy = &NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy{}
	return s.ApplyPolicy
}

// GetOrCreateAsPathOptions retrieves the value of the AsPathOptions field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateAsPathOptions() *NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions {
	if s.AsPathOptions != nil {
		return s.AsPathOptions
	}
	s.AsPathOptions = &NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions{}
	return s.AsPathOptions
}

// GetOrCreateEbgpMultihop retrieves the value of the EbgpMultihop field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateEbgpMultihop() *NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop {
	if s.EbgpMultihop != nil {
		return s.EbgpMultihop
	}
	s.EbgpMultihop = &NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop{}
	return s.EbgpMultihop
}

// GetOrCreateErrorHandling retrieves the value of the ErrorHandling field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateErrorHandling() *NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling {
	if s.ErrorHandling != nil {
		return s.ErrorHandling
	}
	s.ErrorHandling = &NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling{}
	return s.ErrorHandling
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateLoggingOptions retrieves the value of the LoggingOptions field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateLoggingOptions() *NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions {
	if s.LoggingOptions != nil {
		return s.LoggingOptions
	}
	s.LoggingOptions = &NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions{}
	return s.LoggingOptions
}

// GetOrCreateMessages retrieves the value of the Messages field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateMessages() *NetworkInstance_Protocol_Bgp_Neighbor_Messages {
	if s.Messages != nil {
		return s.Messages
	}
	s.Messages = &NetworkInstance_Protocol_Bgp_Neighbor_Messages{}
	return s.Messages
}

// GetOrCreateQueues retrieves the value of the Queues field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateQueues() *NetworkInstance_Protocol_Bgp_Neighbor_Queues {
	if s.Queues != nil {
		return s.Queues
	}
	s.Queues = &NetworkInstance_Protocol_Bgp_Neighbor_Queues{}
	return s.Queues
}

// GetOrCreateRouteReflector retrieves the value of the RouteReflector field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateRouteReflector() *NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector {
	if s.RouteReflector != nil {
		return s.RouteReflector
	}
	s.RouteReflector = &NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector{}
	return s.RouteReflector
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateTimers() *NetworkInstance_Protocol_Bgp_Neighbor_Timers {
	if s.Timers != nil {
		return s.Timers
	}
	s.Timers = &NetworkInstance_Protocol_Bgp_Neighbor_Timers{}
	return s.Timers
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateTransport() *NetworkInstance_Protocol_Bgp_Neighbor_Transport {
	if s.Transport != nil {
		return s.Transport
	}
	s.Transport = &NetworkInstance_Protocol_Bgp_Neighbor_Transport{}
	return s.Transport
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetApplyPolicy() *NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy {
	if s != nil && s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	return nil
}

// GetAsPathOptions returns the value of the AsPathOptions struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field AsPathOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetAsPathOptions() *NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions {
	if s != nil && s.AsPathOptions != nil {
		return s.AsPathOptions
	}
	return nil
}

// GetEbgpMultihop returns the value of the EbgpMultihop struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field EbgpMultihop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetEbgpMultihop() *NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop {
	if s != nil && s.EbgpMultihop != nil {
		return s.EbgpMultihop
	}
	return nil
}

// GetErrorHandling returns the value of the ErrorHandling struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field ErrorHandling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetErrorHandling() *NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling {
	if s != nil && s.ErrorHandling != nil {
		return s.ErrorHandling
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetLoggingOptions returns the value of the LoggingOptions struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field LoggingOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetLoggingOptions() *NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions {
	if s != nil && s.LoggingOptions != nil {
		return s.LoggingOptions
	}
	return nil
}

// GetMessages returns the value of the Messages struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field Messages is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetMessages() *NetworkInstance_Protocol_Bgp_Neighbor_Messages {
	if s != nil && s.Messages != nil {
		return s.Messages
	}
	return nil
}

// GetQueues returns the value of the Queues struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field Queues is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetQueues() *NetworkInstance_Protocol_Bgp_Neighbor_Queues {
	if s != nil && s.Queues != nil {
		return s.Queues
	}
	return nil
}

// GetRouteReflector returns the value of the RouteReflector struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field RouteReflector is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetRouteReflector() *NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector {
	if s != nil && s.RouteReflector != nil {
		return s.RouteReflector
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetTimers() *NetworkInstance_Protocol_Bgp_Neighbor_Timers {
	if s != nil && s.Timers != nil {
		return s.Timers
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetTransport() *NetworkInstance_Protocol_Bgp_Neighbor_Transport {
	if s != nil && s.Transport != nil {
		return s.Transport
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NeighborAddress == nil {
		return nil, fmt.Errorf("nil value for key NeighborAddress")
	}

	return map[string]interface{}{
		"neighbor-address": *t.NeighborAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateAddPaths() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths {
	if s.AddPaths != nil {
		return s.AddPaths
	}
	s.AddPaths = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths{}
	return s.AddPaths
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateApplyPolicy() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy {
	if s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	s.ApplyPolicy = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy{}
	return s.ApplyPolicy
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast {
	if s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	s.Ipv4LabeledUnicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast{}
	return s.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateIpv4Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast {
	if s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	s.Ipv4Unicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast{}
	return s.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast {
	if s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	s.Ipv6LabeledUnicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast{}
	return s.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateIpv6Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast {
	if s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	s.Ipv6Unicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast{}
	return s.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL2VpnEvpn() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn {
	if s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	s.L2VpnEvpn = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn{}
	return s.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL2VpnVpls() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls {
	if s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	s.L2VpnVpls = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls{}
	return s.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast {
	if s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	s.L3VpnIpv4Multicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast{}
	return s.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast {
	if s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	s.L3VpnIpv4Unicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast{}
	return s.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast {
	if s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	s.L3VpnIpv6Multicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast{}
	return s.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast {
	if s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	s.L3VpnIpv6Unicast = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast{}
	return s.L3VpnIpv6Unicast
}

// GetOrCreatePrefixes retrieves the value of the Prefixes field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreatePrefixes() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes {
	if s.Prefixes != nil {
		return s.Prefixes
	}
	s.Prefixes = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes{}
	return s.Prefixes
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4 {
	if s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	s.SrtePolicyIpv4 = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4{}
	return s.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6 {
	if s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	s.SrtePolicyIpv6 = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6{}
	return s.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetAddPaths() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths {
	if s != nil && s.AddPaths != nil {
		return s.AddPaths
	}
	return nil
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetApplyPolicy() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy {
	if s != nil && s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast {
	if s != nil && s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetIpv4Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast {
	if s != nil && s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast {
	if s != nil && s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetIpv6Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast {
	if s != nil && s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL2VpnEvpn() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn {
	if s != nil && s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL2VpnVpls() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls {
	if s != nil && s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast {
	if s != nil && s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast {
	if s != nil && s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast {
	if s != nil && s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast {
	if s != nil && s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	return nil
}

// GetPrefixes returns the value of the Prefixes struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field Prefixes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetPrefixes() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes {
	if s != nil && s.Prefixes != nil {
		return s.Prefixes
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4 {
	if s != nil && s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6 {
	if s != nil && s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_Prefixes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_AsPathOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_EbgpMultihop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_ErrorHandling) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_LoggingOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateReceived retrieves the value of the Received field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_Messages) GetOrCreateReceived() *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received {
	if s.Received != nil {
		return s.Received
	}
	s.Received = &NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received{}
	return s.Received
}

// GetOrCreateSent retrieves the value of the Sent field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_Messages) GetOrCreateSent() *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent {
	if s.Sent != nil {
		return s.Sent
	}
	s.Sent = &NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent{}
	return s.Sent
}

// GetReceived returns the value of the Received struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_Messages. If the receiver or the field Received is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_Messages) GetReceived() *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received {
	if s != nil && s.Received != nil {
		return s.Received
	}
	return nil
}

// GetSent returns the value of the Sent struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_Messages. If the receiver or the field Sent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_Messages) GetSent() *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent {
	if s != nil && s.Sent != nil {
		return s.Sent
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_Messages) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Messages"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Received) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Messages_Sent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_Queues) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Queues"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Queues) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Timers"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_Transport"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_Transport) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAfiSafi creates a new entry in the AfiSafi list of the
// NetworkInstance_Protocol_Bgp_PeerGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) NewAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) (*NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the NetworkInstance_Protocol_Bgp_PeerGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) RenameAfiSafi(oldK, newK E_OpenconfigBgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_PeerGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) GetAfiSafi(AfiSafiName E_OpenconfigBgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// AppendAfiSafi appends the supplied NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi struct to the
// list AfiSafi of NetworkInstance_Protocol_Bgp_PeerGroup. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) AppendAfiSafi(v *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_OpenconfigBgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateApplyPolicy() *NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy {
	if s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	s.ApplyPolicy = &NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy{}
	return s.ApplyPolicy
}

// GetOrCreateAsPathOptions retrieves the value of the AsPathOptions field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateAsPathOptions() *NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions {
	if s.AsPathOptions != nil {
		return s.AsPathOptions
	}
	s.AsPathOptions = &NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions{}
	return s.AsPathOptions
}

// GetOrCreateEbgpMultihop retrieves the value of the EbgpMultihop field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateEbgpMultihop() *NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop {
	if s.EbgpMultihop != nil {
		return s.EbgpMultihop
	}
	s.EbgpMultihop = &NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop{}
	return s.EbgpMultihop
}

// GetOrCreateErrorHandling retrieves the value of the ErrorHandling field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateErrorHandling() *NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling {
	if s.ErrorHandling != nil {
		return s.ErrorHandling
	}
	s.ErrorHandling = &NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling{}
	return s.ErrorHandling
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateLoggingOptions retrieves the value of the LoggingOptions field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateLoggingOptions() *NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions {
	if s.LoggingOptions != nil {
		return s.LoggingOptions
	}
	s.LoggingOptions = &NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions{}
	return s.LoggingOptions
}

// GetOrCreateRouteReflector retrieves the value of the RouteReflector field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateRouteReflector() *NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector {
	if s.RouteReflector != nil {
		return s.RouteReflector
	}
	s.RouteReflector = &NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector{}
	return s.RouteReflector
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateTimers() *NetworkInstance_Protocol_Bgp_PeerGroup_Timers {
	if s.Timers != nil {
		return s.Timers
	}
	s.Timers = &NetworkInstance_Protocol_Bgp_PeerGroup_Timers{}
	return s.Timers
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateTransport() *NetworkInstance_Protocol_Bgp_PeerGroup_Transport {
	if s.Transport != nil {
		return s.Transport
	}
	s.Transport = &NetworkInstance_Protocol_Bgp_PeerGroup_Transport{}
	return s.Transport
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetApplyPolicy() *NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy {
	if s != nil && s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	return nil
}

// GetAsPathOptions returns the value of the AsPathOptions struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field AsPathOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetAsPathOptions() *NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions {
	if s != nil && s.AsPathOptions != nil {
		return s.AsPathOptions
	}
	return nil
}

// GetEbgpMultihop returns the value of the EbgpMultihop struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field EbgpMultihop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetEbgpMultihop() *NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop {
	if s != nil && s.EbgpMultihop != nil {
		return s.EbgpMultihop
	}
	return nil
}

// GetErrorHandling returns the value of the ErrorHandling struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field ErrorHandling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetErrorHandling() *NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling {
	if s != nil && s.ErrorHandling != nil {
		return s.ErrorHandling
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetLoggingOptions returns the value of the LoggingOptions struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field LoggingOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetLoggingOptions() *NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions {
	if s != nil && s.LoggingOptions != nil {
		return s.LoggingOptions
	}
	return nil
}

// GetRouteReflector returns the value of the RouteReflector struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field RouteReflector is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetRouteReflector() *NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector {
	if s != nil && s.RouteReflector != nil {
		return s.RouteReflector
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetTimers() *NetworkInstance_Protocol_Bgp_PeerGroup_Timers {
	if s != nil && s.Timers != nil {
		return s.Timers
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetTransport() *NetworkInstance_Protocol_Bgp_PeerGroup_Transport {
	if s != nil && s.Transport != nil {
		return s.Transport
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_PeerGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PeerGroupName == nil {
		return nil, fmt.Errorf("nil value for key PeerGroupName")
	}

	return map[string]interface{}{
		"peer-group-name": *t.PeerGroupName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateAddPaths() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths {
	if s.AddPaths != nil {
		return s.AddPaths
	}
	s.AddPaths = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths{}
	return s.AddPaths
}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateApplyPolicy() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy {
	if s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	s.ApplyPolicy = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy{}
	return s.ApplyPolicy
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast {
	if s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	s.Ipv4LabeledUnicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast{}
	return s.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateIpv4Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast {
	if s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	s.Ipv4Unicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast{}
	return s.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast {
	if s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	s.Ipv6LabeledUnicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast{}
	return s.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateIpv6Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast {
	if s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	s.Ipv6Unicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast{}
	return s.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL2VpnEvpn() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn {
	if s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	s.L2VpnEvpn = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn{}
	return s.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL2VpnVpls() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls {
	if s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	s.L2VpnVpls = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls{}
	return s.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast {
	if s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	s.L3VpnIpv4Multicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast{}
	return s.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast {
	if s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	s.L3VpnIpv4Unicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast{}
	return s.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast {
	if s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	s.L3VpnIpv6Multicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast{}
	return s.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast {
	if s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	s.L3VpnIpv6Unicast = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast{}
	return s.L3VpnIpv6Unicast
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4 {
	if s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	s.SrtePolicyIpv4 = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4{}
	return s.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6 {
	if s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	s.SrtePolicyIpv6 = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6{}
	return s.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths {
	if s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	s.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths{}
	return s.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetAddPaths() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths {
	if s != nil && s.AddPaths != nil {
		return s.AddPaths
	}
	return nil
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetApplyPolicy() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy {
	if s != nil && s.ApplyPolicy != nil {
		return s.ApplyPolicy
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast {
	if s != nil && s.Ipv4LabeledUnicast != nil {
		return s.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetIpv4Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast {
	if s != nil && s.Ipv4Unicast != nil {
		return s.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast {
	if s != nil && s.Ipv6LabeledUnicast != nil {
		return s.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetIpv6Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast {
	if s != nil && s.Ipv6Unicast != nil {
		return s.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL2VpnEvpn() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn {
	if s != nil && s.L2VpnEvpn != nil {
		return s.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL2VpnVpls() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls {
	if s != nil && s.L2VpnVpls != nil {
		return s.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast {
	if s != nil && s.L3VpnIpv4Multicast != nil {
		return s.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast {
	if s != nil && s.L3VpnIpv4Unicast != nil {
		return s.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast {
	if s != nil && s.L3VpnIpv6Multicast != nil {
		return s.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast {
	if s != nil && s.L3VpnIpv6Unicast != nil {
		return s.L3VpnIpv6Unicast
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4 {
	if s != nil && s.SrtePolicyIpv4 != nil {
		return s.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6 {
	if s != nil && s.SrtePolicyIpv6 != nil {
		return s.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths {
	if s != nil && s.UseMultiplePaths != nil {
		return s.UseMultiplePaths
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_L3VpnIpv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv4_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	s.PrefixLimit = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit{}
	return s.PrefixLimit
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit {
	if s != nil && s.PrefixLimit != nil {
		return s.PrefixLimit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_SrtePolicyIpv6_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetOrCreateIbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp {
	if s.Ibgp != nil {
		return s.Ibgp
	}
	s.Ibgp = &NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp{}
	return s.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) GetIbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp {
	if s != nil && s.Ibgp != nil {
		return s.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AfiSafi_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_AsPathOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_EbgpMultihop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_ErrorHandling) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_LoggingOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_Timers"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_Transport"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_Transport) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEbgp retrieves the value of the Ebgp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) GetOrCreateEbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp {
	if s.Ebgp != nil {
		return s.Ebgp
	}
	s.Ebgp = &NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp{}
	return s.Ebgp
}

// GetOrCreateIbgp retrieves the value of the Ibgp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) GetOrCreateIbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp {
	if s.Ibgp != nil {
		return s.Ibgp
	}
	s.Ibgp = &NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp{}
	return s.Ibgp
}

// GetEbgp returns the value of the Ebgp struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths. If the receiver or the field Ebgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) GetEbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp {
	if s != nil && s.Ebgp != nil {
		return s.Ebgp
	}
	return nil
}

// GetIbgp returns the value of the Ibgp struct pointer
// from NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths. If the receiver or the field Ibgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) GetIbgp() *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp {
	if s != nil && s.Ibgp != nil {
		return s.Ibgp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ebgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_UseMultiplePaths_Ibgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Protocol_Isis struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis) NewInterface(InterfaceId string) (*NetworkInstance_Protocol_Isis_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Isis_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Protocol_Isis_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Protocol_Isis struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Protocol_Isis_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Protocol_Isis. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis) GetInterface(InterfaceId string) *NetworkInstance_Protocol_Isis_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied NetworkInstance_Protocol_Isis_Interface struct to the
// list Interface of NetworkInstance_Protocol_Isis. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis) AppendInterface(v *NetworkInstance_Protocol_Isis_Interface) error {
	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Isis_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewLevel creates a new entry in the Level list of the
// NetworkInstance_Protocol_Isis struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis) NewLevel(LevelNumber uint8) (*NetworkInstance_Protocol_Isis_Level, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Level)
	}

	key := LevelNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Level[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Level", key)
	}

	t.Level[key] = &NetworkInstance_Protocol_Isis_Level{
		LevelNumber: &LevelNumber,
	}

	return t.Level[key], nil
}

// RenameLevel renames an entry in the list Level within
// the NetworkInstance_Protocol_Isis struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis) RenameLevel(oldK, newK uint8) error {
	if _, ok := t.Level[newK]; ok {
		return fmt.Errorf("key %v already exists in Level", newK)
	}

	e, ok := t.Level[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Level", oldK)
	}
	e.LevelNumber = &newK

	t.Level[newK] = e
	delete(t.Level, oldK)
	return nil
}

// GetOrCreateLevel retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis) GetOrCreateLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Level {

	key := LevelNumber

	if v, ok := t.Level[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLevel(LevelNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLevel got unexpected error: %v", err))
	}
	return v
}

// GetLevel retrieves the value with the specified key from
// the Level map field of NetworkInstance_Protocol_Isis. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis) GetLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Level {

	if t == nil {
		return nil
	}

	key := LevelNumber

	if lm, ok := t.Level[key]; ok {
		return lm
	}
	return nil
}

// AppendLevel appends the supplied NetworkInstance_Protocol_Isis_Level struct to the
// list Level of NetworkInstance_Protocol_Isis. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis) AppendLevel(v *NetworkInstance_Protocol_Isis_Level) error {
	key := *v.LevelNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Level)
	}

	if _, ok := t.Level[key]; ok {
		return fmt.Errorf("duplicate key for list Level %v", key)
	}

	t.Level[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis) GetOrCreateGlobal() *NetworkInstance_Protocol_Isis_Global {
	if s.Global != nil {
		return s.Global
	}
	s.Global = &NetworkInstance_Protocol_Isis_Global{}
	return s.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Protocol_Isis. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis) GetGlobal() *NetworkInstance_Protocol_Isis_Global {
	if s != nil && s.Global != nil {
		return s.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAf creates a new entry in the Af list of the
// NetworkInstance_Protocol_Isis_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Global) NewAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) (*NetworkInstance_Protocol_Isis_Global_Af, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Global_Af_Key]*NetworkInstance_Protocol_Isis_Global_Af)
	}

	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Af[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Af", key)
	}

	t.Af[key] = &NetworkInstance_Protocol_Isis_Global_Af{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	return t.Af[key], nil
}

// RenameAf renames an entry in the list Af within
// the NetworkInstance_Protocol_Isis_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Global) RenameAf(oldK, newK NetworkInstance_Protocol_Isis_Global_Af_Key) error {
	if _, ok := t.Af[newK]; ok {
		return fmt.Errorf("key %v already exists in Af", newK)
	}

	e, ok := t.Af[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Af", oldK)
	}
	e.AfiName = newK.AfiName
	e.SafiName = newK.SafiName

	t.Af[newK] = e
	delete(t.Af, oldK)
	return nil
}

// GetOrCreateAf retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Af {

	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if v, ok := t.Af[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAf(AfiName, SafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAf got unexpected error: %v", err))
	}
	return v
}

// GetAf retrieves the value with the specified key from
// the Af map field of NetworkInstance_Protocol_Isis_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Af {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if lm, ok := t.Af[key]; ok {
		return lm
	}
	return nil
}

// AppendAf appends the supplied NetworkInstance_Protocol_Isis_Global_Af struct to the
// list Af of NetworkInstance_Protocol_Isis_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Global_Af already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Global) AppendAf(v *NetworkInstance_Protocol_Isis_Global_Af) error {
	key := NetworkInstance_Protocol_Isis_Global_Af_Key{AfiName: v.AfiName, SafiName: v.SafiName}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Global_Af_Key]*NetworkInstance_Protocol_Isis_Global_Af)
	}

	if _, ok := t.Af[key]; ok {
		return fmt.Errorf("duplicate key for list Af %v", key)
	}

	t.Af[key] = v
	return nil
}

// NewAfi creates a new entry in the Afi list of the
// NetworkInstance_Protocol_Isis_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Global) NewAfi(AfiName E_OpenconfigIsisTypes_AFI_TYPE) (*NetworkInstance_Protocol_Isis_Global_Afi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Afi == nil {
		t.Afi = make(map[E_OpenconfigIsisTypes_AFI_TYPE]*NetworkInstance_Protocol_Isis_Global_Afi)
	}

	key := AfiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Afi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Afi", key)
	}

	t.Afi[key] = &NetworkInstance_Protocol_Isis_Global_Afi{
		AfiName: AfiName,
	}

	return t.Afi[key], nil
}

// RenameAfi renames an entry in the list Afi within
// the NetworkInstance_Protocol_Isis_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Global) RenameAfi(oldK, newK E_OpenconfigIsisTypes_AFI_TYPE) error {
	if _, ok := t.Afi[newK]; ok {
		return fmt.Errorf("key %v already exists in Afi", newK)
	}

	e, ok := t.Afi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Afi", oldK)
	}
	e.AfiName = newK

	t.Afi[newK] = e
	delete(t.Afi, oldK)
	return nil
}

// GetOrCreateAfi retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateAfi(AfiName E_OpenconfigIsisTypes_AFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Afi {

	key := AfiName

	if v, ok := t.Afi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfi(AfiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfi got unexpected error: %v", err))
	}
	return v
}

// GetAfi retrieves the value with the specified key from
// the Afi map field of NetworkInstance_Protocol_Isis_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetAfi(AfiName E_OpenconfigIsisTypes_AFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Afi {

	if t == nil {
		return nil
	}

	key := AfiName

	if lm, ok := t.Afi[key]; ok {
		return lm
	}
	return nil
}

// AppendAfi appends the supplied NetworkInstance_Protocol_Isis_Global_Afi struct to the
// list Afi of NetworkInstance_Protocol_Isis_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Global_Afi already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Global) AppendAfi(v *NetworkInstance_Protocol_Isis_Global_Afi) error {
	key := v.AfiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Afi == nil {
		t.Afi = make(map[E_OpenconfigIsisTypes_AFI_TYPE]*NetworkInstance_Protocol_Isis_Global_Afi)
	}

	if _, ok := t.Afi[key]; ok {
		return fmt.Errorf("duplicate key for list Afi %v", key)
	}

	t.Afi[key] = v
	return nil
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Isis_Global_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateInterLevelPropagationPolicies retrieves the value of the InterLevelPropagationPolicies field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global) GetOrCreateInterLevelPropagationPolicies() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	if s.InterLevelPropagationPolicies != nil {
		return s.InterLevelPropagationPolicies
	}
	s.InterLevelPropagationPolicies = &NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{}
	return s.InterLevelPropagationPolicies
}

// GetOrCreateLspBit retrieves the value of the LspBit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global) GetOrCreateLspBit() *NetworkInstance_Protocol_Isis_Global_LspBit {
	if s.LspBit != nil {
		return s.LspBit
	}
	s.LspBit = &NetworkInstance_Protocol_Isis_Global_LspBit{}
	return s.LspBit
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global) GetOrCreateMpls() *NetworkInstance_Protocol_Isis_Global_Mpls {
	if s.Mpls != nil {
		return s.Mpls
	}
	s.Mpls = &NetworkInstance_Protocol_Isis_Global_Mpls{}
	return s.Mpls
}

// GetOrCreateNsr retrieves the value of the Nsr field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global) GetOrCreateNsr() *NetworkInstance_Protocol_Isis_Global_Nsr {
	if s.Nsr != nil {
		return s.Nsr
	}
	s.Nsr = &NetworkInstance_Protocol_Isis_Global_Nsr{}
	return s.Nsr
}

// GetOrCreateReferenceBandwidth retrieves the value of the ReferenceBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global) GetOrCreateReferenceBandwidth() *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	if s.ReferenceBandwidth != nil {
		return s.ReferenceBandwidth
	}
	s.ReferenceBandwidth = &NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
	return s.ReferenceBandwidth
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global) GetOrCreateSegmentRouting() *NetworkInstance_Protocol_Isis_Global_SegmentRouting {
	if s.SegmentRouting != nil {
		return s.SegmentRouting
	}
	s.SegmentRouting = &NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	return s.SegmentRouting
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global) GetOrCreateTimers() *NetworkInstance_Protocol_Isis_Global_Timers {
	if s.Timers != nil {
		return s.Timers
	}
	s.Timers = &NetworkInstance_Protocol_Isis_Global_Timers{}
	return s.Timers
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global) GetOrCreateTransport() *NetworkInstance_Protocol_Isis_Global_Transport {
	if s.Transport != nil {
		return s.Transport
	}
	s.Transport = &NetworkInstance_Protocol_Isis_Global_Transport{}
	return s.Transport
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global) GetGracefulRestart() *NetworkInstance_Protocol_Isis_Global_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetInterLevelPropagationPolicies returns the value of the InterLevelPropagationPolicies struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field InterLevelPropagationPolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global) GetInterLevelPropagationPolicies() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	if s != nil && s.InterLevelPropagationPolicies != nil {
		return s.InterLevelPropagationPolicies
	}
	return nil
}

// GetLspBit returns the value of the LspBit struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field LspBit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global) GetLspBit() *NetworkInstance_Protocol_Isis_Global_LspBit {
	if s != nil && s.LspBit != nil {
		return s.LspBit
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global) GetMpls() *NetworkInstance_Protocol_Isis_Global_Mpls {
	if s != nil && s.Mpls != nil {
		return s.Mpls
	}
	return nil
}

// GetNsr returns the value of the Nsr struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Nsr is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global) GetNsr() *NetworkInstance_Protocol_Isis_Global_Nsr {
	if s != nil && s.Nsr != nil {
		return s.Nsr
	}
	return nil
}

// GetReferenceBandwidth returns the value of the ReferenceBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field ReferenceBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global) GetReferenceBandwidth() *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	if s != nil && s.ReferenceBandwidth != nil {
		return s.ReferenceBandwidth
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global) GetSegmentRouting() *NetworkInstance_Protocol_Isis_Global_SegmentRouting {
	if s != nil && s.SegmentRouting != nil {
		return s.SegmentRouting
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global) GetTimers() *NetworkInstance_Protocol_Isis_Global_Timers {
	if s != nil && s.Timers != nil {
		return s.Timers
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global) GetTransport() *NetworkInstance_Protocol_Isis_Global_Transport {
	if s != nil && s.Transport != nil {
		return s.Transport
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateMultiTopology retrieves the value of the MultiTopology field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global_Af) GetOrCreateMultiTopology() *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	if s.MultiTopology != nil {
		return s.MultiTopology
	}
	s.MultiTopology = &NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	return s.MultiTopology
}

// GetMultiTopology returns the value of the MultiTopology struct pointer
// from NetworkInstance_Protocol_Isis_Global_Af. If the receiver or the field MultiTopology is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global_Af) GetMultiTopology() *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	if s != nil && s.MultiTopology != nil {
		return s.MultiTopology
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Global_Af struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Global_Af) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name":  t.AfiName,
		"safi-name": t.SafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_Af) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Af"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Af) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Af_MultiTopology"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Global_Afi struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Global_Afi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name": t.AfiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_Afi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Afi"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Afi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLevel1ToLevel2 retrieves the value of the Level1ToLevel2 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetOrCreateLevel1ToLevel2() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	if s.Level1ToLevel2 != nil {
		return s.Level1ToLevel2
	}
	s.Level1ToLevel2 = &NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	return s.Level1ToLevel2
}

// GetOrCreateLevel2ToLevel1 retrieves the value of the Level2ToLevel1 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetOrCreateLevel2ToLevel1() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	if s.Level2ToLevel1 != nil {
		return s.Level2ToLevel1
	}
	s.Level2ToLevel1 = &NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	return s.Level2ToLevel1
}

// GetLevel1ToLevel2 returns the value of the Level1ToLevel2 struct pointer
// from NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies. If the receiver or the field Level1ToLevel2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetLevel1ToLevel2() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	if s != nil && s.Level1ToLevel2 != nil {
		return s.Level1ToLevel2
	}
	return nil
}

// GetLevel2ToLevel1 returns the value of the Level2ToLevel1 struct pointer
// from NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies. If the receiver or the field Level2ToLevel1 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetLevel2ToLevel1() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	if s != nil && s.Level2ToLevel1 != nil {
		return s.Level2ToLevel1
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAttachedBit retrieves the value of the AttachedBit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global_LspBit) GetOrCreateAttachedBit() *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	if s.AttachedBit != nil {
		return s.AttachedBit
	}
	s.AttachedBit = &NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	return s.AttachedBit
}

// GetOrCreateOverloadBit retrieves the value of the OverloadBit field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global_LspBit) GetOrCreateOverloadBit() *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	if s.OverloadBit != nil {
		return s.OverloadBit
	}
	s.OverloadBit = &NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	return s.OverloadBit
}

// GetAttachedBit returns the value of the AttachedBit struct pointer
// from NetworkInstance_Protocol_Isis_Global_LspBit. If the receiver or the field AttachedBit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global_LspBit) GetAttachedBit() *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	if s != nil && s.AttachedBit != nil {
		return s.AttachedBit
	}
	return nil
}

// GetOverloadBit returns the value of the OverloadBit struct pointer
// from NetworkInstance_Protocol_Isis_Global_LspBit. If the receiver or the field OverloadBit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global_LspBit) GetOverloadBit() *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	if s != nil && s.OverloadBit != nil {
		return s.OverloadBit
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_LspBit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewResetTrigger creates a new entry in the ResetTrigger list of the
// NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) NewResetTrigger(ResetTrigger E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) (*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ResetTrigger == nil {
		t.ResetTrigger = make(map[E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE]*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger)
	}

	key := ResetTrigger

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ResetTrigger[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ResetTrigger", key)
	}

	t.ResetTrigger[key] = &NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{
		ResetTrigger: ResetTrigger,
	}

	return t.ResetTrigger[key], nil
}

// RenameResetTrigger renames an entry in the list ResetTrigger within
// the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) RenameResetTrigger(oldK, newK E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) error {
	if _, ok := t.ResetTrigger[newK]; ok {
		return fmt.Errorf("key %v already exists in ResetTrigger", newK)
	}

	e, ok := t.ResetTrigger[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ResetTrigger", oldK)
	}
	e.ResetTrigger = newK

	t.ResetTrigger[newK] = e
	delete(t.ResetTrigger, oldK)
	return nil
}

// GetOrCreateResetTrigger retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) GetOrCreateResetTrigger(ResetTrigger E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {

	key := ResetTrigger

	if v, ok := t.ResetTrigger[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewResetTrigger(ResetTrigger)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateResetTrigger got unexpected error: %v", err))
	}
	return v
}

// GetResetTrigger retrieves the value with the specified key from
// the ResetTrigger map field of NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) GetResetTrigger(ResetTrigger E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {

	if t == nil {
		return nil
	}

	key := ResetTrigger

	if lm, ok := t.ResetTrigger[key]; ok {
		return lm
	}
	return nil
}

// AppendResetTrigger appends the supplied NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger struct to the
// list ResetTrigger of NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) AppendResetTrigger(v *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) error {
	key := v.ResetTrigger

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ResetTrigger == nil {
		t.ResetTrigger = make(map[E_OpenconfigIsisTypes_OVERLOAD_RESET_TRIGGER_TYPE]*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger)
	}

	if _, ok := t.ResetTrigger[key]; ok {
		return fmt.Errorf("duplicate key for list ResetTrigger %v", key)
	}

	t.ResetTrigger[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"reset-trigger": t.ResetTrigger,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateIgpLdpSync retrieves the value of the IgpLdpSync field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global_Mpls) GetOrCreateIgpLdpSync() *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	if s.IgpLdpSync != nil {
		return s.IgpLdpSync
	}
	s.IgpLdpSync = &NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	return s.IgpLdpSync
}

// GetIgpLdpSync returns the value of the IgpLdpSync struct pointer
// from NetworkInstance_Protocol_Isis_Global_Mpls. If the receiver or the field IgpLdpSync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global_Mpls) GetIgpLdpSync() *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	if s != nil && s.IgpLdpSync != nil {
		return s.IgpLdpSync
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Mpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_Nsr) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Nsr"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Nsr) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_SegmentRouting"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLspGeneration retrieves the value of the LspGeneration field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global_Timers) GetOrCreateLspGeneration() *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	if s.LspGeneration != nil {
		return s.LspGeneration
	}
	s.LspGeneration = &NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	return s.LspGeneration
}

// GetOrCreateSpf retrieves the value of the Spf field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Global_Timers) GetOrCreateSpf() *NetworkInstance_Protocol_Isis_Global_Timers_Spf {
	if s.Spf != nil {
		return s.Spf
	}
	s.Spf = &NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	return s.Spf
}

// GetLspGeneration returns the value of the LspGeneration struct pointer
// from NetworkInstance_Protocol_Isis_Global_Timers. If the receiver or the field LspGeneration is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global_Timers) GetLspGeneration() *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	if s != nil && s.LspGeneration != nil {
		return s.LspGeneration
	}
	return nil
}

// GetSpf returns the value of the Spf struct pointer
// from NetworkInstance_Protocol_Isis_Global_Timers. If the receiver or the field Spf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Global_Timers) GetSpf() *NetworkInstance_Protocol_Isis_Global_Timers_Spf {
	if s != nil && s.Spf != nil {
		return s.Spf
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Timers"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_Timers_Spf) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Timers_Spf"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_Spf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Global_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Transport"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Transport) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAf creates a new entry in the Af list of the
// NetworkInstance_Protocol_Isis_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface) NewAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) (*NetworkInstance_Protocol_Isis_Interface_Af, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Af)
	}

	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Af[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Af", key)
	}

	t.Af[key] = &NetworkInstance_Protocol_Isis_Interface_Af{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	return t.Af[key], nil
}

// RenameAf renames an entry in the list Af within
// the NetworkInstance_Protocol_Isis_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface) RenameAf(oldK, newK NetworkInstance_Protocol_Isis_Interface_Af_Key) error {
	if _, ok := t.Af[newK]; ok {
		return fmt.Errorf("key %v already exists in Af", newK)
	}

	e, ok := t.Af[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Af", oldK)
	}
	e.AfiName = newK.AfiName
	e.SafiName = newK.SafiName

	t.Af[newK] = e
	delete(t.Af, oldK)
	return nil
}

// GetOrCreateAf retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Af {

	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if v, ok := t.Af[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAf(AfiName, SafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAf got unexpected error: %v", err))
	}
	return v
}

// GetAf retrieves the value with the specified key from
// the Af map field of NetworkInstance_Protocol_Isis_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Af {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if lm, ok := t.Af[key]; ok {
		return lm
	}
	return nil
}

// AppendAf appends the supplied NetworkInstance_Protocol_Isis_Interface_Af struct to the
// list Af of NetworkInstance_Protocol_Isis_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Af already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface) AppendAf(v *NetworkInstance_Protocol_Isis_Interface_Af) error {
	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{AfiName: v.AfiName, SafiName: v.SafiName}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Af)
	}

	if _, ok := t.Af[key]; ok {
		return fmt.Errorf("duplicate key for list Af %v", key)
	}

	t.Af[key] = v
	return nil
}

// NewLevel creates a new entry in the Level list of the
// NetworkInstance_Protocol_Isis_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface) NewLevel(LevelNumber uint8) (*NetworkInstance_Protocol_Isis_Interface_Level, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Interface_Level)
	}

	key := LevelNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Level[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Level", key)
	}

	t.Level[key] = &NetworkInstance_Protocol_Isis_Interface_Level{
		LevelNumber: &LevelNumber,
	}

	return t.Level[key], nil
}

// RenameLevel renames an entry in the list Level within
// the NetworkInstance_Protocol_Isis_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface) RenameLevel(oldK, newK uint8) error {
	if _, ok := t.Level[newK]; ok {
		return fmt.Errorf("key %v already exists in Level", newK)
	}

	e, ok := t.Level[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Level", oldK)
	}
	e.LevelNumber = &newK

	t.Level[newK] = e
	delete(t.Level, oldK)
	return nil
}

// GetOrCreateLevel retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Interface_Level {

	key := LevelNumber

	if v, ok := t.Level[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLevel(LevelNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLevel got unexpected error: %v", err))
	}
	return v
}

// GetLevel retrieves the value with the specified key from
// the Level map field of NetworkInstance_Protocol_Isis_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Interface_Level {

	if t == nil {
		return nil
	}

	key := LevelNumber

	if lm, ok := t.Level[key]; ok {
		return lm
	}
	return nil
}

// AppendLevel appends the supplied NetworkInstance_Protocol_Isis_Interface_Level struct to the
// list Level of NetworkInstance_Protocol_Isis_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface) AppendLevel(v *NetworkInstance_Protocol_Isis_Interface_Level) error {
	key := *v.LevelNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Interface_Level)
	}

	if _, ok := t.Level[key]; ok {
		return fmt.Errorf("duplicate key for list Level %v", key)
	}

	t.Level[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface) GetOrCreateAuthentication() *NetworkInstance_Protocol_Isis_Interface_Authentication {
	if s.Authentication != nil {
		return s.Authentication
	}
	s.Authentication = &NetworkInstance_Protocol_Isis_Interface_Authentication{}
	return s.Authentication
}

// GetOrCreateBfd retrieves the value of the Bfd field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface) GetOrCreateBfd() *NetworkInstance_Protocol_Isis_Interface_Bfd {
	if s.Bfd != nil {
		return s.Bfd
	}
	s.Bfd = &NetworkInstance_Protocol_Isis_Interface_Bfd{}
	return s.Bfd
}

// GetOrCreateCircuitCounters retrieves the value of the CircuitCounters field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface) GetOrCreateCircuitCounters() *NetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	if s.CircuitCounters != nil {
		return s.CircuitCounters
	}
	s.CircuitCounters = &NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	return s.CircuitCounters
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface) GetOrCreateTimers() *NetworkInstance_Protocol_Isis_Interface_Timers {
	if s.Timers != nil {
		return s.Timers
	}
	s.Timers = &NetworkInstance_Protocol_Isis_Interface_Timers{}
	return s.Timers
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface) GetAuthentication() *NetworkInstance_Protocol_Isis_Interface_Authentication {
	if s != nil && s.Authentication != nil {
		return s.Authentication
	}
	return nil
}

// GetBfd returns the value of the Bfd struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field Bfd is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface) GetBfd() *NetworkInstance_Protocol_Isis_Interface_Bfd {
	if s != nil && s.Bfd != nil {
		return s.Bfd
	}
	return nil
}

// GetCircuitCounters returns the value of the CircuitCounters struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field CircuitCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface) GetCircuitCounters() *NetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	if s != nil && s.CircuitCounters != nil {
		return s.CircuitCounters
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface) GetInterfaceRef() *NetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface) GetTimers() *NetworkInstance_Protocol_Isis_Interface_Timers {
	if s != nil && s.Timers != nil {
		return s.Timers
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Af struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name":  t.AfiName,
		"safi-name": t.SafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Af) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Af"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateKey retrieves the value of the Key field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Authentication) GetOrCreateKey() *NetworkInstance_Protocol_Isis_Interface_Authentication_Key {
	if s.Key != nil {
		return s.Key
	}
	s.Key = &NetworkInstance_Protocol_Isis_Interface_Authentication_Key{}
	return s.Key
}

// GetOrCreateKeychain retrieves the value of the Keychain field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Authentication) GetOrCreateKeychain() *NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain {
	if s.Keychain != nil {
		return s.Keychain
	}
	s.Keychain = &NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain{}
	return s.Keychain
}

// GetKey returns the value of the Key struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Authentication. If the receiver or the field Key is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Authentication) GetKey() *NetworkInstance_Protocol_Isis_Interface_Authentication_Key {
	if s != nil && s.Key != nil {
		return s.Key
	}
	return nil
}

// GetKeychain returns the value of the Keychain struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Authentication. If the receiver or the field Keychain is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Authentication) GetKeychain() *NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain {
	if s != nil && s.Keychain != nil {
		return s.Keychain
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Authentication"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Authentication_Key) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Authentication_Key"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication_Key) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication_Keychain) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Bfd) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Bfd"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Bfd) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_CircuitCounters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacency creates a new entry in the Adjacency list of the
// NetworkInstance_Protocol_Isis_Interface_Level struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) NewAdjacency(SystemId string) (*NetworkInstance_Protocol_Isis_Interface_Level_Adjacency, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Adjacency == nil {
		t.Adjacency = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Adjacency)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Adjacency[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Adjacency", key)
	}

	t.Adjacency[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{
		SystemId: &SystemId,
	}

	return t.Adjacency[key], nil
}

// RenameAdjacency renames an entry in the list Adjacency within
// the NetworkInstance_Protocol_Isis_Interface_Level struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) RenameAdjacency(oldK, newK string) error {
	if _, ok := t.Adjacency[newK]; ok {
		return fmt.Errorf("key %v already exists in Adjacency", newK)
	}

	e, ok := t.Adjacency[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Adjacency", oldK)
	}
	e.SystemId = &newK

	t.Adjacency[newK] = e
	delete(t.Adjacency, oldK)
	return nil
}

// GetOrCreateAdjacency retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateAdjacency(SystemId string) *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency {

	key := SystemId

	if v, ok := t.Adjacency[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacency(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacency got unexpected error: %v", err))
	}
	return v
}

// GetAdjacency retrieves the value with the specified key from
// the Adjacency map field of NetworkInstance_Protocol_Isis_Interface_Level. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetAdjacency(SystemId string) *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Adjacency[key]; ok {
		return lm
	}
	return nil
}

// AppendAdjacency appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Adjacency struct to the
// list Adjacency of NetworkInstance_Protocol_Isis_Interface_Level. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Adjacency already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) AppendAdjacency(v *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) error {
	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Adjacency == nil {
		t.Adjacency = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Adjacency)
	}

	if _, ok := t.Adjacency[key]; ok {
		return fmt.Errorf("duplicate key for list Adjacency %v", key)
	}

	t.Adjacency[key] = v
	return nil
}

// NewAf creates a new entry in the Af list of the
// NetworkInstance_Protocol_Isis_Interface_Level struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) NewAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) (*NetworkInstance_Protocol_Isis_Interface_Level_Af, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af)
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Af[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Af", key)
	}

	t.Af[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Af{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	return t.Af[key], nil
}

// RenameAf renames an entry in the list Af within
// the NetworkInstance_Protocol_Isis_Interface_Level struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) RenameAf(oldK, newK NetworkInstance_Protocol_Isis_Interface_Level_Af_Key) error {
	if _, ok := t.Af[newK]; ok {
		return fmt.Errorf("key %v already exists in Af", newK)
	}

	e, ok := t.Af[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Af", oldK)
	}
	e.AfiName = newK.AfiName
	e.SafiName = newK.SafiName

	t.Af[newK] = e
	delete(t.Af, oldK)
	return nil
}

// GetOrCreateAf retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Level_Af {

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if v, ok := t.Af[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAf(AfiName, SafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAf got unexpected error: %v", err))
	}
	return v
}

// GetAf retrieves the value with the specified key from
// the Af map field of NetworkInstance_Protocol_Isis_Interface_Level. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetAf(AfiName E_OpenconfigIsisTypes_AFI_TYPE, SafiName E_OpenconfigIsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Level_Af {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if lm, ok := t.Af[key]; ok {
		return lm
	}
	return nil
}

// AppendAf appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af struct to the
// list Af of NetworkInstance_Protocol_Isis_Interface_Level. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) AppendAf(v *NetworkInstance_Protocol_Isis_Interface_Level_Af) error {
	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{AfiName: v.AfiName, SafiName: v.SafiName}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af)
	}

	if _, ok := t.Af[key]; ok {
		return fmt.Errorf("duplicate key for list Af %v", key)
	}

	t.Af[key] = v
	return nil
}

// GetOrCreateHelloAuthentication retrieves the value of the HelloAuthentication field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateHelloAuthentication() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	if s.HelloAuthentication != nil {
		return s.HelloAuthentication
	}
	s.HelloAuthentication = &NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	return s.HelloAuthentication
}

// GetOrCreatePacketCounters retrieves the value of the PacketCounters field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreatePacketCounters() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	if s.PacketCounters != nil {
		return s.PacketCounters
	}
	s.PacketCounters = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{}
	return s.PacketCounters
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateTimers() *NetworkInstance_Protocol_Isis_Interface_Level_Timers {
	if s.Timers != nil {
		return s.Timers
	}
	s.Timers = &NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	return s.Timers
}

// GetHelloAuthentication returns the value of the HelloAuthentication struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level. If the receiver or the field HelloAuthentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level) GetHelloAuthentication() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	if s != nil && s.HelloAuthentication != nil {
		return s.HelloAuthentication
	}
	return nil
}

// GetPacketCounters returns the value of the PacketCounters struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level. If the receiver or the field PacketCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level) GetPacketCounters() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	if s != nil && s.PacketCounters != nil {
		return s.PacketCounters
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level) GetTimers() *NetworkInstance_Protocol_Isis_Interface_Level_Timers {
	if s != nil && s.Timers != nil {
		return s.Timers
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LevelNumber == nil {
		return nil, fmt.Errorf("nil value for key LevelNumber")
	}

	return map[string]interface{}{
		"level-number": *t.LevelNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Adjacency"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_Af) GetOrCreateSegmentRouting() *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	if s.SegmentRouting != nil {
		return s.SegmentRouting
	}
	s.SegmentRouting = &NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{}
	return s.SegmentRouting
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_Af. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_Af) GetSegmentRouting() *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	if s != nil && s.SegmentRouting != nil {
		return s.SegmentRouting
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Af struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name":  t.AfiName,
		"safi-name": t.SafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_Af) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) NewAdjacencySid(Neighbor string, SidId NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) (*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid)
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: Neighbor,
		SidId:    SidId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{
		Neighbor: &Neighbor,
		SidId:    SidId,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) RenameAdjacencySid(oldK, newK NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Neighbor = &newK.Neighbor
	e.SidId = newK.SidId

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetOrCreateAdjacencySid(Neighbor string, SidId NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: Neighbor,
		SidId:    SidId,
	}

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Neighbor, SidId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetAdjacencySid(Neighbor string, SidId NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: Neighbor,
		SidId:    SidId,
	}

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) error {
	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{Neighbor: *v.Neighbor, SidId: v.SidId}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) NewPrefixSid(Prefix string) (*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{
		Prefix: &Prefix,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) RenamePrefixSid(oldK, newK string) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Prefix = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetOrCreatePrefixSid(Prefix string) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {

	key := Prefix

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetPrefixSid(Prefix string) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Neighbor == nil {
		return nil, fmt.Errorf("nil value for key Neighbor")
	}

	return map[string]interface{}{
		"neighbor": *t.Neighbor,
		"sid-id":   t.SidId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateKey retrieves the value of the Key field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) GetOrCreateKey() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key {
	if s.Key != nil {
		return s.Key
	}
	s.Key = &NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key{}
	return s.Key
}

// GetOrCreateKeychain retrieves the value of the Keychain field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) GetOrCreateKeychain() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain {
	if s.Keychain != nil {
		return s.Keychain
	}
	s.Keychain = &NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain{}
	return s.Keychain
}

// GetKey returns the value of the Key struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication. If the receiver or the field Key is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) GetKey() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key {
	if s != nil && s.Key != nil {
		return s.Key
	}
	return nil
}

// GetKeychain returns the value of the Keychain struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication. If the receiver or the field Keychain is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) GetKeychain() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain {
	if s != nil && s.Keychain != nil {
		return s.Keychain
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Key) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_Keychain) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateCsnp retrieves the value of the Csnp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateCsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	if s.Csnp != nil {
		return s.Csnp
	}
	s.Csnp = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	return s.Csnp
}

// GetOrCreateEsh retrieves the value of the Esh field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateEsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	if s.Esh != nil {
		return s.Esh
	}
	s.Esh = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	return s.Esh
}

// GetOrCreateIih retrieves the value of the Iih field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateIih() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	if s.Iih != nil {
		return s.Iih
	}
	s.Iih = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	return s.Iih
}

// GetOrCreateIsh retrieves the value of the Ish field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateIsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	if s.Ish != nil {
		return s.Ish
	}
	s.Ish = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	return s.Ish
}

// GetOrCreateLsp retrieves the value of the Lsp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateLsp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	if s.Lsp != nil {
		return s.Lsp
	}
	s.Lsp = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	return s.Lsp
}

// GetOrCreatePsnp retrieves the value of the Psnp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreatePsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	if s.Psnp != nil {
		return s.Psnp
	}
	s.Psnp = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	return s.Psnp
}

// GetOrCreateUnknown retrieves the value of the Unknown field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateUnknown() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	if s.Unknown != nil {
		return s.Unknown
	}
	s.Unknown = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	return s.Unknown
}

// GetCsnp returns the value of the Csnp struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Csnp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetCsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	if s != nil && s.Csnp != nil {
		return s.Csnp
	}
	return nil
}

// GetEsh returns the value of the Esh struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Esh is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetEsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	if s != nil && s.Esh != nil {
		return s.Esh
	}
	return nil
}

// GetIih returns the value of the Iih struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Iih is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetIih() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	if s != nil && s.Iih != nil {
		return s.Iih
	}
	return nil
}

// GetIsh returns the value of the Ish struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Ish is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetIsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	if s != nil && s.Ish != nil {
		return s.Ish
	}
	return nil
}

// GetLsp returns the value of the Lsp struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Lsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetLsp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	if s != nil && s.Lsp != nil {
		return s.Lsp
	}
	return nil
}

// GetPsnp returns the value of the Psnp struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Psnp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetPsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	if s != nil && s.Psnp != nil {
		return s.Psnp
	}
	return nil
}

// GetUnknown returns the value of the Unknown struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Unknown is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetUnknown() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	if s != nil && s.Unknown != nil {
		return s.Unknown
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Level_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Timers"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Interface_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Timers"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewLsp creates a new entry in the Lsp list of the
// NetworkInstance_Protocol_Isis_Level struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level) NewLsp(LspId string) (*NetworkInstance_Protocol_Isis_Level_Lsp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsp == nil {
		t.Lsp = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp)
	}

	key := LspId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Lsp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Lsp", key)
	}

	t.Lsp[key] = &NetworkInstance_Protocol_Isis_Level_Lsp{
		LspId: &LspId,
	}

	return t.Lsp[key], nil
}

// RenameLsp renames an entry in the list Lsp within
// the NetworkInstance_Protocol_Isis_Level struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level) RenameLsp(oldK, newK string) error {
	if _, ok := t.Lsp[newK]; ok {
		return fmt.Errorf("key %v already exists in Lsp", newK)
	}

	e, ok := t.Lsp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Lsp", oldK)
	}
	e.LspId = &newK

	t.Lsp[newK] = e
	delete(t.Lsp, oldK)
	return nil
}

// GetOrCreateLsp retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level) GetOrCreateLsp(LspId string) *NetworkInstance_Protocol_Isis_Level_Lsp {

	key := LspId

	if v, ok := t.Lsp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLsp(LspId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLsp got unexpected error: %v", err))
	}
	return v
}

// GetLsp retrieves the value with the specified key from
// the Lsp map field of NetworkInstance_Protocol_Isis_Level. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level) GetLsp(LspId string) *NetworkInstance_Protocol_Isis_Level_Lsp {

	if t == nil {
		return nil
	}

	key := LspId

	if lm, ok := t.Lsp[key]; ok {
		return lm
	}
	return nil
}

// AppendLsp appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp struct to the
// list Lsp of NetworkInstance_Protocol_Isis_Level. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level) AppendLsp(v *NetworkInstance_Protocol_Isis_Level_Lsp) error {
	key := *v.LspId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsp == nil {
		t.Lsp = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp)
	}

	if _, ok := t.Lsp[key]; ok {
		return fmt.Errorf("duplicate key for list Lsp %v", key)
	}

	t.Lsp[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level) GetOrCreateAuthentication() *NetworkInstance_Protocol_Isis_Level_Authentication {
	if s.Authentication != nil {
		return s.Authentication
	}
	s.Authentication = &NetworkInstance_Protocol_Isis_Level_Authentication{}
	return s.Authentication
}

// GetOrCreateRoutePreference retrieves the value of the RoutePreference field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level) GetOrCreateRoutePreference() *NetworkInstance_Protocol_Isis_Level_RoutePreference {
	if s.RoutePreference != nil {
		return s.RoutePreference
	}
	s.RoutePreference = &NetworkInstance_Protocol_Isis_Level_RoutePreference{}
	return s.RoutePreference
}

// GetOrCreateSystemLevelCounters retrieves the value of the SystemLevelCounters field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level) GetOrCreateSystemLevelCounters() *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	if s.SystemLevelCounters != nil {
		return s.SystemLevelCounters
	}
	s.SystemLevelCounters = &NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	return s.SystemLevelCounters
}

// GetOrCreateTrafficEngineering retrieves the value of the TrafficEngineering field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level) GetOrCreateTrafficEngineering() *NetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	if s.TrafficEngineering != nil {
		return s.TrafficEngineering
	}
	s.TrafficEngineering = &NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	return s.TrafficEngineering
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level) GetAuthentication() *NetworkInstance_Protocol_Isis_Level_Authentication {
	if s != nil && s.Authentication != nil {
		return s.Authentication
	}
	return nil
}

// GetRoutePreference returns the value of the RoutePreference struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field RoutePreference is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level) GetRoutePreference() *NetworkInstance_Protocol_Isis_Level_RoutePreference {
	if s != nil && s.RoutePreference != nil {
		return s.RoutePreference
	}
	return nil
}

// GetSystemLevelCounters returns the value of the SystemLevelCounters struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field SystemLevelCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level) GetSystemLevelCounters() *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	if s != nil && s.SystemLevelCounters != nil {
		return s.SystemLevelCounters
	}
	return nil
}

// GetTrafficEngineering returns the value of the TrafficEngineering struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field TrafficEngineering is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level) GetTrafficEngineering() *NetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	if s != nil && s.TrafficEngineering != nil {
		return s.TrafficEngineering
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LevelNumber == nil {
		return nil, fmt.Errorf("nil value for key LevelNumber")
	}

	return map[string]interface{}{
		"level-number": *t.LevelNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateKey retrieves the value of the Key field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Authentication) GetOrCreateKey() *NetworkInstance_Protocol_Isis_Level_Authentication_Key {
	if s.Key != nil {
		return s.Key
	}
	s.Key = &NetworkInstance_Protocol_Isis_Level_Authentication_Key{}
	return s.Key
}

// GetOrCreateKeychain retrieves the value of the Keychain field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Authentication) GetOrCreateKeychain() *NetworkInstance_Protocol_Isis_Level_Authentication_Keychain {
	if s.Keychain != nil {
		return s.Keychain
	}
	s.Keychain = &NetworkInstance_Protocol_Isis_Level_Authentication_Keychain{}
	return s.Keychain
}

// GetKey returns the value of the Key struct pointer
// from NetworkInstance_Protocol_Isis_Level_Authentication. If the receiver or the field Key is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Authentication) GetKey() *NetworkInstance_Protocol_Isis_Level_Authentication_Key {
	if s != nil && s.Key != nil {
		return s.Key
	}
	return nil
}

// GetKeychain returns the value of the Keychain struct pointer
// from NetworkInstance_Protocol_Isis_Level_Authentication. If the receiver or the field Keychain is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Authentication) GetKeychain() *NetworkInstance_Protocol_Isis_Level_Authentication_Keychain {
	if s != nil && s.Keychain != nil {
		return s.Keychain
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Authentication"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Authentication_Key) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Authentication_Key"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication_Key) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Authentication_Keychain) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Authentication_Keychain"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication_Keychain) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTlv creates a new entry in the Tlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) NewTlv(Type E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tlv", key)
	}

	t.Tlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv{
		Type: Type,
	}

	return t.Tlv[key], nil
}

// RenameTlv renames an entry in the list Tlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) RenameTlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE) error {
	if _, ok := t.Tlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Tlv", newK)
	}

	e, ok := t.Tlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tlv", oldK)
	}
	e.Type = newK

	t.Tlv[newK] = e
	delete(t.Tlv, oldK)
	return nil
}

// GetOrCreateTlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetOrCreateTlv(Type E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv {

	key := Type

	if v, ok := t.Tlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTlv got unexpected error: %v", err))
	}
	return v
}

// GetTlv retrieves the value with the specified key from
// the Tlv map field of NetworkInstance_Protocol_Isis_Level_Lsp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetTlv(Type E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Tlv[key]; ok {
		return lm
	}
	return nil
}

// AppendTlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct to the
// list Tlv of NetworkInstance_Protocol_Isis_Level_Lsp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) AppendTlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_TLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv)
	}

	if _, ok := t.Tlv[key]; ok {
		return fmt.Errorf("duplicate key for list Tlv %v", key)
	}

	t.Tlv[key] = v
	return nil
}

// NewUndefinedTlv creates a new entry in the UndefinedTlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) NewUndefinedTlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedTlv == nil {
		t.UndefinedTlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedTlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedTlv", key)
	}

	t.UndefinedTlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{
		Type: &Type,
	}

	return t.UndefinedTlv[key], nil
}

// RenameUndefinedTlv renames an entry in the list UndefinedTlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) RenameUndefinedTlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedTlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedTlv", newK)
	}

	e, ok := t.UndefinedTlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedTlv", oldK)
	}
	e.Type = &newK

	t.UndefinedTlv[newK] = e
	delete(t.UndefinedTlv, oldK)
	return nil
}

// GetOrCreateUndefinedTlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetOrCreateUndefinedTlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {

	key := Type

	if v, ok := t.UndefinedTlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedTlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedTlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedTlv retrieves the value with the specified key from
// the UndefinedTlv map field of NetworkInstance_Protocol_Isis_Level_Lsp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetUndefinedTlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedTlv[key]; ok {
		return lm
	}
	return nil
}

// AppendUndefinedTlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv struct to the
// list UndefinedTlv of NetworkInstance_Protocol_Isis_Level_Lsp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) AppendUndefinedTlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedTlv == nil {
		t.UndefinedTlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv)
	}

	if _, ok := t.UndefinedTlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedTlv %v", key)
	}

	t.UndefinedTlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LspId == nil {
		return nil, fmt.Errorf("nil value for key LspId")
	}

	return map[string]interface{}{
		"lsp-id": *t.LspId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewCapability creates a new entry in the Capability list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewCapability(InstanceNumber uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability)
	}

	key := InstanceNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Capability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Capability", key)
	}

	t.Capability[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{
		InstanceNumber: &InstanceNumber,
	}

	return t.Capability[key], nil
}

// RenameCapability renames an entry in the list Capability within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameCapability(oldK, newK uint32) error {
	if _, ok := t.Capability[newK]; ok {
		return fmt.Errorf("key %v already exists in Capability", newK)
	}

	e, ok := t.Capability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Capability", oldK)
	}
	e.InstanceNumber = &newK

	t.Capability[newK] = e
	delete(t.Capability, oldK)
	return nil
}

// GetOrCreateCapability retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateCapability(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {

	key := InstanceNumber

	if v, ok := t.Capability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCapability(InstanceNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCapability got unexpected error: %v", err))
	}
	return v
}

// GetCapability retrieves the value with the specified key from
// the Capability map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetCapability(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {

	if t == nil {
		return nil
	}

	key := InstanceNumber

	if lm, ok := t.Capability[key]; ok {
		return lm
	}
	return nil
}

// AppendCapability appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct to the
// list Capability of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendCapability(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) error {
	key := *v.InstanceNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability)
	}

	if _, ok := t.Capability[key]; ok {
		return fmt.Errorf("duplicate key for list Capability %v", key)
	}

	t.Capability[key] = v
	return nil
}

// NewInstanceId creates a new entry in the InstanceId list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewInstanceId(InstanceId uint16) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InstanceId == nil {
		t.InstanceId = make(map[uint16]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId)
	}

	key := InstanceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.InstanceId[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list InstanceId", key)
	}

	t.InstanceId[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId{
		InstanceId: &InstanceId,
	}

	return t.InstanceId[key], nil
}

// RenameInstanceId renames an entry in the list InstanceId within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameInstanceId(oldK, newK uint16) error {
	if _, ok := t.InstanceId[newK]; ok {
		return fmt.Errorf("key %v already exists in InstanceId", newK)
	}

	e, ok := t.InstanceId[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in InstanceId", oldK)
	}
	e.InstanceId = &newK

	t.InstanceId[newK] = e
	delete(t.InstanceId, oldK)
	return nil
}

// GetOrCreateInstanceId retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateInstanceId(InstanceId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId {

	key := InstanceId

	if v, ok := t.InstanceId[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstanceId(InstanceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstanceId got unexpected error: %v", err))
	}
	return v
}

// GetInstanceId retrieves the value with the specified key from
// the InstanceId map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetInstanceId(InstanceId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId {

	if t == nil {
		return nil
	}

	key := InstanceId

	if lm, ok := t.InstanceId[key]; ok {
		return lm
	}
	return nil
}

// AppendInstanceId appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId struct to the
// list InstanceId of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendInstanceId(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId) error {
	key := *v.InstanceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InstanceId == nil {
		t.InstanceId = make(map[uint16]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId)
	}

	if _, ok := t.InstanceId[key]; ok {
		return fmt.Errorf("duplicate key for list InstanceId %v", key)
	}

	t.InstanceId[key] = v
	return nil
}

// NewIpv4Srlg creates a new entry in the Ipv4Srlg list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewIpv4Srlg(InstanceNumber uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Srlg == nil {
		t.Ipv4Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg)
	}

	key := InstanceNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Srlg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Srlg", key)
	}

	t.Ipv4Srlg[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg{
		InstanceNumber: &InstanceNumber,
	}

	return t.Ipv4Srlg[key], nil
}

// RenameIpv4Srlg renames an entry in the list Ipv4Srlg within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameIpv4Srlg(oldK, newK uint32) error {
	if _, ok := t.Ipv4Srlg[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Srlg", newK)
	}

	e, ok := t.Ipv4Srlg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Srlg", oldK)
	}
	e.InstanceNumber = &newK

	t.Ipv4Srlg[newK] = e
	delete(t.Ipv4Srlg, oldK)
	return nil
}

// GetOrCreateIpv4Srlg retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg {

	key := InstanceNumber

	if v, ok := t.Ipv4Srlg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Srlg(InstanceNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Srlg got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Srlg retrieves the value with the specified key from
// the Ipv4Srlg map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg {

	if t == nil {
		return nil
	}

	key := InstanceNumber

	if lm, ok := t.Ipv4Srlg[key]; ok {
		return lm
	}
	return nil
}

// AppendIpv4Srlg appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg struct to the
// list Ipv4Srlg of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendIpv4Srlg(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg) error {
	key := *v.InstanceNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Srlg == nil {
		t.Ipv4Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg)
	}

	if _, ok := t.Ipv4Srlg[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Srlg %v", key)
	}

	t.Ipv4Srlg[key] = v
	return nil
}

// NewIpv6Srlg creates a new entry in the Ipv6Srlg list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewIpv6Srlg(InstanceNumber uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Srlg == nil {
		t.Ipv6Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg)
	}

	key := InstanceNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Srlg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Srlg", key)
	}

	t.Ipv6Srlg[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg{
		InstanceNumber: &InstanceNumber,
	}

	return t.Ipv6Srlg[key], nil
}

// RenameIpv6Srlg renames an entry in the list Ipv6Srlg within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameIpv6Srlg(oldK, newK uint32) error {
	if _, ok := t.Ipv6Srlg[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Srlg", newK)
	}

	e, ok := t.Ipv6Srlg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Srlg", oldK)
	}
	e.InstanceNumber = &newK

	t.Ipv6Srlg[newK] = e
	delete(t.Ipv6Srlg, oldK)
	return nil
}

// GetOrCreateIpv6Srlg retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg {

	key := InstanceNumber

	if v, ok := t.Ipv6Srlg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Srlg(InstanceNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Srlg got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Srlg retrieves the value with the specified key from
// the Ipv6Srlg map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg {

	if t == nil {
		return nil
	}

	key := InstanceNumber

	if lm, ok := t.Ipv6Srlg[key]; ok {
		return lm
	}
	return nil
}

// AppendIpv6Srlg appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg struct to the
// list Ipv6Srlg of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendIpv6Srlg(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg) error {
	key := *v.InstanceNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Srlg == nil {
		t.Ipv6Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg)
	}

	if _, ok := t.Ipv6Srlg[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Srlg %v", key)
	}

	t.Ipv6Srlg[key] = v
	return nil
}

// GetOrCreateAreaAddress retrieves the value of the AreaAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateAreaAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	if s.AreaAddress != nil {
		return s.AreaAddress
	}
	s.AreaAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
	return s.AreaAddress
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateAuthentication() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	if s.Authentication != nil {
		return s.Authentication
	}
	s.Authentication = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	return s.Authentication
}

// GetOrCreateExtendedIpv4Reachability retrieves the value of the ExtendedIpv4Reachability field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateExtendedIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	if s.ExtendedIpv4Reachability != nil {
		return s.ExtendedIpv4Reachability
	}
	s.ExtendedIpv4Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{}
	return s.ExtendedIpv4Reachability
}

// GetOrCreateExtendedIsReachability retrieves the value of the ExtendedIsReachability field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateExtendedIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability {
	if s.ExtendedIsReachability != nil {
		return s.ExtendedIsReachability
	}
	s.ExtendedIsReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability{}
	return s.ExtendedIsReachability
}

// GetOrCreateHostname retrieves the value of the Hostname field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateHostname() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname {
	if s.Hostname != nil {
		return s.Hostname
	}
	s.Hostname = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname{}
	return s.Hostname
}

// GetOrCreateIpv4ExternalReachability retrieves the value of the Ipv4ExternalReachability field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4ExternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability {
	if s.Ipv4ExternalReachability != nil {
		return s.Ipv4ExternalReachability
	}
	s.Ipv4ExternalReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability{}
	return s.Ipv4ExternalReachability
}

// GetOrCreateIpv4InterfaceAddresses retrieves the value of the Ipv4InterfaceAddresses field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses {
	if s.Ipv4InterfaceAddresses != nil {
		return s.Ipv4InterfaceAddresses
	}
	s.Ipv4InterfaceAddresses = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses{}
	return s.Ipv4InterfaceAddresses
}

// GetOrCreateIpv4InternalReachability retrieves the value of the Ipv4InternalReachability field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4InternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability {
	if s.Ipv4InternalReachability != nil {
		return s.Ipv4InternalReachability
	}
	s.Ipv4InternalReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability{}
	return s.Ipv4InternalReachability
}

// GetOrCreateIpv4TeRouterId retrieves the value of the Ipv4TeRouterId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId {
	if s.Ipv4TeRouterId != nil {
		return s.Ipv4TeRouterId
	}
	s.Ipv4TeRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId{}
	return s.Ipv4TeRouterId
}

// GetOrCreateIpv6InterfaceAddresses retrieves the value of the Ipv6InterfaceAddresses field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses {
	if s.Ipv6InterfaceAddresses != nil {
		return s.Ipv6InterfaceAddresses
	}
	s.Ipv6InterfaceAddresses = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses{}
	return s.Ipv6InterfaceAddresses
}

// GetOrCreateIpv6Reachability retrieves the value of the Ipv6Reachability field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability {
	if s.Ipv6Reachability != nil {
		return s.Ipv6Reachability
	}
	s.Ipv6Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability{}
	return s.Ipv6Reachability
}

// GetOrCreateIpv6TeRouterId retrieves the value of the Ipv6TeRouterId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId {
	if s.Ipv6TeRouterId != nil {
		return s.Ipv6TeRouterId
	}
	s.Ipv6TeRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId{}
	return s.Ipv6TeRouterId
}

// GetOrCreateIsAliasId retrieves the value of the IsAliasId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIsAliasId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId {
	if s.IsAliasId != nil {
		return s.IsAliasId
	}
	s.IsAliasId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId{}
	return s.IsAliasId
}

// GetOrCreateIsReachability retrieves the value of the IsReachability field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability {
	if s.IsReachability != nil {
		return s.IsReachability
	}
	s.IsReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability{}
	return s.IsReachability
}

// GetOrCreateIsisNeighborAttribute retrieves the value of the IsisNeighborAttribute field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute {
	if s.IsisNeighborAttribute != nil {
		return s.IsisNeighborAttribute
	}
	s.IsisNeighborAttribute = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute{}
	return s.IsisNeighborAttribute
}

// GetOrCreateLspBufferSize retrieves the value of the LspBufferSize field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateLspBufferSize() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize {
	if s.LspBufferSize != nil {
		return s.LspBufferSize
	}
	s.LspBufferSize = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize{}
	return s.LspBufferSize
}

// GetOrCreateMtIpv4Reachability retrieves the value of the MtIpv4Reachability field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability {
	if s.MtIpv4Reachability != nil {
		return s.MtIpv4Reachability
	}
	s.MtIpv4Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability{}
	return s.MtIpv4Reachability
}

// GetOrCreateMtIpv6Reachability retrieves the value of the MtIpv6Reachability field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability {
	if s.MtIpv6Reachability != nil {
		return s.MtIpv6Reachability
	}
	s.MtIpv6Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability{}
	return s.MtIpv6Reachability
}

// GetOrCreateMtIsisNeighborAttribute retrieves the value of the MtIsisNeighborAttribute field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute {
	if s.MtIsisNeighborAttribute != nil {
		return s.MtIsisNeighborAttribute
	}
	s.MtIsisNeighborAttribute = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute{}
	return s.MtIsisNeighborAttribute
}

// GetOrCreateMtIsn retrieves the value of the MtIsn field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIsn() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn {
	if s.MtIsn != nil {
		return s.MtIsn
	}
	s.MtIsn = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn{}
	return s.MtIsn
}

// GetOrCreateMultiTopology retrieves the value of the MultiTopology field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMultiTopology() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	if s.MultiTopology != nil {
		return s.MultiTopology
	}
	s.MultiTopology = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{}
	return s.MultiTopology
}

// GetOrCreateNlpid retrieves the value of the Nlpid field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateNlpid() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	if s.Nlpid != nil {
		return s.Nlpid
	}
	s.Nlpid = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{}
	return s.Nlpid
}

// GetOrCreatePurgeOi retrieves the value of the PurgeOi field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreatePurgeOi() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	if s.PurgeOi != nil {
		return s.PurgeOi
	}
	s.PurgeOi = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	return s.PurgeOi
}

// GetAreaAddress returns the value of the AreaAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field AreaAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetAreaAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	if s != nil && s.AreaAddress != nil {
		return s.AreaAddress
	}
	return nil
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetAuthentication() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	if s != nil && s.Authentication != nil {
		return s.Authentication
	}
	return nil
}

// GetExtendedIpv4Reachability returns the value of the ExtendedIpv4Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field ExtendedIpv4Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetExtendedIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	if s != nil && s.ExtendedIpv4Reachability != nil {
		return s.ExtendedIpv4Reachability
	}
	return nil
}

// GetExtendedIsReachability returns the value of the ExtendedIsReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field ExtendedIsReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetExtendedIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability {
	if s != nil && s.ExtendedIsReachability != nil {
		return s.ExtendedIsReachability
	}
	return nil
}

// GetHostname returns the value of the Hostname struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Hostname is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetHostname() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname {
	if s != nil && s.Hostname != nil {
		return s.Hostname
	}
	return nil
}

// GetIpv4ExternalReachability returns the value of the Ipv4ExternalReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4ExternalReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4ExternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability {
	if s != nil && s.Ipv4ExternalReachability != nil {
		return s.Ipv4ExternalReachability
	}
	return nil
}

// GetIpv4InterfaceAddresses returns the value of the Ipv4InterfaceAddresses struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4InterfaceAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses {
	if s != nil && s.Ipv4InterfaceAddresses != nil {
		return s.Ipv4InterfaceAddresses
	}
	return nil
}

// GetIpv4InternalReachability returns the value of the Ipv4InternalReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4InternalReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4InternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability {
	if s != nil && s.Ipv4InternalReachability != nil {
		return s.Ipv4InternalReachability
	}
	return nil
}

// GetIpv4TeRouterId returns the value of the Ipv4TeRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4TeRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId {
	if s != nil && s.Ipv4TeRouterId != nil {
		return s.Ipv4TeRouterId
	}
	return nil
}

// GetIpv6InterfaceAddresses returns the value of the Ipv6InterfaceAddresses struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv6InterfaceAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses {
	if s != nil && s.Ipv6InterfaceAddresses != nil {
		return s.Ipv6InterfaceAddresses
	}
	return nil
}

// GetIpv6Reachability returns the value of the Ipv6Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv6Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability {
	if s != nil && s.Ipv6Reachability != nil {
		return s.Ipv6Reachability
	}
	return nil
}

// GetIpv6TeRouterId returns the value of the Ipv6TeRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv6TeRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId {
	if s != nil && s.Ipv6TeRouterId != nil {
		return s.Ipv6TeRouterId
	}
	return nil
}

// GetIsAliasId returns the value of the IsAliasId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field IsAliasId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIsAliasId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId {
	if s != nil && s.IsAliasId != nil {
		return s.IsAliasId
	}
	return nil
}

// GetIsReachability returns the value of the IsReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field IsReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability {
	if s != nil && s.IsReachability != nil {
		return s.IsReachability
	}
	return nil
}

// GetIsisNeighborAttribute returns the value of the IsisNeighborAttribute struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field IsisNeighborAttribute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute {
	if s != nil && s.IsisNeighborAttribute != nil {
		return s.IsisNeighborAttribute
	}
	return nil
}

// GetLspBufferSize returns the value of the LspBufferSize struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field LspBufferSize is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetLspBufferSize() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize {
	if s != nil && s.LspBufferSize != nil {
		return s.LspBufferSize
	}
	return nil
}

// GetMtIpv4Reachability returns the value of the MtIpv4Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIpv4Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability {
	if s != nil && s.MtIpv4Reachability != nil {
		return s.MtIpv4Reachability
	}
	return nil
}

// GetMtIpv6Reachability returns the value of the MtIpv6Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIpv6Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability {
	if s != nil && s.MtIpv6Reachability != nil {
		return s.MtIpv6Reachability
	}
	return nil
}

// GetMtIsisNeighborAttribute returns the value of the MtIsisNeighborAttribute struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIsisNeighborAttribute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute {
	if s != nil && s.MtIsisNeighborAttribute != nil {
		return s.MtIsisNeighborAttribute
	}
	return nil
}

// GetMtIsn returns the value of the MtIsn struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIsn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIsn() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn {
	if s != nil && s.MtIsn != nil {
		return s.MtIsn
	}
	return nil
}

// GetMultiTopology returns the value of the MultiTopology struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MultiTopology is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMultiTopology() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	if s != nil && s.MultiTopology != nil {
		return s.MultiTopology
	}
	return nil
}

// GetNlpid returns the value of the Nlpid struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Nlpid is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetNlpid() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	if s != nil && s.Nlpid != nil {
		return s.Nlpid
	}
	return nil
}

// GetPurgeOi returns the value of the PurgeOi struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field PurgeOi is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetPurgeOi() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	if s != nil && s.PurgeOi != nil {
		return s.PurgeOi
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceNumber == nil {
		return nil, fmt.Errorf("nil value for key InstanceNumber")
	}

	return map[string]interface{}{
		"instance-number": *t.InstanceNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateSegmentRoutingAlgorithms retrieves the value of the SegmentRoutingAlgorithms field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetOrCreateSegmentRoutingAlgorithms() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	if s.SegmentRoutingAlgorithms != nil {
		return s.SegmentRoutingAlgorithms
	}
	s.SegmentRoutingAlgorithms = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
	return s.SegmentRoutingAlgorithms
}

// GetOrCreateSegmentRoutingCapability retrieves the value of the SegmentRoutingCapability field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetOrCreateSegmentRoutingCapability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	if s.SegmentRoutingCapability != nil {
		return s.SegmentRoutingCapability
	}
	s.SegmentRoutingCapability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
	return s.SegmentRoutingCapability
}

// GetSegmentRoutingAlgorithms returns the value of the SegmentRoutingAlgorithms struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv. If the receiver or the field SegmentRoutingAlgorithms is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetSegmentRoutingAlgorithms() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	if s != nil && s.SegmentRoutingAlgorithms != nil {
		return s.SegmentRoutingAlgorithms
	}
	return nil
}

// GetSegmentRoutingCapability returns the value of the SegmentRoutingCapability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv. If the receiver or the field SegmentRoutingCapability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetSegmentRoutingCapability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	if s != nil && s.SegmentRoutingCapability != nil {
		return s.SegmentRoutingCapability
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSrgbDescriptor creates a new entry in the SrgbDescriptor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) NewSrgbDescriptor(Range uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SrgbDescriptor == nil {
		t.SrgbDescriptor = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor)
	}

	key := Range

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SrgbDescriptor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SrgbDescriptor", key)
	}

	t.SrgbDescriptor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{
		Range: &Range,
	}

	return t.SrgbDescriptor[key], nil
}

// RenameSrgbDescriptor renames an entry in the list SrgbDescriptor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) RenameSrgbDescriptor(oldK, newK uint32) error {
	if _, ok := t.SrgbDescriptor[newK]; ok {
		return fmt.Errorf("key %v already exists in SrgbDescriptor", newK)
	}

	e, ok := t.SrgbDescriptor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SrgbDescriptor", oldK)
	}
	e.Range = &newK

	t.SrgbDescriptor[newK] = e
	delete(t.SrgbDescriptor, oldK)
	return nil
}

// GetOrCreateSrgbDescriptor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) GetOrCreateSrgbDescriptor(Range uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {

	key := Range

	if v, ok := t.SrgbDescriptor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrgbDescriptor(Range)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrgbDescriptor got unexpected error: %v", err))
	}
	return v
}

// GetSrgbDescriptor retrieves the value with the specified key from
// the SrgbDescriptor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) GetSrgbDescriptor(Range uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {

	if t == nil {
		return nil
	}

	key := Range

	if lm, ok := t.SrgbDescriptor[key]; ok {
		return lm
	}
	return nil
}

// AppendSrgbDescriptor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor struct to the
// list SrgbDescriptor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) AppendSrgbDescriptor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) error {
	key := *v.Range

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SrgbDescriptor == nil {
		t.SrgbDescriptor = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor)
	}

	if _, ok := t.SrgbDescriptor[key]; ok {
		return fmt.Errorf("duplicate key for list SrgbDescriptor %v", key)
	}

	t.SrgbDescriptor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Range == nil {
		return nil, fmt.Errorf("nil value for key Range")
	}

	return map[string]interface{}{
		"range": *t.Range,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) NewPrefix(Prefix string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) GetOrCreatePrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) GetPrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) NewPrefixSid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid{
		Value: &Value,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) RenamePrefixSid(oldK, newK uint32) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Value = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreatePrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid {

	key := Value

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetPrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// GetOrCreateFlags retrieves the value of the Flags field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	if s.Flags != nil {
		return s.Flags
	}
	s.Flags = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	return s.Flags
}

// GetOrCreateIpv4SourceRouterId retrieves the value of the Ipv4SourceRouterId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if s.Ipv4SourceRouterId != nil {
		return s.Ipv4SourceRouterId
	}
	s.Ipv4SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	return s.Ipv4SourceRouterId
}

// GetOrCreateIpv6SourceRouterId retrieves the value of the Ipv6SourceRouterId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if s.Ipv6SourceRouterId != nil {
		return s.Ipv6SourceRouterId
	}
	s.Ipv6SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	return s.Ipv6SourceRouterId
}

// GetOrCreateTag retrieves the value of the Tag field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag {
	if s.Tag != nil {
		return s.Tag
	}
	s.Tag = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag{}
	return s.Tag
}

// GetOrCreateTag64 retrieves the value of the Tag64 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64 {
	if s.Tag64 != nil {
		return s.Tag64
	}
	s.Tag64 = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64{}
	return s.Tag64
}

// GetFlags returns the value of the Flags struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Flags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	if s != nil && s.Flags != nil {
		return s.Flags
	}
	return nil
}

// GetIpv4SourceRouterId returns the value of the Ipv4SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Ipv4SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if s != nil && s.Ipv4SourceRouterId != nil {
		return s.Ipv4SourceRouterId
	}
	return nil
}

// GetIpv6SourceRouterId returns the value of the Ipv6SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Ipv6SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if s != nil && s.Ipv6SourceRouterId != nil {
		return s.Ipv6SourceRouterId
	}
	return nil
}

// GetTag returns the value of the Tag struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Tag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag {
	if s != nil && s.Tag != nil {
		return s.Tag
	}
	return nil
}

// GetTag64 returns the value of the Tag64 struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Tag64 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64 {
	if s != nil && s.Tag64 != nil {
		return s.Tag64
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) NewNeighbor(SystemId string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor{
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.SystemId = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) GetOrCreateNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor {

	key := SystemId

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) GetNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) AppendNeighbor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) error {
	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) NewAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid{
		Value: &Value,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) RenameAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Value = &newK

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid {

	key := Value

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewBandwidthConstraint creates a new entry in the BandwidthConstraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) NewBandwidthConstraint(ModelId uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint)
	}

	key := ModelId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthConstraint", key)
	}

	t.BandwidthConstraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint{
		ModelId: &ModelId,
	}

	return t.BandwidthConstraint[key], nil
}

// RenameBandwidthConstraint renames an entry in the list BandwidthConstraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) RenameBandwidthConstraint(oldK, newK uint8) error {
	if _, ok := t.BandwidthConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthConstraint", newK)
	}

	e, ok := t.BandwidthConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthConstraint", oldK)
	}
	e.ModelId = &newK

	t.BandwidthConstraint[newK] = e
	delete(t.BandwidthConstraint, oldK)
	return nil
}

// GetOrCreateBandwidthConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint {

	key := ModelId

	if v, ok := t.BandwidthConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthConstraint(ModelId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthConstraint got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthConstraint retrieves the value with the specified key from
// the BandwidthConstraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint {

	if t == nil {
		return nil
	}

	key := ModelId

	if lm, ok := t.BandwidthConstraint[key]; ok {
		return lm
	}
	return nil
}

// AppendBandwidthConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint struct to the
// list BandwidthConstraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) AppendBandwidthConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint) error {
	key := *v.ModelId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint)
	}

	if _, ok := t.BandwidthConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthConstraint %v", key)
	}

	t.BandwidthConstraint[key] = v
	return nil
}

// NewLanAdjacencySid creates a new entry in the LanAdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) NewLanAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LanAdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LanAdjacencySid", key)
	}

	t.LanAdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid{
		Value: &Value,
	}

	return t.LanAdjacencySid[key], nil
}

// RenameLanAdjacencySid renames an entry in the list LanAdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) RenameLanAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.LanAdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in LanAdjacencySid", newK)
	}

	e, ok := t.LanAdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LanAdjacencySid", oldK)
	}
	e.Value = &newK

	t.LanAdjacencySid[newK] = e
	delete(t.LanAdjacencySid, oldK)
	return nil
}

// GetOrCreateLanAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid {

	key := Value

	if v, ok := t.LanAdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLanAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLanAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetLanAdjacencySid retrieves the value with the specified key from
// the LanAdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.LanAdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// AppendLanAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid struct to the
// list LanAdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) AppendLanAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid)
	}

	if _, ok := t.LanAdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list LanAdjacencySid %v", key)
	}

	t.LanAdjacencySid[key] = v
	return nil
}

// NewSetupPriority creates a new entry in the SetupPriority list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) NewSetupPriority(Priority uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SetupPriority[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SetupPriority", key)
	}

	t.SetupPriority[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority{
		Priority: &Priority,
	}

	return t.SetupPriority[key], nil
}

// RenameSetupPriority renames an entry in the list SetupPriority within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) RenameSetupPriority(oldK, newK uint8) error {
	if _, ok := t.SetupPriority[newK]; ok {
		return fmt.Errorf("key %v already exists in SetupPriority", newK)
	}

	e, ok := t.SetupPriority[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SetupPriority", oldK)
	}
	e.Priority = &newK

	t.SetupPriority[newK] = e
	delete(t.SetupPriority, oldK)
	return nil
}

// GetOrCreateSetupPriority retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority {

	key := Priority

	if v, ok := t.SetupPriority[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSetupPriority(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSetupPriority got unexpected error: %v", err))
	}
	return v
}

// GetSetupPriority retrieves the value with the specified key from
// the SetupPriority map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.SetupPriority[key]; ok {
		return lm
	}
	return nil
}

// AppendSetupPriority appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority struct to the
// list SetupPriority of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) AppendSetupPriority(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority) error {
	key := *v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority)
	}

	if _, ok := t.SetupPriority[key]; ok {
		return fmt.Errorf("duplicate key for list SetupPriority %v", key)
	}

	t.SetupPriority[key] = v
	return nil
}

// GetOrCreateAdminGroup retrieves the value of the AdminGroup field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdminGroup {
	if s.AdminGroup != nil {
		return s.AdminGroup
	}
	s.AdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdminGroup{}
	return s.AdminGroup
}

// GetOrCreateAvailableBandwidth retrieves the value of the AvailableBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AvailableBandwidth {
	if s.AvailableBandwidth != nil {
		return s.AvailableBandwidth
	}
	s.AvailableBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AvailableBandwidth{}
	return s.AvailableBandwidth
}

// GetOrCreateExtendedAdminGroup retrieves the value of the ExtendedAdminGroup field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ExtendedAdminGroup {
	if s.ExtendedAdminGroup != nil {
		return s.ExtendedAdminGroup
	}
	s.ExtendedAdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ExtendedAdminGroup{}
	return s.ExtendedAdminGroup
}

// GetOrCreateIpv4InterfaceAddress retrieves the value of the Ipv4InterfaceAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4InterfaceAddress {
	if s.Ipv4InterfaceAddress != nil {
		return s.Ipv4InterfaceAddress
	}
	s.Ipv4InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4InterfaceAddress{}
	return s.Ipv4InterfaceAddress
}

// GetOrCreateIpv4NeighborAddress retrieves the value of the Ipv4NeighborAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4NeighborAddress {
	if s.Ipv4NeighborAddress != nil {
		return s.Ipv4NeighborAddress
	}
	s.Ipv4NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4NeighborAddress{}
	return s.Ipv4NeighborAddress
}

// GetOrCreateIpv6InterfaceAddress retrieves the value of the Ipv6InterfaceAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6InterfaceAddress {
	if s.Ipv6InterfaceAddress != nil {
		return s.Ipv6InterfaceAddress
	}
	s.Ipv6InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6InterfaceAddress{}
	return s.Ipv6InterfaceAddress
}

// GetOrCreateIpv6NeighborAddress retrieves the value of the Ipv6NeighborAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6NeighborAddress {
	if s.Ipv6NeighborAddress != nil {
		return s.Ipv6NeighborAddress
	}
	s.Ipv6NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6NeighborAddress{}
	return s.Ipv6NeighborAddress
}

// GetOrCreateLinkAttributes retrieves the value of the LinkAttributes field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkAttributes {
	if s.LinkAttributes != nil {
		return s.LinkAttributes
	}
	s.LinkAttributes = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkAttributes{}
	return s.LinkAttributes
}

// GetOrCreateLinkDelay retrieves the value of the LinkDelay field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelay {
	if s.LinkDelay != nil {
		return s.LinkDelay
	}
	s.LinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelay{}
	return s.LinkDelay
}

// GetOrCreateLinkDelayVariation retrieves the value of the LinkDelayVariation field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelayVariation {
	if s.LinkDelayVariation != nil {
		return s.LinkDelayVariation
	}
	s.LinkDelayVariation = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelayVariation{}
	return s.LinkDelayVariation
}

// GetOrCreateLinkId retrieves the value of the LinkId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkId {
	if s.LinkId != nil {
		return s.LinkId
	}
	s.LinkId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkId{}
	return s.LinkId
}

// GetOrCreateLinkLoss retrieves the value of the LinkLoss field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkLoss {
	if s.LinkLoss != nil {
		return s.LinkLoss
	}
	s.LinkLoss = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkLoss{}
	return s.LinkLoss
}

// GetOrCreateLinkProtectionType retrieves the value of the LinkProtectionType field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkProtectionType {
	if s.LinkProtectionType != nil {
		return s.LinkProtectionType
	}
	s.LinkProtectionType = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkProtectionType{}
	return s.LinkProtectionType
}

// GetOrCreateMaxLinkBandwidth retrieves the value of the MaxLinkBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxLinkBandwidth {
	if s.MaxLinkBandwidth != nil {
		return s.MaxLinkBandwidth
	}
	s.MaxLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxLinkBandwidth{}
	return s.MaxLinkBandwidth
}

// GetOrCreateMaxReservableLinkBandwidth retrieves the value of the MaxReservableLinkBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxReservableLinkBandwidth {
	if s.MaxReservableLinkBandwidth != nil {
		return s.MaxReservableLinkBandwidth
	}
	s.MaxReservableLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxReservableLinkBandwidth{}
	return s.MaxReservableLinkBandwidth
}

// GetOrCreateMinMaxLinkDelay retrieves the value of the MinMaxLinkDelay field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MinMaxLinkDelay {
	if s.MinMaxLinkDelay != nil {
		return s.MinMaxLinkDelay
	}
	s.MinMaxLinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MinMaxLinkDelay{}
	return s.MinMaxLinkDelay
}

// GetOrCreateResidualBandwidth retrieves the value of the ResidualBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ResidualBandwidth {
	if s.ResidualBandwidth != nil {
		return s.ResidualBandwidth
	}
	s.ResidualBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ResidualBandwidth{}
	return s.ResidualBandwidth
}

// GetOrCreateTeDefaultMetric retrieves the value of the TeDefaultMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_TeDefaultMetric {
	if s.TeDefaultMetric != nil {
		return s.TeDefaultMetric
	}
	s.TeDefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_TeDefaultMetric{}
	return s.TeDefaultMetric
}

// GetOrCreateUnconstrainedLsp retrieves the value of the UnconstrainedLsp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UnconstrainedLsp {
	if s.UnconstrainedLsp != nil {
		return s.UnconstrainedLsp
	}
	s.UnconstrainedLsp = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UnconstrainedLsp{}
	return s.UnconstrainedLsp
}

// GetOrCreateUtilizedBandwidth retrieves the value of the UtilizedBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetOrCreateUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UtilizedBandwidth {
	if s.UtilizedBandwidth != nil {
		return s.UtilizedBandwidth
	}
	s.UtilizedBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UtilizedBandwidth{}
	return s.UtilizedBandwidth
}

// GetAdminGroup returns the value of the AdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field AdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdminGroup {
	if s != nil && s.AdminGroup != nil {
		return s.AdminGroup
	}
	return nil
}

// GetAvailableBandwidth returns the value of the AvailableBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field AvailableBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AvailableBandwidth {
	if s != nil && s.AvailableBandwidth != nil {
		return s.AvailableBandwidth
	}
	return nil
}

// GetExtendedAdminGroup returns the value of the ExtendedAdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field ExtendedAdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ExtendedAdminGroup {
	if s != nil && s.ExtendedAdminGroup != nil {
		return s.ExtendedAdminGroup
	}
	return nil
}

// GetIpv4InterfaceAddress returns the value of the Ipv4InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field Ipv4InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4InterfaceAddress {
	if s != nil && s.Ipv4InterfaceAddress != nil {
		return s.Ipv4InterfaceAddress
	}
	return nil
}

// GetIpv4NeighborAddress returns the value of the Ipv4NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field Ipv4NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4NeighborAddress {
	if s != nil && s.Ipv4NeighborAddress != nil {
		return s.Ipv4NeighborAddress
	}
	return nil
}

// GetIpv6InterfaceAddress returns the value of the Ipv6InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field Ipv6InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6InterfaceAddress {
	if s != nil && s.Ipv6InterfaceAddress != nil {
		return s.Ipv6InterfaceAddress
	}
	return nil
}

// GetIpv6NeighborAddress returns the value of the Ipv6NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field Ipv6NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6NeighborAddress {
	if s != nil && s.Ipv6NeighborAddress != nil {
		return s.Ipv6NeighborAddress
	}
	return nil
}

// GetLinkAttributes returns the value of the LinkAttributes struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field LinkAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkAttributes {
	if s != nil && s.LinkAttributes != nil {
		return s.LinkAttributes
	}
	return nil
}

// GetLinkDelay returns the value of the LinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field LinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelay {
	if s != nil && s.LinkDelay != nil {
		return s.LinkDelay
	}
	return nil
}

// GetLinkDelayVariation returns the value of the LinkDelayVariation struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field LinkDelayVariation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelayVariation {
	if s != nil && s.LinkDelayVariation != nil {
		return s.LinkDelayVariation
	}
	return nil
}

// GetLinkId returns the value of the LinkId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field LinkId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkId {
	if s != nil && s.LinkId != nil {
		return s.LinkId
	}
	return nil
}

// GetLinkLoss returns the value of the LinkLoss struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field LinkLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkLoss {
	if s != nil && s.LinkLoss != nil {
		return s.LinkLoss
	}
	return nil
}

// GetLinkProtectionType returns the value of the LinkProtectionType struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field LinkProtectionType is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkProtectionType {
	if s != nil && s.LinkProtectionType != nil {
		return s.LinkProtectionType
	}
	return nil
}

// GetMaxLinkBandwidth returns the value of the MaxLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field MaxLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxLinkBandwidth {
	if s != nil && s.MaxLinkBandwidth != nil {
		return s.MaxLinkBandwidth
	}
	return nil
}

// GetMaxReservableLinkBandwidth returns the value of the MaxReservableLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field MaxReservableLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxReservableLinkBandwidth {
	if s != nil && s.MaxReservableLinkBandwidth != nil {
		return s.MaxReservableLinkBandwidth
	}
	return nil
}

// GetMinMaxLinkDelay returns the value of the MinMaxLinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field MinMaxLinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MinMaxLinkDelay {
	if s != nil && s.MinMaxLinkDelay != nil {
		return s.MinMaxLinkDelay
	}
	return nil
}

// GetResidualBandwidth returns the value of the ResidualBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field ResidualBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ResidualBandwidth {
	if s != nil && s.ResidualBandwidth != nil {
		return s.ResidualBandwidth
	}
	return nil
}

// GetTeDefaultMetric returns the value of the TeDefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field TeDefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_TeDefaultMetric {
	if s != nil && s.TeDefaultMetric != nil {
		return s.TeDefaultMetric
	}
	return nil
}

// GetUnconstrainedLsp returns the value of the UnconstrainedLsp struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field UnconstrainedLsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UnconstrainedLsp {
	if s != nil && s.UnconstrainedLsp != nil {
		return s.UnconstrainedLsp
	}
	return nil
}

// GetUtilizedBandwidth returns the value of the UtilizedBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv. If the receiver or the field UtilizedBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) GetUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UtilizedBandwidth {
	if s != nil && s.UtilizedBandwidth != nil {
		return s.UtilizedBandwidth
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdminGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AvailableBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AvailableBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_AvailableBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewConstraint creates a new entry in the Constraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint) NewConstraint(ConstraintId uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint)
	}

	key := ConstraintId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Constraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Constraint", key)
	}

	t.Constraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint{
		ConstraintId: &ConstraintId,
	}

	return t.Constraint[key], nil
}

// RenameConstraint renames an entry in the list Constraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint) RenameConstraint(oldK, newK uint32) error {
	if _, ok := t.Constraint[newK]; ok {
		return fmt.Errorf("key %v already exists in Constraint", newK)
	}

	e, ok := t.Constraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Constraint", oldK)
	}
	e.ConstraintId = &newK

	t.Constraint[newK] = e
	delete(t.Constraint, oldK)
	return nil
}

// GetOrCreateConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint) GetOrCreateConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint {

	key := ConstraintId

	if v, ok := t.Constraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConstraint(ConstraintId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConstraint got unexpected error: %v", err))
	}
	return v
}

// GetConstraint retrieves the value with the specified key from
// the Constraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint) GetConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint {

	if t == nil {
		return nil
	}

	key := ConstraintId

	if lm, ok := t.Constraint[key]; ok {
		return lm
	}
	return nil
}

// AppendConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint struct to the
// list Constraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint) AppendConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint) error {
	key := *v.ConstraintId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint)
	}

	if _, ok := t.Constraint[key]; ok {
		return fmt.Errorf("duplicate key for list Constraint %v", key)
	}

	t.Constraint[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ModelId == nil {
		return nil, fmt.Errorf("nil value for key ModelId")
	}

	return map[string]interface{}{
		"model-id": *t.ModelId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConstraintId == nil {
		return nil, fmt.Errorf("nil value for key ConstraintId")
	}

	return map[string]interface{}{
		"constraint-id": *t.ConstraintId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_BandwidthConstraint_Constraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ExtendedAdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ExtendedAdminGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ExtendedAdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4InterfaceAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4NeighborAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv4NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6InterfaceAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6NeighborAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_Ipv6NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LanAdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkAttributes"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelay"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelayVariation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelayVariation"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkDelayVariation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkLoss"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkProtectionType) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkProtectionType"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_LinkProtectionType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxLinkBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxReservableLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxReservableLinkBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MaxReservableLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MinMaxLinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MinMaxLinkDelay"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_MinMaxLinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ResidualBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ResidualBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_ResidualBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Priority == nil {
		return nil, fmt.Errorf("nil value for key Priority")
	}

	return map[string]interface{}{
		"priority": *t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_SetupPriority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_TeDefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_TeDefaultMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_TeDefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UnconstrainedLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UnconstrainedLsp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UnconstrainedLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UtilizedBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UtilizedBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Subtlv_UtilizedBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceId == nil {
		return nil, fmt.Errorf("nil value for key InstanceId")
	}

	return map[string]interface{}{
		"instance-id": *t.InstanceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) NewPrefix(Prefix string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) GetOrCreatePrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) GetPrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateDefaultMetric retrieves the value of the DefaultMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetOrCreateDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric {
	if s.DefaultMetric != nil {
		return s.DefaultMetric
	}
	s.DefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric{}
	return s.DefaultMetric
}

// GetOrCreateDelayMetric retrieves the value of the DelayMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetOrCreateDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric {
	if s.DelayMetric != nil {
		return s.DelayMetric
	}
	s.DelayMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric{}
	return s.DelayMetric
}

// GetOrCreateErrorMetric retrieves the value of the ErrorMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetOrCreateErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric {
	if s.ErrorMetric != nil {
		return s.ErrorMetric
	}
	s.ErrorMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric{}
	return s.ErrorMetric
}

// GetOrCreateExpenseMetric retrieves the value of the ExpenseMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetOrCreateExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric {
	if s.ExpenseMetric != nil {
		return s.ExpenseMetric
	}
	s.ExpenseMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric{}
	return s.ExpenseMetric
}

// GetDefaultMetric returns the value of the DefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix. If the receiver or the field DefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric {
	if s != nil && s.DefaultMetric != nil {
		return s.DefaultMetric
	}
	return nil
}

// GetDelayMetric returns the value of the DelayMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix. If the receiver or the field DelayMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric {
	if s != nil && s.DelayMetric != nil {
		return s.DelayMetric
	}
	return nil
}

// GetErrorMetric returns the value of the ErrorMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix. If the receiver or the field ErrorMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric {
	if s != nil && s.ErrorMetric != nil {
		return s.ErrorMetric
	}
	return nil
}

// GetExpenseMetric returns the value of the ExpenseMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix. If the receiver or the field ExpenseMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) GetExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric {
	if s != nil && s.ExpenseMetric != nil {
		return s.ExpenseMetric
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_DelayMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ErrorMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability_Prefix_ExpenseMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) NewPrefix(Prefix string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) GetOrCreatePrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) GetPrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateDefaultMetric retrieves the value of the DefaultMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetOrCreateDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric {
	if s.DefaultMetric != nil {
		return s.DefaultMetric
	}
	s.DefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric{}
	return s.DefaultMetric
}

// GetOrCreateDelayMetric retrieves the value of the DelayMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetOrCreateDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric {
	if s.DelayMetric != nil {
		return s.DelayMetric
	}
	s.DelayMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric{}
	return s.DelayMetric
}

// GetOrCreateErrorMetric retrieves the value of the ErrorMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetOrCreateErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric {
	if s.ErrorMetric != nil {
		return s.ErrorMetric
	}
	s.ErrorMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric{}
	return s.ErrorMetric
}

// GetOrCreateExpenseMetric retrieves the value of the ExpenseMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetOrCreateExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric {
	if s.ExpenseMetric != nil {
		return s.ExpenseMetric
	}
	s.ExpenseMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric{}
	return s.ExpenseMetric
}

// GetDefaultMetric returns the value of the DefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix. If the receiver or the field DefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric {
	if s != nil && s.DefaultMetric != nil {
		return s.DefaultMetric
	}
	return nil
}

// GetDelayMetric returns the value of the DelayMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix. If the receiver or the field DelayMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric {
	if s != nil && s.DelayMetric != nil {
		return s.DelayMetric
	}
	return nil
}

// GetErrorMetric returns the value of the ErrorMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix. If the receiver or the field ErrorMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric {
	if s != nil && s.ErrorMetric != nil {
		return s.ErrorMetric
	}
	return nil
}

// GetExpenseMetric returns the value of the ExpenseMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix. If the receiver or the field ExpenseMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) GetExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric {
	if s != nil && s.ExpenseMetric != nil {
		return s.ExpenseMetric
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_DelayMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ErrorMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability_Prefix_ExpenseMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceNumber == nil {
		return nil, fmt.Errorf("nil value for key InstanceNumber")
	}

	return map[string]interface{}{
		"instance-number": *t.InstanceNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) NewPrefix(Prefix string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) GetOrCreatePrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) GetPrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) error {
	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) NewPrefixSid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid{
		Value: &Value,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) RenamePrefixSid(oldK, newK uint32) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Value = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreatePrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid {

	key := Value

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetPrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// GetOrCreateFlags retrieves the value of the Flags field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreateFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags {
	if s.Flags != nil {
		return s.Flags
	}
	s.Flags = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags{}
	return s.Flags
}

// GetOrCreateIpv4SourceRouterId retrieves the value of the Ipv4SourceRouterId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreateIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if s.Ipv4SourceRouterId != nil {
		return s.Ipv4SourceRouterId
	}
	s.Ipv4SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	return s.Ipv4SourceRouterId
}

// GetOrCreateIpv6SourceRouterId retrieves the value of the Ipv6SourceRouterId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreateIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if s.Ipv6SourceRouterId != nil {
		return s.Ipv6SourceRouterId
	}
	s.Ipv6SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	return s.Ipv6SourceRouterId
}

// GetOrCreateTag retrieves the value of the Tag field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreateTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag {
	if s.Tag != nil {
		return s.Tag
	}
	s.Tag = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag{}
	return s.Tag
}

// GetOrCreateTag64 retrieves the value of the Tag64 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetOrCreateTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64 {
	if s.Tag64 != nil {
		return s.Tag64
	}
	s.Tag64 = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64{}
	return s.Tag64
}

// GetFlags returns the value of the Flags struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver or the field Flags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags {
	if s != nil && s.Flags != nil {
		return s.Flags
	}
	return nil
}

// GetIpv4SourceRouterId returns the value of the Ipv4SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver or the field Ipv4SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if s != nil && s.Ipv4SourceRouterId != nil {
		return s.Ipv4SourceRouterId
	}
	return nil
}

// GetIpv6SourceRouterId returns the value of the Ipv6SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver or the field Ipv6SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if s != nil && s.Ipv6SourceRouterId != nil {
		return s.Ipv6SourceRouterId
	}
	return nil
}

// GetTag returns the value of the Tag struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver or the field Tag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag {
	if s != nil && s.Tag != nil {
		return s.Tag
	}
	return nil
}

// GetTag64 returns the value of the Tag64 struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv. If the receiver or the field Tag64 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) GetTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64 {
	if s != nil && s.Tag64 != nil {
		return s.Tag64
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Flags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_Subtlv_Tag64) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability_Prefix_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceNumber == nil {
		return nil, fmt.Errorf("nil value for key InstanceNumber")
	}

	return map[string]interface{}{
		"instance-number": *t.InstanceNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) NewNeighbor(SystemId string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor{
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.SystemId = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) GetOrCreateNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor {

	key := SystemId

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) GetNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) AppendNeighbor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) error {
	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateDefaultMetric retrieves the value of the DefaultMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetOrCreateDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric {
	if s.DefaultMetric != nil {
		return s.DefaultMetric
	}
	s.DefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric{}
	return s.DefaultMetric
}

// GetOrCreateDelayMetric retrieves the value of the DelayMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetOrCreateDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric {
	if s.DelayMetric != nil {
		return s.DelayMetric
	}
	s.DelayMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric{}
	return s.DelayMetric
}

// GetOrCreateErrorMetric retrieves the value of the ErrorMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetOrCreateErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric {
	if s.ErrorMetric != nil {
		return s.ErrorMetric
	}
	s.ErrorMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric{}
	return s.ErrorMetric
}

// GetOrCreateExpenseMetric retrieves the value of the ExpenseMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetOrCreateExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric {
	if s.ExpenseMetric != nil {
		return s.ExpenseMetric
	}
	s.ExpenseMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric{}
	return s.ExpenseMetric
}

// GetDefaultMetric returns the value of the DefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor. If the receiver or the field DefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric {
	if s != nil && s.DefaultMetric != nil {
		return s.DefaultMetric
	}
	return nil
}

// GetDelayMetric returns the value of the DelayMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor. If the receiver or the field DelayMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetDelayMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric {
	if s != nil && s.DelayMetric != nil {
		return s.DelayMetric
	}
	return nil
}

// GetErrorMetric returns the value of the ErrorMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor. If the receiver or the field ErrorMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetErrorMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric {
	if s != nil && s.ErrorMetric != nil {
		return s.ErrorMetric
	}
	return nil
}

// GetExpenseMetric returns the value of the ExpenseMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor. If the receiver or the field ExpenseMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) GetExpenseMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric {
	if s != nil && s.ExpenseMetric != nil {
		return s.ExpenseMetric
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_DelayMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ErrorMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability_Neighbor_ExpenseMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) NewNeighbor(SystemId string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor{
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.SystemId = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) GetOrCreateNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor {

	key := SystemId

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) GetNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) AppendNeighbor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) error {
	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) NewAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid{
		Value: &Value,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) RenameAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Value = &newK

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid {

	key := Value

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewBandwidthConstraint creates a new entry in the BandwidthConstraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) NewBandwidthConstraint(ModelId uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint)
	}

	key := ModelId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthConstraint", key)
	}

	t.BandwidthConstraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint{
		ModelId: &ModelId,
	}

	return t.BandwidthConstraint[key], nil
}

// RenameBandwidthConstraint renames an entry in the list BandwidthConstraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) RenameBandwidthConstraint(oldK, newK uint8) error {
	if _, ok := t.BandwidthConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthConstraint", newK)
	}

	e, ok := t.BandwidthConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthConstraint", oldK)
	}
	e.ModelId = &newK

	t.BandwidthConstraint[newK] = e
	delete(t.BandwidthConstraint, oldK)
	return nil
}

// GetOrCreateBandwidthConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint {

	key := ModelId

	if v, ok := t.BandwidthConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthConstraint(ModelId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthConstraint got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthConstraint retrieves the value with the specified key from
// the BandwidthConstraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint {

	if t == nil {
		return nil
	}

	key := ModelId

	if lm, ok := t.BandwidthConstraint[key]; ok {
		return lm
	}
	return nil
}

// AppendBandwidthConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint struct to the
// list BandwidthConstraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) AppendBandwidthConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) error {
	key := *v.ModelId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint)
	}

	if _, ok := t.BandwidthConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthConstraint %v", key)
	}

	t.BandwidthConstraint[key] = v
	return nil
}

// NewLanAdjacencySid creates a new entry in the LanAdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) NewLanAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LanAdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LanAdjacencySid", key)
	}

	t.LanAdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid{
		Value: &Value,
	}

	return t.LanAdjacencySid[key], nil
}

// RenameLanAdjacencySid renames an entry in the list LanAdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) RenameLanAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.LanAdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in LanAdjacencySid", newK)
	}

	e, ok := t.LanAdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LanAdjacencySid", oldK)
	}
	e.Value = &newK

	t.LanAdjacencySid[newK] = e
	delete(t.LanAdjacencySid, oldK)
	return nil
}

// GetOrCreateLanAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid {

	key := Value

	if v, ok := t.LanAdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLanAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLanAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetLanAdjacencySid retrieves the value with the specified key from
// the LanAdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.LanAdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// AppendLanAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid struct to the
// list LanAdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) AppendLanAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid)
	}

	if _, ok := t.LanAdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list LanAdjacencySid %v", key)
	}

	t.LanAdjacencySid[key] = v
	return nil
}

// NewSetupPriority creates a new entry in the SetupPriority list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) NewSetupPriority(Priority uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SetupPriority[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SetupPriority", key)
	}

	t.SetupPriority[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority{
		Priority: &Priority,
	}

	return t.SetupPriority[key], nil
}

// RenameSetupPriority renames an entry in the list SetupPriority within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) RenameSetupPriority(oldK, newK uint8) error {
	if _, ok := t.SetupPriority[newK]; ok {
		return fmt.Errorf("key %v already exists in SetupPriority", newK)
	}

	e, ok := t.SetupPriority[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SetupPriority", oldK)
	}
	e.Priority = &newK

	t.SetupPriority[newK] = e
	delete(t.SetupPriority, oldK)
	return nil
}

// GetOrCreateSetupPriority retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority {

	key := Priority

	if v, ok := t.SetupPriority[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSetupPriority(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSetupPriority got unexpected error: %v", err))
	}
	return v
}

// GetSetupPriority retrieves the value with the specified key from
// the SetupPriority map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.SetupPriority[key]; ok {
		return lm
	}
	return nil
}

// AppendSetupPriority appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority struct to the
// list SetupPriority of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) AppendSetupPriority(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority) error {
	key := *v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority)
	}

	if _, ok := t.SetupPriority[key]; ok {
		return fmt.Errorf("duplicate key for list SetupPriority %v", key)
	}

	t.SetupPriority[key] = v
	return nil
}

// GetOrCreateAdminGroup retrieves the value of the AdminGroup field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdminGroup {
	if s.AdminGroup != nil {
		return s.AdminGroup
	}
	s.AdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdminGroup{}
	return s.AdminGroup
}

// GetOrCreateAvailableBandwidth retrieves the value of the AvailableBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth {
	if s.AvailableBandwidth != nil {
		return s.AvailableBandwidth
	}
	s.AvailableBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth{}
	return s.AvailableBandwidth
}

// GetOrCreateExtendedAdminGroup retrieves the value of the ExtendedAdminGroup field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup {
	if s.ExtendedAdminGroup != nil {
		return s.ExtendedAdminGroup
	}
	s.ExtendedAdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup{}
	return s.ExtendedAdminGroup
}

// GetOrCreateIpv4InterfaceAddress retrieves the value of the Ipv4InterfaceAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress {
	if s.Ipv4InterfaceAddress != nil {
		return s.Ipv4InterfaceAddress
	}
	s.Ipv4InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress{}
	return s.Ipv4InterfaceAddress
}

// GetOrCreateIpv4NeighborAddress retrieves the value of the Ipv4NeighborAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress {
	if s.Ipv4NeighborAddress != nil {
		return s.Ipv4NeighborAddress
	}
	s.Ipv4NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress{}
	return s.Ipv4NeighborAddress
}

// GetOrCreateIpv6InterfaceAddress retrieves the value of the Ipv6InterfaceAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress {
	if s.Ipv6InterfaceAddress != nil {
		return s.Ipv6InterfaceAddress
	}
	s.Ipv6InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress{}
	return s.Ipv6InterfaceAddress
}

// GetOrCreateIpv6NeighborAddress retrieves the value of the Ipv6NeighborAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress {
	if s.Ipv6NeighborAddress != nil {
		return s.Ipv6NeighborAddress
	}
	s.Ipv6NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress{}
	return s.Ipv6NeighborAddress
}

// GetOrCreateLinkAttributes retrieves the value of the LinkAttributes field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes {
	if s.LinkAttributes != nil {
		return s.LinkAttributes
	}
	s.LinkAttributes = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes{}
	return s.LinkAttributes
}

// GetOrCreateLinkDelay retrieves the value of the LinkDelay field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelay {
	if s.LinkDelay != nil {
		return s.LinkDelay
	}
	s.LinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelay{}
	return s.LinkDelay
}

// GetOrCreateLinkDelayVariation retrieves the value of the LinkDelayVariation field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation {
	if s.LinkDelayVariation != nil {
		return s.LinkDelayVariation
	}
	s.LinkDelayVariation = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation{}
	return s.LinkDelayVariation
}

// GetOrCreateLinkId retrieves the value of the LinkId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkId {
	if s.LinkId != nil {
		return s.LinkId
	}
	s.LinkId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkId{}
	return s.LinkId
}

// GetOrCreateLinkLoss retrieves the value of the LinkLoss field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkLoss {
	if s.LinkLoss != nil {
		return s.LinkLoss
	}
	s.LinkLoss = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkLoss{}
	return s.LinkLoss
}

// GetOrCreateLinkProtectionType retrieves the value of the LinkProtectionType field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType {
	if s.LinkProtectionType != nil {
		return s.LinkProtectionType
	}
	s.LinkProtectionType = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType{}
	return s.LinkProtectionType
}

// GetOrCreateMaxLinkBandwidth retrieves the value of the MaxLinkBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth {
	if s.MaxLinkBandwidth != nil {
		return s.MaxLinkBandwidth
	}
	s.MaxLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth{}
	return s.MaxLinkBandwidth
}

// GetOrCreateMaxReservableLinkBandwidth retrieves the value of the MaxReservableLinkBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth {
	if s.MaxReservableLinkBandwidth != nil {
		return s.MaxReservableLinkBandwidth
	}
	s.MaxReservableLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth{}
	return s.MaxReservableLinkBandwidth
}

// GetOrCreateMinMaxLinkDelay retrieves the value of the MinMaxLinkDelay field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay {
	if s.MinMaxLinkDelay != nil {
		return s.MinMaxLinkDelay
	}
	s.MinMaxLinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay{}
	return s.MinMaxLinkDelay
}

// GetOrCreateResidualBandwidth retrieves the value of the ResidualBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth {
	if s.ResidualBandwidth != nil {
		return s.ResidualBandwidth
	}
	s.ResidualBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth{}
	return s.ResidualBandwidth
}

// GetOrCreateTeDefaultMetric retrieves the value of the TeDefaultMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric {
	if s.TeDefaultMetric != nil {
		return s.TeDefaultMetric
	}
	s.TeDefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric{}
	return s.TeDefaultMetric
}

// GetOrCreateUnconstrainedLsp retrieves the value of the UnconstrainedLsp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp {
	if s.UnconstrainedLsp != nil {
		return s.UnconstrainedLsp
	}
	s.UnconstrainedLsp = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp{}
	return s.UnconstrainedLsp
}

// GetOrCreateUtilizedBandwidth retrieves the value of the UtilizedBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth {
	if s.UtilizedBandwidth != nil {
		return s.UtilizedBandwidth
	}
	s.UtilizedBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth{}
	return s.UtilizedBandwidth
}

// GetAdminGroup returns the value of the AdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field AdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdminGroup {
	if s != nil && s.AdminGroup != nil {
		return s.AdminGroup
	}
	return nil
}

// GetAvailableBandwidth returns the value of the AvailableBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field AvailableBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth {
	if s != nil && s.AvailableBandwidth != nil {
		return s.AvailableBandwidth
	}
	return nil
}

// GetExtendedAdminGroup returns the value of the ExtendedAdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field ExtendedAdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup {
	if s != nil && s.ExtendedAdminGroup != nil {
		return s.ExtendedAdminGroup
	}
	return nil
}

// GetIpv4InterfaceAddress returns the value of the Ipv4InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field Ipv4InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress {
	if s != nil && s.Ipv4InterfaceAddress != nil {
		return s.Ipv4InterfaceAddress
	}
	return nil
}

// GetIpv4NeighborAddress returns the value of the Ipv4NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field Ipv4NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress {
	if s != nil && s.Ipv4NeighborAddress != nil {
		return s.Ipv4NeighborAddress
	}
	return nil
}

// GetIpv6InterfaceAddress returns the value of the Ipv6InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field Ipv6InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress {
	if s != nil && s.Ipv6InterfaceAddress != nil {
		return s.Ipv6InterfaceAddress
	}
	return nil
}

// GetIpv6NeighborAddress returns the value of the Ipv6NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field Ipv6NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress {
	if s != nil && s.Ipv6NeighborAddress != nil {
		return s.Ipv6NeighborAddress
	}
	return nil
}

// GetLinkAttributes returns the value of the LinkAttributes struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes {
	if s != nil && s.LinkAttributes != nil {
		return s.LinkAttributes
	}
	return nil
}

// GetLinkDelay returns the value of the LinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelay {
	if s != nil && s.LinkDelay != nil {
		return s.LinkDelay
	}
	return nil
}

// GetLinkDelayVariation returns the value of the LinkDelayVariation struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkDelayVariation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation {
	if s != nil && s.LinkDelayVariation != nil {
		return s.LinkDelayVariation
	}
	return nil
}

// GetLinkId returns the value of the LinkId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkId {
	if s != nil && s.LinkId != nil {
		return s.LinkId
	}
	return nil
}

// GetLinkLoss returns the value of the LinkLoss struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkLoss {
	if s != nil && s.LinkLoss != nil {
		return s.LinkLoss
	}
	return nil
}

// GetLinkProtectionType returns the value of the LinkProtectionType struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkProtectionType is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType {
	if s != nil && s.LinkProtectionType != nil {
		return s.LinkProtectionType
	}
	return nil
}

// GetMaxLinkBandwidth returns the value of the MaxLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field MaxLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth {
	if s != nil && s.MaxLinkBandwidth != nil {
		return s.MaxLinkBandwidth
	}
	return nil
}

// GetMaxReservableLinkBandwidth returns the value of the MaxReservableLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field MaxReservableLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth {
	if s != nil && s.MaxReservableLinkBandwidth != nil {
		return s.MaxReservableLinkBandwidth
	}
	return nil
}

// GetMinMaxLinkDelay returns the value of the MinMaxLinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field MinMaxLinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay {
	if s != nil && s.MinMaxLinkDelay != nil {
		return s.MinMaxLinkDelay
	}
	return nil
}

// GetResidualBandwidth returns the value of the ResidualBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field ResidualBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth {
	if s != nil && s.ResidualBandwidth != nil {
		return s.ResidualBandwidth
	}
	return nil
}

// GetTeDefaultMetric returns the value of the TeDefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field TeDefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric {
	if s != nil && s.TeDefaultMetric != nil {
		return s.TeDefaultMetric
	}
	return nil
}

// GetUnconstrainedLsp returns the value of the UnconstrainedLsp struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field UnconstrainedLsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp {
	if s != nil && s.UnconstrainedLsp != nil {
		return s.UnconstrainedLsp
	}
	return nil
}

// GetUtilizedBandwidth returns the value of the UtilizedBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field UtilizedBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) GetUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth {
	if s != nil && s.UtilizedBandwidth != nil {
		return s.UtilizedBandwidth
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdminGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewConstraint creates a new entry in the Constraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) NewConstraint(ConstraintId uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint)
	}

	key := ConstraintId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Constraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Constraint", key)
	}

	t.Constraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint{
		ConstraintId: &ConstraintId,
	}

	return t.Constraint[key], nil
}

// RenameConstraint renames an entry in the list Constraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) RenameConstraint(oldK, newK uint32) error {
	if _, ok := t.Constraint[newK]; ok {
		return fmt.Errorf("key %v already exists in Constraint", newK)
	}

	e, ok := t.Constraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Constraint", oldK)
	}
	e.ConstraintId = &newK

	t.Constraint[newK] = e
	delete(t.Constraint, oldK)
	return nil
}

// GetOrCreateConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) GetOrCreateConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint {

	key := ConstraintId

	if v, ok := t.Constraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConstraint(ConstraintId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConstraint got unexpected error: %v", err))
	}
	return v
}

// GetConstraint retrieves the value with the specified key from
// the Constraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) GetConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint {

	if t == nil {
		return nil
	}

	key := ConstraintId

	if lm, ok := t.Constraint[key]; ok {
		return lm
	}
	return nil
}

// AppendConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint struct to the
// list Constraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) AppendConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint) error {
	key := *v.ConstraintId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint)
	}

	if _, ok := t.Constraint[key]; ok {
		return fmt.Errorf("duplicate key for list Constraint %v", key)
	}

	t.Constraint[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ModelId == nil {
		return nil, fmt.Errorf("nil value for key ModelId")
	}

	return map[string]interface{}{
		"model-id": *t.ModelId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConstraintId == nil {
		return nil, fmt.Errorf("nil value for key ConstraintId")
	}

	return map[string]interface{}{
		"constraint-id": *t.ConstraintId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelay"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkLoss"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Priority == nil {
		return nil, fmt.Errorf("nil value for key Priority")
	}

	return map[string]interface{}{
		"priority": *t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_SetupPriority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute_Neighbor_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) NewPrefix(MtId uint16, Prefix string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix)
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key{
		MtId:   MtId,
		Prefix: Prefix,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix{
		MtId:   &MtId,
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) RenamePrefix(oldK, newK NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.MtId = &newK.MtId
	e.Prefix = &newK.Prefix

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) GetOrCreatePrefix(MtId uint16, Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix {

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key{
		MtId:   MtId,
		Prefix: Prefix,
	}

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(MtId, Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) GetPrefix(MtId uint16, Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key{
		MtId:   MtId,
		Prefix: Prefix,
	}

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) error {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key{MtId: *v.MtId, Prefix: *v.Prefix}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MtId == nil {
		return nil, fmt.Errorf("nil value for key MtId")
	}

	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"mt-id":  *t.MtId,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) NewPrefixSid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid{
		Value: &Value,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) RenamePrefixSid(oldK, newK uint32) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Value = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreatePrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid {

	key := Value

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetPrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// GetOrCreateFlags retrieves the value of the Flags field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreateFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags {
	if s.Flags != nil {
		return s.Flags
	}
	s.Flags = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags{}
	return s.Flags
}

// GetOrCreateIpv4SourceRouterId retrieves the value of the Ipv4SourceRouterId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreateIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if s.Ipv4SourceRouterId != nil {
		return s.Ipv4SourceRouterId
	}
	s.Ipv4SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	return s.Ipv4SourceRouterId
}

// GetOrCreateIpv6SourceRouterId retrieves the value of the Ipv6SourceRouterId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreateIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if s.Ipv6SourceRouterId != nil {
		return s.Ipv6SourceRouterId
	}
	s.Ipv6SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	return s.Ipv6SourceRouterId
}

// GetOrCreateTag retrieves the value of the Tag field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreateTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag {
	if s.Tag != nil {
		return s.Tag
	}
	s.Tag = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag{}
	return s.Tag
}

// GetOrCreateTag64 retrieves the value of the Tag64 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetOrCreateTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64 {
	if s.Tag64 != nil {
		return s.Tag64
	}
	s.Tag64 = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64{}
	return s.Tag64
}

// GetFlags returns the value of the Flags struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver or the field Flags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags {
	if s != nil && s.Flags != nil {
		return s.Flags
	}
	return nil
}

// GetIpv4SourceRouterId returns the value of the Ipv4SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver or the field Ipv4SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if s != nil && s.Ipv4SourceRouterId != nil {
		return s.Ipv4SourceRouterId
	}
	return nil
}

// GetIpv6SourceRouterId returns the value of the Ipv6SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver or the field Ipv6SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if s != nil && s.Ipv6SourceRouterId != nil {
		return s.Ipv6SourceRouterId
	}
	return nil
}

// GetTag returns the value of the Tag struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver or the field Tag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag {
	if s != nil && s.Tag != nil {
		return s.Tag
	}
	return nil
}

// GetTag64 returns the value of the Tag64 struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv. If the receiver or the field Tag64 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) GetTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64 {
	if s != nil && s.Tag64 != nil {
		return s.Tag64
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Flags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_Subtlv_Tag64) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability_Prefix_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) NewPrefix(Prefix string, MtId uint16) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix)
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key{
		Prefix: Prefix,
		MtId:   MtId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix{
		Prefix: &Prefix,
		MtId:   &MtId,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) RenamePrefix(oldK, newK NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK.Prefix
	e.MtId = &newK.MtId

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) GetOrCreatePrefix(Prefix string, MtId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix {

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key{
		Prefix: Prefix,
		MtId:   MtId,
	}

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix, MtId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) GetPrefix(Prefix string, MtId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key{
		Prefix: Prefix,
		MtId:   MtId,
	}

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) error {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key{Prefix: *v.Prefix, MtId: *v.MtId}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MtId == nil {
		return nil, fmt.Errorf("nil value for key MtId")
	}

	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"mt-id":  *t.MtId,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) NewPrefixSid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid{
		Value: &Value,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) RenamePrefixSid(oldK, newK uint32) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Value = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreatePrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid {

	key := Value

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetPrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// GetOrCreateFlags retrieves the value of the Flags field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreateFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags {
	if s.Flags != nil {
		return s.Flags
	}
	s.Flags = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags{}
	return s.Flags
}

// GetOrCreateIpv4SourceRouterId retrieves the value of the Ipv4SourceRouterId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreateIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if s.Ipv4SourceRouterId != nil {
		return s.Ipv4SourceRouterId
	}
	s.Ipv4SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	return s.Ipv4SourceRouterId
}

// GetOrCreateIpv6SourceRouterId retrieves the value of the Ipv6SourceRouterId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreateIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if s.Ipv6SourceRouterId != nil {
		return s.Ipv6SourceRouterId
	}
	s.Ipv6SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	return s.Ipv6SourceRouterId
}

// GetOrCreateTag retrieves the value of the Tag field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreateTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag {
	if s.Tag != nil {
		return s.Tag
	}
	s.Tag = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag{}
	return s.Tag
}

// GetOrCreateTag64 retrieves the value of the Tag64 field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetOrCreateTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64 {
	if s.Tag64 != nil {
		return s.Tag64
	}
	s.Tag64 = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64{}
	return s.Tag64
}

// GetFlags returns the value of the Flags struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver or the field Flags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags {
	if s != nil && s.Flags != nil {
		return s.Flags
	}
	return nil
}

// GetIpv4SourceRouterId returns the value of the Ipv4SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver or the field Ipv4SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if s != nil && s.Ipv4SourceRouterId != nil {
		return s.Ipv4SourceRouterId
	}
	return nil
}

// GetIpv6SourceRouterId returns the value of the Ipv6SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver or the field Ipv6SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if s != nil && s.Ipv6SourceRouterId != nil {
		return s.Ipv6SourceRouterId
	}
	return nil
}

// GetTag returns the value of the Tag struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver or the field Tag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag {
	if s != nil && s.Tag != nil {
		return s.Tag
	}
	return nil
}

// GetTag64 returns the value of the Tag64 struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv. If the receiver or the field Tag64 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) GetTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64 {
	if s != nil && s.Tag64 != nil {
		return s.Tag64
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Flags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv4SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Ipv6SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_Subtlv_Tag64) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability_Prefix_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) NewNeighbor(MtId uint16, SystemId string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor)
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor{
		MtId:     &MtId,
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) RenameNeighbor(oldK, newK NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.MtId = &newK.MtId
	e.SystemId = &newK.SystemId

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) GetOrCreateNeighbor(MtId uint16, SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor {

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(MtId, SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) GetNeighbor(MtId uint16, SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) AppendNeighbor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) error {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key{MtId: *v.MtId, SystemId: *v.SystemId}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MtId == nil {
		return nil, fmt.Errorf("nil value for key MtId")
	}

	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"mt-id":     *t.MtId,
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) NewAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid{
		Value: &Value,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) RenameAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Value = &newK

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid {

	key := Value

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewBandwidthConstraint creates a new entry in the BandwidthConstraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) NewBandwidthConstraint(ModelId uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint)
	}

	key := ModelId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthConstraint", key)
	}

	t.BandwidthConstraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint{
		ModelId: &ModelId,
	}

	return t.BandwidthConstraint[key], nil
}

// RenameBandwidthConstraint renames an entry in the list BandwidthConstraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) RenameBandwidthConstraint(oldK, newK uint8) error {
	if _, ok := t.BandwidthConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthConstraint", newK)
	}

	e, ok := t.BandwidthConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthConstraint", oldK)
	}
	e.ModelId = &newK

	t.BandwidthConstraint[newK] = e
	delete(t.BandwidthConstraint, oldK)
	return nil
}

// GetOrCreateBandwidthConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint {

	key := ModelId

	if v, ok := t.BandwidthConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthConstraint(ModelId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthConstraint got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthConstraint retrieves the value with the specified key from
// the BandwidthConstraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint {

	if t == nil {
		return nil
	}

	key := ModelId

	if lm, ok := t.BandwidthConstraint[key]; ok {
		return lm
	}
	return nil
}

// AppendBandwidthConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint struct to the
// list BandwidthConstraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) AppendBandwidthConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) error {
	key := *v.ModelId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint)
	}

	if _, ok := t.BandwidthConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthConstraint %v", key)
	}

	t.BandwidthConstraint[key] = v
	return nil
}

// NewLanAdjacencySid creates a new entry in the LanAdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) NewLanAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LanAdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LanAdjacencySid", key)
	}

	t.LanAdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid{
		Value: &Value,
	}

	return t.LanAdjacencySid[key], nil
}

// RenameLanAdjacencySid renames an entry in the list LanAdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) RenameLanAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.LanAdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in LanAdjacencySid", newK)
	}

	e, ok := t.LanAdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LanAdjacencySid", oldK)
	}
	e.Value = &newK

	t.LanAdjacencySid[newK] = e
	delete(t.LanAdjacencySid, oldK)
	return nil
}

// GetOrCreateLanAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid {

	key := Value

	if v, ok := t.LanAdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLanAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLanAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetLanAdjacencySid retrieves the value with the specified key from
// the LanAdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.LanAdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// AppendLanAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid struct to the
// list LanAdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) AppendLanAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid)
	}

	if _, ok := t.LanAdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list LanAdjacencySid %v", key)
	}

	t.LanAdjacencySid[key] = v
	return nil
}

// NewSetupPriority creates a new entry in the SetupPriority list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) NewSetupPriority(Priority uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SetupPriority[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SetupPriority", key)
	}

	t.SetupPriority[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority{
		Priority: &Priority,
	}

	return t.SetupPriority[key], nil
}

// RenameSetupPriority renames an entry in the list SetupPriority within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) RenameSetupPriority(oldK, newK uint8) error {
	if _, ok := t.SetupPriority[newK]; ok {
		return fmt.Errorf("key %v already exists in SetupPriority", newK)
	}

	e, ok := t.SetupPriority[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SetupPriority", oldK)
	}
	e.Priority = &newK

	t.SetupPriority[newK] = e
	delete(t.SetupPriority, oldK)
	return nil
}

// GetOrCreateSetupPriority retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority {

	key := Priority

	if v, ok := t.SetupPriority[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSetupPriority(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSetupPriority got unexpected error: %v", err))
	}
	return v
}

// GetSetupPriority retrieves the value with the specified key from
// the SetupPriority map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.SetupPriority[key]; ok {
		return lm
	}
	return nil
}

// AppendSetupPriority appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority struct to the
// list SetupPriority of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) AppendSetupPriority(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority) error {
	key := *v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority)
	}

	if _, ok := t.SetupPriority[key]; ok {
		return fmt.Errorf("duplicate key for list SetupPriority %v", key)
	}

	t.SetupPriority[key] = v
	return nil
}

// GetOrCreateAdminGroup retrieves the value of the AdminGroup field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdminGroup {
	if s.AdminGroup != nil {
		return s.AdminGroup
	}
	s.AdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdminGroup{}
	return s.AdminGroup
}

// GetOrCreateAvailableBandwidth retrieves the value of the AvailableBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth {
	if s.AvailableBandwidth != nil {
		return s.AvailableBandwidth
	}
	s.AvailableBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth{}
	return s.AvailableBandwidth
}

// GetOrCreateExtendedAdminGroup retrieves the value of the ExtendedAdminGroup field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup {
	if s.ExtendedAdminGroup != nil {
		return s.ExtendedAdminGroup
	}
	s.ExtendedAdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup{}
	return s.ExtendedAdminGroup
}

// GetOrCreateIpv4InterfaceAddress retrieves the value of the Ipv4InterfaceAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress {
	if s.Ipv4InterfaceAddress != nil {
		return s.Ipv4InterfaceAddress
	}
	s.Ipv4InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress{}
	return s.Ipv4InterfaceAddress
}

// GetOrCreateIpv4NeighborAddress retrieves the value of the Ipv4NeighborAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress {
	if s.Ipv4NeighborAddress != nil {
		return s.Ipv4NeighborAddress
	}
	s.Ipv4NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress{}
	return s.Ipv4NeighborAddress
}

// GetOrCreateIpv6InterfaceAddress retrieves the value of the Ipv6InterfaceAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress {
	if s.Ipv6InterfaceAddress != nil {
		return s.Ipv6InterfaceAddress
	}
	s.Ipv6InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress{}
	return s.Ipv6InterfaceAddress
}

// GetOrCreateIpv6NeighborAddress retrieves the value of the Ipv6NeighborAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress {
	if s.Ipv6NeighborAddress != nil {
		return s.Ipv6NeighborAddress
	}
	s.Ipv6NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress{}
	return s.Ipv6NeighborAddress
}

// GetOrCreateLinkAttributes retrieves the value of the LinkAttributes field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes {
	if s.LinkAttributes != nil {
		return s.LinkAttributes
	}
	s.LinkAttributes = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes{}
	return s.LinkAttributes
}

// GetOrCreateLinkDelay retrieves the value of the LinkDelay field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelay {
	if s.LinkDelay != nil {
		return s.LinkDelay
	}
	s.LinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelay{}
	return s.LinkDelay
}

// GetOrCreateLinkDelayVariation retrieves the value of the LinkDelayVariation field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation {
	if s.LinkDelayVariation != nil {
		return s.LinkDelayVariation
	}
	s.LinkDelayVariation = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation{}
	return s.LinkDelayVariation
}

// GetOrCreateLinkId retrieves the value of the LinkId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkId {
	if s.LinkId != nil {
		return s.LinkId
	}
	s.LinkId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkId{}
	return s.LinkId
}

// GetOrCreateLinkLoss retrieves the value of the LinkLoss field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkLoss {
	if s.LinkLoss != nil {
		return s.LinkLoss
	}
	s.LinkLoss = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkLoss{}
	return s.LinkLoss
}

// GetOrCreateLinkProtectionType retrieves the value of the LinkProtectionType field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType {
	if s.LinkProtectionType != nil {
		return s.LinkProtectionType
	}
	s.LinkProtectionType = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType{}
	return s.LinkProtectionType
}

// GetOrCreateMaxLinkBandwidth retrieves the value of the MaxLinkBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth {
	if s.MaxLinkBandwidth != nil {
		return s.MaxLinkBandwidth
	}
	s.MaxLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth{}
	return s.MaxLinkBandwidth
}

// GetOrCreateMaxReservableLinkBandwidth retrieves the value of the MaxReservableLinkBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth {
	if s.MaxReservableLinkBandwidth != nil {
		return s.MaxReservableLinkBandwidth
	}
	s.MaxReservableLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth{}
	return s.MaxReservableLinkBandwidth
}

// GetOrCreateMinMaxLinkDelay retrieves the value of the MinMaxLinkDelay field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay {
	if s.MinMaxLinkDelay != nil {
		return s.MinMaxLinkDelay
	}
	s.MinMaxLinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay{}
	return s.MinMaxLinkDelay
}

// GetOrCreateResidualBandwidth retrieves the value of the ResidualBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth {
	if s.ResidualBandwidth != nil {
		return s.ResidualBandwidth
	}
	s.ResidualBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth{}
	return s.ResidualBandwidth
}

// GetOrCreateTeDefaultMetric retrieves the value of the TeDefaultMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric {
	if s.TeDefaultMetric != nil {
		return s.TeDefaultMetric
	}
	s.TeDefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric{}
	return s.TeDefaultMetric
}

// GetOrCreateUnconstrainedLsp retrieves the value of the UnconstrainedLsp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp {
	if s.UnconstrainedLsp != nil {
		return s.UnconstrainedLsp
	}
	s.UnconstrainedLsp = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp{}
	return s.UnconstrainedLsp
}

// GetOrCreateUtilizedBandwidth retrieves the value of the UtilizedBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetOrCreateUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth {
	if s.UtilizedBandwidth != nil {
		return s.UtilizedBandwidth
	}
	s.UtilizedBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth{}
	return s.UtilizedBandwidth
}

// GetAdminGroup returns the value of the AdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field AdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdminGroup {
	if s != nil && s.AdminGroup != nil {
		return s.AdminGroup
	}
	return nil
}

// GetAvailableBandwidth returns the value of the AvailableBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field AvailableBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth {
	if s != nil && s.AvailableBandwidth != nil {
		return s.AvailableBandwidth
	}
	return nil
}

// GetExtendedAdminGroup returns the value of the ExtendedAdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field ExtendedAdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup {
	if s != nil && s.ExtendedAdminGroup != nil {
		return s.ExtendedAdminGroup
	}
	return nil
}

// GetIpv4InterfaceAddress returns the value of the Ipv4InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field Ipv4InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress {
	if s != nil && s.Ipv4InterfaceAddress != nil {
		return s.Ipv4InterfaceAddress
	}
	return nil
}

// GetIpv4NeighborAddress returns the value of the Ipv4NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field Ipv4NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress {
	if s != nil && s.Ipv4NeighborAddress != nil {
		return s.Ipv4NeighborAddress
	}
	return nil
}

// GetIpv6InterfaceAddress returns the value of the Ipv6InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field Ipv6InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress {
	if s != nil && s.Ipv6InterfaceAddress != nil {
		return s.Ipv6InterfaceAddress
	}
	return nil
}

// GetIpv6NeighborAddress returns the value of the Ipv6NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field Ipv6NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress {
	if s != nil && s.Ipv6NeighborAddress != nil {
		return s.Ipv6NeighborAddress
	}
	return nil
}

// GetLinkAttributes returns the value of the LinkAttributes struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes {
	if s != nil && s.LinkAttributes != nil {
		return s.LinkAttributes
	}
	return nil
}

// GetLinkDelay returns the value of the LinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelay {
	if s != nil && s.LinkDelay != nil {
		return s.LinkDelay
	}
	return nil
}

// GetLinkDelayVariation returns the value of the LinkDelayVariation struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkDelayVariation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation {
	if s != nil && s.LinkDelayVariation != nil {
		return s.LinkDelayVariation
	}
	return nil
}

// GetLinkId returns the value of the LinkId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkId {
	if s != nil && s.LinkId != nil {
		return s.LinkId
	}
	return nil
}

// GetLinkLoss returns the value of the LinkLoss struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkLoss {
	if s != nil && s.LinkLoss != nil {
		return s.LinkLoss
	}
	return nil
}

// GetLinkProtectionType returns the value of the LinkProtectionType struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field LinkProtectionType is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType {
	if s != nil && s.LinkProtectionType != nil {
		return s.LinkProtectionType
	}
	return nil
}

// GetMaxLinkBandwidth returns the value of the MaxLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field MaxLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth {
	if s != nil && s.MaxLinkBandwidth != nil {
		return s.MaxLinkBandwidth
	}
	return nil
}

// GetMaxReservableLinkBandwidth returns the value of the MaxReservableLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field MaxReservableLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth {
	if s != nil && s.MaxReservableLinkBandwidth != nil {
		return s.MaxReservableLinkBandwidth
	}
	return nil
}

// GetMinMaxLinkDelay returns the value of the MinMaxLinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field MinMaxLinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay {
	if s != nil && s.MinMaxLinkDelay != nil {
		return s.MinMaxLinkDelay
	}
	return nil
}

// GetResidualBandwidth returns the value of the ResidualBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field ResidualBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth {
	if s != nil && s.ResidualBandwidth != nil {
		return s.ResidualBandwidth
	}
	return nil
}

// GetTeDefaultMetric returns the value of the TeDefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field TeDefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric {
	if s != nil && s.TeDefaultMetric != nil {
		return s.TeDefaultMetric
	}
	return nil
}

// GetUnconstrainedLsp returns the value of the UnconstrainedLsp struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field UnconstrainedLsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp {
	if s != nil && s.UnconstrainedLsp != nil {
		return s.UnconstrainedLsp
	}
	return nil
}

// GetUtilizedBandwidth returns the value of the UtilizedBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv. If the receiver or the field UtilizedBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) GetUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth {
	if s != nil && s.UtilizedBandwidth != nil {
		return s.UtilizedBandwidth
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdminGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_AvailableBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewConstraint creates a new entry in the Constraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) NewConstraint(ConstraintId uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint)
	}

	key := ConstraintId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Constraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Constraint", key)
	}

	t.Constraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint{
		ConstraintId: &ConstraintId,
	}

	return t.Constraint[key], nil
}

// RenameConstraint renames an entry in the list Constraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) RenameConstraint(oldK, newK uint32) error {
	if _, ok := t.Constraint[newK]; ok {
		return fmt.Errorf("key %v already exists in Constraint", newK)
	}

	e, ok := t.Constraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Constraint", oldK)
	}
	e.ConstraintId = &newK

	t.Constraint[newK] = e
	delete(t.Constraint, oldK)
	return nil
}

// GetOrCreateConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) GetOrCreateConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint {

	key := ConstraintId

	if v, ok := t.Constraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConstraint(ConstraintId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConstraint got unexpected error: %v", err))
	}
	return v
}

// GetConstraint retrieves the value with the specified key from
// the Constraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) GetConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint {

	if t == nil {
		return nil
	}

	key := ConstraintId

	if lm, ok := t.Constraint[key]; ok {
		return lm
	}
	return nil
}

// AppendConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint struct to the
// list Constraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) AppendConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint) error {
	key := *v.ConstraintId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint)
	}

	if _, ok := t.Constraint[key]; ok {
		return fmt.Errorf("duplicate key for list Constraint %v", key)
	}

	t.Constraint[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ModelId == nil {
		return nil, fmt.Errorf("nil value for key ModelId")
	}

	return map[string]interface{}{
		"model-id": *t.ModelId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConstraintId == nil {
		return nil, fmt.Errorf("nil value for key ConstraintId")
	}

	return map[string]interface{}{
		"constraint-id": *t.ConstraintId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_BandwidthConstraint_Constraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ExtendedAdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv4NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_Ipv6NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LanAdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelay"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkDelayVariation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkLoss"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_LinkProtectionType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MaxReservableLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_MinMaxLinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_ResidualBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Priority == nil {
		return nil, fmt.Errorf("nil value for key Priority")
	}

	return map[string]interface{}{
		"priority": *t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_SetupPriority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_TeDefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UnconstrainedLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_Subtlv_UtilizedBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute_Neighbor_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) NewNeighbor(MtId uint16, SystemId string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor)
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor{
		MtId:     &MtId,
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) RenameNeighbor(oldK, newK NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.MtId = &newK.MtId
	e.SystemId = &newK.SystemId

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) GetOrCreateNeighbor(MtId uint16, SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor {

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(MtId, SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) GetNeighbor(MtId uint16, SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key{
		MtId:     MtId,
		SystemId: SystemId,
	}

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) AppendNeighbor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) error {
	key := NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key{MtId: *v.MtId, SystemId: *v.SystemId}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Key]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) NewSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) RenameSubtlv(oldK, newK E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) GetOrCreateSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) GetSubtlv(Type E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_OpenconfigIsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv) error {
	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MtId == nil {
		return nil, fmt.Errorf("nil value for key MtId")
	}

	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"mt-id":     *t.MtId,
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) NewAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid{
		Value: &Value,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) RenameAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Value = &newK

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid {

	key := Value

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewBandwidthConstraint creates a new entry in the BandwidthConstraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) NewBandwidthConstraint(ModelId uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint)
	}

	key := ModelId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthConstraint", key)
	}

	t.BandwidthConstraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint{
		ModelId: &ModelId,
	}

	return t.BandwidthConstraint[key], nil
}

// RenameBandwidthConstraint renames an entry in the list BandwidthConstraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) RenameBandwidthConstraint(oldK, newK uint8) error {
	if _, ok := t.BandwidthConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthConstraint", newK)
	}

	e, ok := t.BandwidthConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthConstraint", oldK)
	}
	e.ModelId = &newK

	t.BandwidthConstraint[newK] = e
	delete(t.BandwidthConstraint, oldK)
	return nil
}

// GetOrCreateBandwidthConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint {

	key := ModelId

	if v, ok := t.BandwidthConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthConstraint(ModelId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthConstraint got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthConstraint retrieves the value with the specified key from
// the BandwidthConstraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint {

	if t == nil {
		return nil
	}

	key := ModelId

	if lm, ok := t.BandwidthConstraint[key]; ok {
		return lm
	}
	return nil
}

// AppendBandwidthConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint struct to the
// list BandwidthConstraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) AppendBandwidthConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint) error {
	key := *v.ModelId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint)
	}

	if _, ok := t.BandwidthConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthConstraint %v", key)
	}

	t.BandwidthConstraint[key] = v
	return nil
}

// NewLanAdjacencySid creates a new entry in the LanAdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) NewLanAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LanAdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LanAdjacencySid", key)
	}

	t.LanAdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid{
		Value: &Value,
	}

	return t.LanAdjacencySid[key], nil
}

// RenameLanAdjacencySid renames an entry in the list LanAdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) RenameLanAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.LanAdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in LanAdjacencySid", newK)
	}

	e, ok := t.LanAdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LanAdjacencySid", oldK)
	}
	e.Value = &newK

	t.LanAdjacencySid[newK] = e
	delete(t.LanAdjacencySid, oldK)
	return nil
}

// GetOrCreateLanAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid {

	key := Value

	if v, ok := t.LanAdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLanAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLanAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetLanAdjacencySid retrieves the value with the specified key from
// the LanAdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.LanAdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// AppendLanAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid struct to the
// list LanAdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) AppendLanAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid) error {
	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid)
	}

	if _, ok := t.LanAdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list LanAdjacencySid %v", key)
	}

	t.LanAdjacencySid[key] = v
	return nil
}

// NewSetupPriority creates a new entry in the SetupPriority list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) NewSetupPriority(Priority uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SetupPriority[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SetupPriority", key)
	}

	t.SetupPriority[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority{
		Priority: &Priority,
	}

	return t.SetupPriority[key], nil
}

// RenameSetupPriority renames an entry in the list SetupPriority within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) RenameSetupPriority(oldK, newK uint8) error {
	if _, ok := t.SetupPriority[newK]; ok {
		return fmt.Errorf("key %v already exists in SetupPriority", newK)
	}

	e, ok := t.SetupPriority[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SetupPriority", oldK)
	}
	e.Priority = &newK

	t.SetupPriority[newK] = e
	delete(t.SetupPriority, oldK)
	return nil
}

// GetOrCreateSetupPriority retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority {

	key := Priority

	if v, ok := t.SetupPriority[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSetupPriority(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSetupPriority got unexpected error: %v", err))
	}
	return v
}

// GetSetupPriority retrieves the value with the specified key from
// the SetupPriority map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.SetupPriority[key]; ok {
		return lm
	}
	return nil
}

// AppendSetupPriority appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority struct to the
// list SetupPriority of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) AppendSetupPriority(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority) error {
	key := *v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority)
	}

	if _, ok := t.SetupPriority[key]; ok {
		return fmt.Errorf("duplicate key for list SetupPriority %v", key)
	}

	t.SetupPriority[key] = v
	return nil
}

// GetOrCreateAdminGroup retrieves the value of the AdminGroup field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdminGroup {
	if s.AdminGroup != nil {
		return s.AdminGroup
	}
	s.AdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdminGroup{}
	return s.AdminGroup
}

// GetOrCreateAvailableBandwidth retrieves the value of the AvailableBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AvailableBandwidth {
	if s.AvailableBandwidth != nil {
		return s.AvailableBandwidth
	}
	s.AvailableBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AvailableBandwidth{}
	return s.AvailableBandwidth
}

// GetOrCreateExtendedAdminGroup retrieves the value of the ExtendedAdminGroup field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ExtendedAdminGroup {
	if s.ExtendedAdminGroup != nil {
		return s.ExtendedAdminGroup
	}
	s.ExtendedAdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ExtendedAdminGroup{}
	return s.ExtendedAdminGroup
}

// GetOrCreateIpv4InterfaceAddress retrieves the value of the Ipv4InterfaceAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4InterfaceAddress {
	if s.Ipv4InterfaceAddress != nil {
		return s.Ipv4InterfaceAddress
	}
	s.Ipv4InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4InterfaceAddress{}
	return s.Ipv4InterfaceAddress
}

// GetOrCreateIpv4NeighborAddress retrieves the value of the Ipv4NeighborAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4NeighborAddress {
	if s.Ipv4NeighborAddress != nil {
		return s.Ipv4NeighborAddress
	}
	s.Ipv4NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4NeighborAddress{}
	return s.Ipv4NeighborAddress
}

// GetOrCreateIpv6InterfaceAddress retrieves the value of the Ipv6InterfaceAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6InterfaceAddress {
	if s.Ipv6InterfaceAddress != nil {
		return s.Ipv6InterfaceAddress
	}
	s.Ipv6InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6InterfaceAddress{}
	return s.Ipv6InterfaceAddress
}

// GetOrCreateIpv6NeighborAddress retrieves the value of the Ipv6NeighborAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6NeighborAddress {
	if s.Ipv6NeighborAddress != nil {
		return s.Ipv6NeighborAddress
	}
	s.Ipv6NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6NeighborAddress{}
	return s.Ipv6NeighborAddress
}

// GetOrCreateLinkAttributes retrieves the value of the LinkAttributes field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkAttributes {
	if s.LinkAttributes != nil {
		return s.LinkAttributes
	}
	s.LinkAttributes = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkAttributes{}
	return s.LinkAttributes
}

// GetOrCreateLinkDelay retrieves the value of the LinkDelay field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelay {
	if s.LinkDelay != nil {
		return s.LinkDelay
	}
	s.LinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelay{}
	return s.LinkDelay
}

// GetOrCreateLinkDelayVariation retrieves the value of the LinkDelayVariation field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelayVariation {
	if s.LinkDelayVariation != nil {
		return s.LinkDelayVariation
	}
	s.LinkDelayVariation = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelayVariation{}
	return s.LinkDelayVariation
}

// GetOrCreateLinkId retrieves the value of the LinkId field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkId {
	if s.LinkId != nil {
		return s.LinkId
	}
	s.LinkId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkId{}
	return s.LinkId
}

// GetOrCreateLinkLoss retrieves the value of the LinkLoss field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkLoss {
	if s.LinkLoss != nil {
		return s.LinkLoss
	}
	s.LinkLoss = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkLoss{}
	return s.LinkLoss
}

// GetOrCreateLinkProtectionType retrieves the value of the LinkProtectionType field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkProtectionType {
	if s.LinkProtectionType != nil {
		return s.LinkProtectionType
	}
	s.LinkProtectionType = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkProtectionType{}
	return s.LinkProtectionType
}

// GetOrCreateMaxLinkBandwidth retrieves the value of the MaxLinkBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxLinkBandwidth {
	if s.MaxLinkBandwidth != nil {
		return s.MaxLinkBandwidth
	}
	s.MaxLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxLinkBandwidth{}
	return s.MaxLinkBandwidth
}

// GetOrCreateMaxReservableLinkBandwidth retrieves the value of the MaxReservableLinkBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxReservableLinkBandwidth {
	if s.MaxReservableLinkBandwidth != nil {
		return s.MaxReservableLinkBandwidth
	}
	s.MaxReservableLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxReservableLinkBandwidth{}
	return s.MaxReservableLinkBandwidth
}

// GetOrCreateMinMaxLinkDelay retrieves the value of the MinMaxLinkDelay field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MinMaxLinkDelay {
	if s.MinMaxLinkDelay != nil {
		return s.MinMaxLinkDelay
	}
	s.MinMaxLinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MinMaxLinkDelay{}
	return s.MinMaxLinkDelay
}

// GetOrCreateResidualBandwidth retrieves the value of the ResidualBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ResidualBandwidth {
	if s.ResidualBandwidth != nil {
		return s.ResidualBandwidth
	}
	s.ResidualBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ResidualBandwidth{}
	return s.ResidualBandwidth
}

// GetOrCreateTeDefaultMetric retrieves the value of the TeDefaultMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_TeDefaultMetric {
	if s.TeDefaultMetric != nil {
		return s.TeDefaultMetric
	}
	s.TeDefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_TeDefaultMetric{}
	return s.TeDefaultMetric
}

// GetOrCreateUnconstrainedLsp retrieves the value of the UnconstrainedLsp field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UnconstrainedLsp {
	if s.UnconstrainedLsp != nil {
		return s.UnconstrainedLsp
	}
	s.UnconstrainedLsp = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UnconstrainedLsp{}
	return s.UnconstrainedLsp
}

// GetOrCreateUtilizedBandwidth retrieves the value of the UtilizedBandwidth field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetOrCreateUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UtilizedBandwidth {
	if s.UtilizedBandwidth != nil {
		return s.UtilizedBandwidth
	}
	s.UtilizedBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UtilizedBandwidth{}
	return s.UtilizedBandwidth
}

// GetAdminGroup returns the value of the AdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field AdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdminGroup {
	if s != nil && s.AdminGroup != nil {
		return s.AdminGroup
	}
	return nil
}

// GetAvailableBandwidth returns the value of the AvailableBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field AvailableBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AvailableBandwidth {
	if s != nil && s.AvailableBandwidth != nil {
		return s.AvailableBandwidth
	}
	return nil
}

// GetExtendedAdminGroup returns the value of the ExtendedAdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field ExtendedAdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ExtendedAdminGroup {
	if s != nil && s.ExtendedAdminGroup != nil {
		return s.ExtendedAdminGroup
	}
	return nil
}

// GetIpv4InterfaceAddress returns the value of the Ipv4InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field Ipv4InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4InterfaceAddress {
	if s != nil && s.Ipv4InterfaceAddress != nil {
		return s.Ipv4InterfaceAddress
	}
	return nil
}

// GetIpv4NeighborAddress returns the value of the Ipv4NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field Ipv4NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4NeighborAddress {
	if s != nil && s.Ipv4NeighborAddress != nil {
		return s.Ipv4NeighborAddress
	}
	return nil
}

// GetIpv6InterfaceAddress returns the value of the Ipv6InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field Ipv6InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6InterfaceAddress {
	if s != nil && s.Ipv6InterfaceAddress != nil {
		return s.Ipv6InterfaceAddress
	}
	return nil
}

// GetIpv6NeighborAddress returns the value of the Ipv6NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field Ipv6NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6NeighborAddress {
	if s != nil && s.Ipv6NeighborAddress != nil {
		return s.Ipv6NeighborAddress
	}
	return nil
}

// GetLinkAttributes returns the value of the LinkAttributes struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field LinkAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkAttributes {
	if s != nil && s.LinkAttributes != nil {
		return s.LinkAttributes
	}
	return nil
}

// GetLinkDelay returns the value of the LinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field LinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelay {
	if s != nil && s.LinkDelay != nil {
		return s.LinkDelay
	}
	return nil
}

// GetLinkDelayVariation returns the value of the LinkDelayVariation struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field LinkDelayVariation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelayVariation {
	if s != nil && s.LinkDelayVariation != nil {
		return s.LinkDelayVariation
	}
	return nil
}

// GetLinkId returns the value of the LinkId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field LinkId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkId {
	if s != nil && s.LinkId != nil {
		return s.LinkId
	}
	return nil
}

// GetLinkLoss returns the value of the LinkLoss struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field LinkLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkLoss {
	if s != nil && s.LinkLoss != nil {
		return s.LinkLoss
	}
	return nil
}

// GetLinkProtectionType returns the value of the LinkProtectionType struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field LinkProtectionType is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkProtectionType {
	if s != nil && s.LinkProtectionType != nil {
		return s.LinkProtectionType
	}
	return nil
}

// GetMaxLinkBandwidth returns the value of the MaxLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field MaxLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxLinkBandwidth {
	if s != nil && s.MaxLinkBandwidth != nil {
		return s.MaxLinkBandwidth
	}
	return nil
}

// GetMaxReservableLinkBandwidth returns the value of the MaxReservableLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field MaxReservableLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxReservableLinkBandwidth {
	if s != nil && s.MaxReservableLinkBandwidth != nil {
		return s.MaxReservableLinkBandwidth
	}
	return nil
}

// GetMinMaxLinkDelay returns the value of the MinMaxLinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field MinMaxLinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MinMaxLinkDelay {
	if s != nil && s.MinMaxLinkDelay != nil {
		return s.MinMaxLinkDelay
	}
	return nil
}

// GetResidualBandwidth returns the value of the ResidualBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field ResidualBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ResidualBandwidth {
	if s != nil && s.ResidualBandwidth != nil {
		return s.ResidualBandwidth
	}
	return nil
}

// GetTeDefaultMetric returns the value of the TeDefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field TeDefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_TeDefaultMetric {
	if s != nil && s.TeDefaultMetric != nil {
		return s.TeDefaultMetric
	}
	return nil
}

// GetUnconstrainedLsp returns the value of the UnconstrainedLsp struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field UnconstrainedLsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UnconstrainedLsp {
	if s != nil && s.UnconstrainedLsp != nil {
		return s.UnconstrainedLsp
	}
	return nil
}

// GetUtilizedBandwidth returns the value of the UtilizedBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv. If the receiver or the field UtilizedBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) GetUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UtilizedBandwidth {
	if s != nil && s.UtilizedBandwidth != nil {
		return s.UtilizedBandwidth
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdminGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AvailableBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AvailableBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_AvailableBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewConstraint creates a new entry in the Constraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint) NewConstraint(ConstraintId uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint)
	}

	key := ConstraintId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Constraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Constraint", key)
	}

	t.Constraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint{
		ConstraintId: &ConstraintId,
	}

	return t.Constraint[key], nil
}

// RenameConstraint renames an entry in the list Constraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint) RenameConstraint(oldK, newK uint32) error {
	if _, ok := t.Constraint[newK]; ok {
		return fmt.Errorf("key %v already exists in Constraint", newK)
	}

	e, ok := t.Constraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Constraint", oldK)
	}
	e.ConstraintId = &newK

	t.Constraint[newK] = e
	delete(t.Constraint, oldK)
	return nil
}

// GetOrCreateConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint) GetOrCreateConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint {

	key := ConstraintId

	if v, ok := t.Constraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConstraint(ConstraintId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConstraint got unexpected error: %v", err))
	}
	return v
}

// GetConstraint retrieves the value with the specified key from
// the Constraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint) GetConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint {

	if t == nil {
		return nil
	}

	key := ConstraintId

	if lm, ok := t.Constraint[key]; ok {
		return lm
	}
	return nil
}

// AppendConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint struct to the
// list Constraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint) AppendConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint) error {
	key := *v.ConstraintId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint)
	}

	if _, ok := t.Constraint[key]; ok {
		return fmt.Errorf("duplicate key for list Constraint %v", key)
	}

	t.Constraint[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ModelId == nil {
		return nil, fmt.Errorf("nil value for key ModelId")
	}

	return map[string]interface{}{
		"model-id": *t.ModelId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConstraintId == nil {
		return nil, fmt.Errorf("nil value for key ConstraintId")
	}

	return map[string]interface{}{
		"constraint-id": *t.ConstraintId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_BandwidthConstraint_Constraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ExtendedAdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ExtendedAdminGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ExtendedAdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4InterfaceAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4NeighborAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv4NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6InterfaceAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6NeighborAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_Ipv6NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LanAdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkAttributes"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelay"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelayVariation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelayVariation"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkDelayVariation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkId"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkLoss"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkProtectionType) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkProtectionType"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_LinkProtectionType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxLinkBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxReservableLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxReservableLinkBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MaxReservableLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MinMaxLinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MinMaxLinkDelay"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_MinMaxLinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ResidualBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ResidualBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_ResidualBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Priority == nil {
		return nil, fmt.Errorf("nil value for key Priority")
	}

	return map[string]interface{}{
		"priority": *t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_SetupPriority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_TeDefaultMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_TeDefaultMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_TeDefaultMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UnconstrainedLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UnconstrainedLsp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UnconstrainedLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UtilizedBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UtilizedBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_Subtlv_UtilizedBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn_Neighbor_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTopology creates a new entry in the Topology list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) NewTopology(MtId uint16) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Topology == nil {
		t.Topology = make(map[uint16]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology)
	}

	key := MtId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Topology[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Topology", key)
	}

	t.Topology[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology{
		MtId: &MtId,
	}

	return t.Topology[key], nil
}

// RenameTopology renames an entry in the list Topology within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) RenameTopology(oldK, newK uint16) error {
	if _, ok := t.Topology[newK]; ok {
		return fmt.Errorf("key %v already exists in Topology", newK)
	}

	e, ok := t.Topology[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Topology", oldK)
	}
	e.MtId = &newK

	t.Topology[newK] = e
	delete(t.Topology, oldK)
	return nil
}

// GetOrCreateTopology retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) GetOrCreateTopology(MtId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology {

	key := MtId

	if v, ok := t.Topology[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTopology(MtId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTopology got unexpected error: %v", err))
	}
	return v
}

// GetTopology retrieves the value with the specified key from
// the Topology map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) GetTopology(MtId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology {

	if t == nil {
		return nil
	}

	key := MtId

	if lm, ok := t.Topology[key]; ok {
		return lm
	}
	return nil
}

// AppendTopology appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology struct to the
// list Topology of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) AppendTopology(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) error {
	key := *v.MtId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Topology == nil {
		t.Topology = make(map[uint16]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology)
	}

	if _, ok := t.Topology[key]; ok {
		return fmt.Errorf("duplicate key for list Topology %v", key)
	}

	t.Topology[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MtId == nil {
		return nil, fmt.Errorf("nil value for key MtId")
	}

	return map[string]interface{}{
		"mt-id": *t.MtId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology_Topology) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_RoutePreference) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_RoutePreference"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_RoutePreference) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_SystemLevelCounters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Isis_Level_TrafficEngineering) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_TrafficEngineering"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_TrafficEngineering) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewArea creates a new entry in the Area list of the
// NetworkInstance_Protocol_Ospfv2 struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2) NewArea(Identifier NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) (*NetworkInstance_Protocol_Ospfv2_Area, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Area == nil {
		t.Area = make(map[NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union]*NetworkInstance_Protocol_Ospfv2_Area)
	}

	key := Identifier

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Area[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Area", key)
	}

	t.Area[key] = &NetworkInstance_Protocol_Ospfv2_Area{
		Identifier: Identifier,
	}

	return t.Area[key], nil
}

// RenameArea renames an entry in the list Area within
// the NetworkInstance_Protocol_Ospfv2 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2) RenameArea(oldK, newK NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) error {
	if _, ok := t.Area[newK]; ok {
		return fmt.Errorf("key %v already exists in Area", newK)
	}

	e, ok := t.Area[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Area", oldK)
	}
	e.Identifier = newK

	t.Area[newK] = e
	delete(t.Area, oldK)
	return nil
}

// GetOrCreateArea retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2) GetOrCreateArea(Identifier NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) *NetworkInstance_Protocol_Ospfv2_Area {

	key := Identifier

	if v, ok := t.Area[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewArea(Identifier)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateArea got unexpected error: %v", err))
	}
	return v
}

// GetArea retrieves the value with the specified key from
// the Area map field of NetworkInstance_Protocol_Ospfv2. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2) GetArea(Identifier NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) *NetworkInstance_Protocol_Ospfv2_Area {

	if t == nil {
		return nil
	}

	key := Identifier

	if lm, ok := t.Area[key]; ok {
		return lm
	}
	return nil
}

// AppendArea appends the supplied NetworkInstance_Protocol_Ospfv2_Area struct to the
// list Area of NetworkInstance_Protocol_Ospfv2. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2) AppendArea(v *NetworkInstance_Protocol_Ospfv2_Area) error {
	key := v.Identifier

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Area == nil {
		t.Area = make(map[NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union]*NetworkInstance_Protocol_Ospfv2_Area)
	}

	if _, ok := t.Area[key]; ok {
		return fmt.Errorf("duplicate key for list Area %v", key)
	}

	t.Area[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2) GetOrCreateGlobal() *NetworkInstance_Protocol_Ospfv2_Global {
	if s.Global != nil {
		return s.Global
	}
	s.Global = &NetworkInstance_Protocol_Ospfv2_Global{}
	return s.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Protocol_Ospfv2. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2) GetGlobal() *NetworkInstance_Protocol_Ospfv2_Global {
	if s != nil && s.Global != nil {
		return s.Global
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Protocol_Ospfv2_Area struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area) NewInterface(Id string) (*NetworkInstance_Protocol_Ospfv2_Area_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Interface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Protocol_Ospfv2_Area_Interface{
		Id: &Id,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Protocol_Ospfv2_Area struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Id = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetOrCreateInterface(Id string) *NetworkInstance_Protocol_Ospfv2_Area_Interface {

	key := Id

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Protocol_Ospfv2_Area. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetInterface(Id string) *NetworkInstance_Protocol_Ospfv2_Area_Interface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Interface struct to the
// list Interface of NetworkInstance_Protocol_Ospfv2_Area. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area) AppendInterface(v *NetworkInstance_Protocol_Ospfv2_Area_Interface) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewVirtualLink creates a new entry in the VirtualLink list of the
// NetworkInstance_Protocol_Ospfv2_Area struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area) NewVirtualLink(RemoteRouterId string) (*NetworkInstance_Protocol_Ospfv2_Area_VirtualLink, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VirtualLink == nil {
		t.VirtualLink = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_VirtualLink)
	}

	key := RemoteRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VirtualLink[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VirtualLink", key)
	}

	t.VirtualLink[key] = &NetworkInstance_Protocol_Ospfv2_Area_VirtualLink{
		RemoteRouterId: &RemoteRouterId,
	}

	return t.VirtualLink[key], nil
}

// RenameVirtualLink renames an entry in the list VirtualLink within
// the NetworkInstance_Protocol_Ospfv2_Area struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area) RenameVirtualLink(oldK, newK string) error {
	if _, ok := t.VirtualLink[newK]; ok {
		return fmt.Errorf("key %v already exists in VirtualLink", newK)
	}

	e, ok := t.VirtualLink[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VirtualLink", oldK)
	}
	e.RemoteRouterId = &newK

	t.VirtualLink[newK] = e
	delete(t.VirtualLink, oldK)
	return nil
}

// GetOrCreateVirtualLink retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetOrCreateVirtualLink(RemoteRouterId string) *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink {

	key := RemoteRouterId

	if v, ok := t.VirtualLink[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVirtualLink(RemoteRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVirtualLink got unexpected error: %v", err))
	}
	return v
}

// GetVirtualLink retrieves the value with the specified key from
// the VirtualLink map field of NetworkInstance_Protocol_Ospfv2_Area. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area) GetVirtualLink(RemoteRouterId string) *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink {

	if t == nil {
		return nil
	}

	key := RemoteRouterId

	if lm, ok := t.VirtualLink[key]; ok {
		return lm
	}
	return nil
}

// AppendVirtualLink appends the supplied NetworkInstance_Protocol_Ospfv2_Area_VirtualLink struct to the
// list VirtualLink of NetworkInstance_Protocol_Ospfv2_Area. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_VirtualLink already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area) AppendVirtualLink(v *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink) error {
	key := *v.RemoteRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VirtualLink == nil {
		t.VirtualLink = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_VirtualLink)
	}

	if _, ok := t.VirtualLink[key]; ok {
		return fmt.Errorf("duplicate key for list VirtualLink %v", key)
	}

	t.VirtualLink[key] = v
	return nil
}

// GetOrCreateLsdb retrieves the value of the Lsdb field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area) GetOrCreateLsdb() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb {
	if s.Lsdb != nil {
		return s.Lsdb
	}
	s.Lsdb = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb{}
	return s.Lsdb
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area) GetOrCreateMpls() *NetworkInstance_Protocol_Ospfv2_Area_Mpls {
	if s.Mpls != nil {
		return s.Mpls
	}
	s.Mpls = &NetworkInstance_Protocol_Ospfv2_Area_Mpls{}
	return s.Mpls
}

// GetLsdb returns the value of the Lsdb struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area. If the receiver or the field Lsdb is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area) GetLsdb() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb {
	if s != nil && s.Lsdb != nil {
		return s.Lsdb
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area) GetMpls() *NetworkInstance_Protocol_Ospfv2_Area_Mpls {
	if s != nil && s.Mpls != nil {
		return s.Mpls
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"identifier": t.Identifier,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Ospfv2_Area_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) NewNeighbor(RouterId string) (*NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor)
	}

	key := RouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor{
		RouterId: &RouterId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Ospfv2_Area_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.RouterId = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetOrCreateNeighbor(RouterId string) *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor {

	key := RouterId

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(RouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Ospfv2_Area_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetNeighbor(RouterId string) *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor {

	if t == nil {
		return nil
	}

	key := RouterId

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Ospfv2_Area_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) AppendNeighbor(v *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) error {
	key := *v.RouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef{}
	return s.InterfaceRef
}

// GetOrCreateLsaFilter retrieves the value of the LsaFilter field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetOrCreateLsaFilter() *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter {
	if s.LsaFilter != nil {
		return s.LsaFilter
	}
	s.LsaFilter = &NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter{}
	return s.LsaFilter
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetOrCreateMpls() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls {
	if s.Mpls != nil {
		return s.Mpls
	}
	s.Mpls = &NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls{}
	return s.Mpls
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetOrCreateTimers() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers {
	if s.Timers != nil {
		return s.Timers
	}
	s.Timers = &NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers{}
	return s.Timers
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetInterfaceRef() *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// GetLsaFilter returns the value of the LsaFilter struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Interface. If the receiver or the field LsaFilter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetLsaFilter() *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter {
	if s != nil && s.LsaFilter != nil {
		return s.LsaFilter
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Interface. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetMpls() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls {
	if s != nil && s.Mpls != nil {
		return s.Mpls
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Interface. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface) GetTimers() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers {
	if s != nil && s.Timers != nil {
		return s.Timers
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_LsaFilter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateIgpLdpSync retrieves the value of the IgpLdpSync field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) GetOrCreateIgpLdpSync() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync {
	if s.IgpLdpSync != nil {
		return s.IgpLdpSync
	}
	s.IgpLdpSync = &NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync{}
	return s.IgpLdpSync
}

// GetIgpLdpSync returns the value of the IgpLdpSync struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls. If the receiver or the field IgpLdpSync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) GetIgpLdpSync() *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync {
	if s != nil && s.IgpLdpSync != nil {
		return s.IgpLdpSync
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Mpls_IgpLdpSync) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.RouterId == nil {
		return nil, fmt.Errorf("nil value for key RouterId")
	}

	return map[string]interface{}{
		"router-id": *t.RouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Interface_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewLsaType creates a new entry in the LsaType list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) NewLsaType(Type E_OpenconfigOspfTypes_OSPF_LSA_TYPE) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LsaType == nil {
		t.LsaType = make(map[E_OpenconfigOspfTypes_OSPF_LSA_TYPE]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LsaType[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LsaType", key)
	}

	t.LsaType[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType{
		Type: Type,
	}

	return t.LsaType[key], nil
}

// RenameLsaType renames an entry in the list LsaType within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) RenameLsaType(oldK, newK E_OpenconfigOspfTypes_OSPF_LSA_TYPE) error {
	if _, ok := t.LsaType[newK]; ok {
		return fmt.Errorf("key %v already exists in LsaType", newK)
	}

	e, ok := t.LsaType[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LsaType", oldK)
	}
	e.Type = newK

	t.LsaType[newK] = e
	delete(t.LsaType, oldK)
	return nil
}

// GetOrCreateLsaType retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) GetOrCreateLsaType(Type E_OpenconfigOspfTypes_OSPF_LSA_TYPE) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType {

	key := Type

	if v, ok := t.LsaType[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLsaType(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLsaType got unexpected error: %v", err))
	}
	return v
}

// GetLsaType retrieves the value with the specified key from
// the LsaType map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) GetLsaType(Type E_OpenconfigOspfTypes_OSPF_LSA_TYPE) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.LsaType[key]; ok {
		return lm
	}
	return nil
}

// AppendLsaType appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType struct to the
// list LsaType of NetworkInstance_Protocol_Ospfv2_Area_Lsdb. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) AppendLsaType(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LsaType == nil {
		t.LsaType = make(map[E_OpenconfigOspfTypes_OSPF_LSA_TYPE]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType)
	}

	if _, ok := t.LsaType[key]; ok {
		return fmt.Errorf("duplicate key for list LsaType %v", key)
	}

	t.LsaType[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewLsa creates a new entry in the Lsa list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) NewLsa(LinkStateId string) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsa == nil {
		t.Lsa = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa)
	}

	key := LinkStateId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Lsa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Lsa", key)
	}

	t.Lsa[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa{
		LinkStateId: &LinkStateId,
	}

	return t.Lsa[key], nil
}

// RenameLsa renames an entry in the list Lsa within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) RenameLsa(oldK, newK string) error {
	if _, ok := t.Lsa[newK]; ok {
		return fmt.Errorf("key %v already exists in Lsa", newK)
	}

	e, ok := t.Lsa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Lsa", oldK)
	}
	e.LinkStateId = &newK

	t.Lsa[newK] = e
	delete(t.Lsa, oldK)
	return nil
}

// GetOrCreateLsa retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) GetOrCreateLsa(LinkStateId string) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa {

	key := LinkStateId

	if v, ok := t.Lsa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLsa(LinkStateId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLsa got unexpected error: %v", err))
	}
	return v
}

// GetLsa retrieves the value with the specified key from
// the Lsa map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) GetLsa(LinkStateId string) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa {

	if t == nil {
		return nil
	}

	key := LinkStateId

	if lm, ok := t.Lsa[key]; ok {
		return lm
	}
	return nil
}

// AppendLsa appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa struct to the
// list Lsa of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) AppendLsa(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) error {
	key := *v.LinkStateId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsa == nil {
		t.Lsa = make(map[string]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa)
	}

	if _, ok := t.Lsa[key]; ok {
		return fmt.Errorf("duplicate key for list Lsa %v", key)
	}

	t.Lsa[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAsExternalLsa retrieves the value of the AsExternalLsa field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateAsExternalLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa {
	if s.AsExternalLsa != nil {
		return s.AsExternalLsa
	}
	s.AsExternalLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa{}
	return s.AsExternalLsa
}

// GetOrCreateNetworkLsa retrieves the value of the NetworkLsa field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateNetworkLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa {
	if s.NetworkLsa != nil {
		return s.NetworkLsa
	}
	s.NetworkLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa{}
	return s.NetworkLsa
}

// GetOrCreateNssaExternalLsa retrieves the value of the NssaExternalLsa field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateNssaExternalLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa {
	if s.NssaExternalLsa != nil {
		return s.NssaExternalLsa
	}
	s.NssaExternalLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa{}
	return s.NssaExternalLsa
}

// GetOrCreateOpaqueLsa retrieves the value of the OpaqueLsa field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateOpaqueLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa {
	if s.OpaqueLsa != nil {
		return s.OpaqueLsa
	}
	s.OpaqueLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa{}
	return s.OpaqueLsa
}

// GetOrCreateRouterLsa retrieves the value of the RouterLsa field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateRouterLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa {
	if s.RouterLsa != nil {
		return s.RouterLsa
	}
	s.RouterLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa{}
	return s.RouterLsa
}

// GetOrCreateSummaryLsa retrieves the value of the SummaryLsa field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOrCreateSummaryLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa {
	if s.SummaryLsa != nil {
		return s.SummaryLsa
	}
	s.SummaryLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa{}
	return s.SummaryLsa
}

// GetAsExternalLsa returns the value of the AsExternalLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field AsExternalLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetAsExternalLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa {
	if s != nil && s.AsExternalLsa != nil {
		return s.AsExternalLsa
	}
	return nil
}

// GetNetworkLsa returns the value of the NetworkLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field NetworkLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetNetworkLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa {
	if s != nil && s.NetworkLsa != nil {
		return s.NetworkLsa
	}
	return nil
}

// GetNssaExternalLsa returns the value of the NssaExternalLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field NssaExternalLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetNssaExternalLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa {
	if s != nil && s.NssaExternalLsa != nil {
		return s.NssaExternalLsa
	}
	return nil
}

// GetOpaqueLsa returns the value of the OpaqueLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field OpaqueLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetOpaqueLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa {
	if s != nil && s.OpaqueLsa != nil {
		return s.OpaqueLsa
	}
	return nil
}

// GetRouterLsa returns the value of the RouterLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field RouterLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetRouterLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa {
	if s != nil && s.RouterLsa != nil {
		return s.RouterLsa
	}
	return nil
}

// GetSummaryLsa returns the value of the SummaryLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa. If the receiver or the field SummaryLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) GetSummaryLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa {
	if s != nil && s.SummaryLsa != nil {
		return s.SummaryLsa
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LinkStateId == nil {
		return nil, fmt.Errorf("nil value for key LinkStateId")
	}

	return map[string]interface{}{
		"link-state-id": *t.LinkStateId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTypeOfService creates a new entry in the TypeOfService list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) NewTypeOfService(Tos uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService)
	}

	key := Tos

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TypeOfService[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TypeOfService", key)
	}

	t.TypeOfService[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService{
		Tos: &Tos,
	}

	return t.TypeOfService[key], nil
}

// RenameTypeOfService renames an entry in the list TypeOfService within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) RenameTypeOfService(oldK, newK uint8) error {
	if _, ok := t.TypeOfService[newK]; ok {
		return fmt.Errorf("key %v already exists in TypeOfService", newK)
	}

	e, ok := t.TypeOfService[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TypeOfService", oldK)
	}
	e.Tos = &newK

	t.TypeOfService[newK] = e
	delete(t.TypeOfService, oldK)
	return nil
}

// GetOrCreateTypeOfService retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) GetOrCreateTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService {

	key := Tos

	if v, ok := t.TypeOfService[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTypeOfService(Tos)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTypeOfService got unexpected error: %v", err))
	}
	return v
}

// GetTypeOfService retrieves the value with the specified key from
// the TypeOfService map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) GetTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService {

	if t == nil {
		return nil
	}

	key := Tos

	if lm, ok := t.TypeOfService[key]; ok {
		return lm
	}
	return nil
}

// AppendTypeOfService appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService struct to the
// list TypeOfService of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) AppendTypeOfService(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService) error {
	key := *v.Tos

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService)
	}

	if _, ok := t.TypeOfService[key]; ok {
		return fmt.Errorf("duplicate key for list TypeOfService %v", key)
	}

	t.TypeOfService[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Tos == nil {
		return nil, fmt.Errorf("nil value for key Tos")
	}

	return map[string]interface{}{
		"tos": *t.Tos,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_AsExternalLsa_TypeOfService) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NetworkLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTypeOfService creates a new entry in the TypeOfService list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) NewTypeOfService(Tos uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService)
	}

	key := Tos

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TypeOfService[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TypeOfService", key)
	}

	t.TypeOfService[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService{
		Tos: &Tos,
	}

	return t.TypeOfService[key], nil
}

// RenameTypeOfService renames an entry in the list TypeOfService within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) RenameTypeOfService(oldK, newK uint8) error {
	if _, ok := t.TypeOfService[newK]; ok {
		return fmt.Errorf("key %v already exists in TypeOfService", newK)
	}

	e, ok := t.TypeOfService[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TypeOfService", oldK)
	}
	e.Tos = &newK

	t.TypeOfService[newK] = e
	delete(t.TypeOfService, oldK)
	return nil
}

// GetOrCreateTypeOfService retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) GetOrCreateTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService {

	key := Tos

	if v, ok := t.TypeOfService[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTypeOfService(Tos)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTypeOfService got unexpected error: %v", err))
	}
	return v
}

// GetTypeOfService retrieves the value with the specified key from
// the TypeOfService map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) GetTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService {

	if t == nil {
		return nil
	}

	key := Tos

	if lm, ok := t.TypeOfService[key]; ok {
		return lm
	}
	return nil
}

// AppendTypeOfService appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService struct to the
// list TypeOfService of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) AppendTypeOfService(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService) error {
	key := *v.Tos

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService)
	}

	if _, ok := t.TypeOfService[key]; ok {
		return fmt.Errorf("duplicate key for list TypeOfService %v", key)
	}

	t.TypeOfService[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Tos == nil {
		return nil, fmt.Errorf("nil value for key Tos")
	}

	return map[string]interface{}{
		"tos": *t.Tos,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_NssaExternalLsa_TypeOfService) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateExtendedLink retrieves the value of the ExtendedLink field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateExtendedLink() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink {
	if s.ExtendedLink != nil {
		return s.ExtendedLink
	}
	s.ExtendedLink = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink{}
	return s.ExtendedLink
}

// GetOrCreateExtendedPrefix retrieves the value of the ExtendedPrefix field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateExtendedPrefix() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix {
	if s.ExtendedPrefix != nil {
		return s.ExtendedPrefix
	}
	s.ExtendedPrefix = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix{}
	return s.ExtendedPrefix
}

// GetOrCreateGraceLsa retrieves the value of the GraceLsa field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateGraceLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa {
	if s.GraceLsa != nil {
		return s.GraceLsa
	}
	s.GraceLsa = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa{}
	return s.GraceLsa
}

// GetOrCreateRouterInformation retrieves the value of the RouterInformation field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateRouterInformation() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation {
	if s.RouterInformation != nil {
		return s.RouterInformation
	}
	s.RouterInformation = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation{}
	return s.RouterInformation
}

// GetOrCreateTrafficEngineering retrieves the value of the TrafficEngineering field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateTrafficEngineering() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering {
	if s.TrafficEngineering != nil {
		return s.TrafficEngineering
	}
	s.TrafficEngineering = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering{}
	return s.TrafficEngineering
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv {
	if s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	s.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv{}
	return s.UnknownTlv
}

// GetExtendedLink returns the value of the ExtendedLink struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field ExtendedLink is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetExtendedLink() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink {
	if s != nil && s.ExtendedLink != nil {
		return s.ExtendedLink
	}
	return nil
}

// GetExtendedPrefix returns the value of the ExtendedPrefix struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field ExtendedPrefix is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetExtendedPrefix() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix {
	if s != nil && s.ExtendedPrefix != nil {
		return s.ExtendedPrefix
	}
	return nil
}

// GetGraceLsa returns the value of the GraceLsa struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field GraceLsa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetGraceLsa() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa {
	if s != nil && s.GraceLsa != nil {
		return s.GraceLsa
	}
	return nil
}

// GetRouterInformation returns the value of the RouterInformation struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field RouterInformation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetRouterInformation() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation {
	if s != nil && s.RouterInformation != nil {
		return s.RouterInformation
	}
	return nil
}

// GetTrafficEngineering returns the value of the TrafficEngineering struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field TrafficEngineering is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetTrafficEngineering() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering {
	if s != nil && s.TrafficEngineering != nil {
		return s.TrafficEngineering
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv {
	if s != nil && s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateAdjacencySid retrieves the value of the AdjacencySid field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) GetOrCreateAdjacencySid() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid {
	if s.AdjacencySid != nil {
		return s.AdjacencySid
	}
	s.AdjacencySid = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid{}
	return s.AdjacencySid
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv {
	if s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	s.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv{}
	return s.UnknownTlv
}

// GetAdjacencySid returns the value of the AdjacencySid struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv. If the receiver or the field AdjacencySid is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) GetAdjacencySid() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid {
	if s != nil && s.AdjacencySid != nil {
		return s.AdjacencySid
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv {
	if s != nil && s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateExtendedPrefixRange retrieves the value of the ExtendedPrefixRange field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetOrCreateExtendedPrefixRange() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange {
	if s.ExtendedPrefixRange != nil {
		return s.ExtendedPrefixRange
	}
	s.ExtendedPrefixRange = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange{}
	return s.ExtendedPrefixRange
}

// GetOrCreatePrefixSid retrieves the value of the PrefixSid field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetOrCreatePrefixSid() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid {
	if s.PrefixSid != nil {
		return s.PrefixSid
	}
	s.PrefixSid = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid{}
	return s.PrefixSid
}

// GetOrCreateSidLabelBinding retrieves the value of the SidLabelBinding field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetOrCreateSidLabelBinding() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding {
	if s.SidLabelBinding != nil {
		return s.SidLabelBinding
	}
	s.SidLabelBinding = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding{}
	return s.SidLabelBinding
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv {
	if s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	s.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv{}
	return s.UnknownTlv
}

// GetExtendedPrefixRange returns the value of the ExtendedPrefixRange struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv. If the receiver or the field ExtendedPrefixRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetExtendedPrefixRange() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange {
	if s != nil && s.ExtendedPrefixRange != nil {
		return s.ExtendedPrefixRange
	}
	return nil
}

// GetPrefixSid returns the value of the PrefixSid struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv. If the receiver or the field PrefixSid is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetPrefixSid() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid {
	if s != nil && s.PrefixSid != nil {
		return s.PrefixSid
	}
	return nil
}

// GetSidLabelBinding returns the value of the SidLabelBinding struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv. If the receiver or the field SidLabelBinding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetSidLabelBinding() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding {
	if s != nil && s.SidLabelBinding != nil {
		return s.SidLabelBinding
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv {
	if s != nil && s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_ExtendedPrefixRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateEroMetric retrieves the value of the EroMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetOrCreateEroMetric() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric {
	if s.EroMetric != nil {
		return s.EroMetric
	}
	s.EroMetric = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric{}
	return s.EroMetric
}

// GetOrCreateEroPath retrieves the value of the EroPath field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetOrCreateEroPath() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath {
	if s.EroPath != nil {
		return s.EroPath
	}
	s.EroPath = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath{}
	return s.EroPath
}

// GetOrCreateSidLabelBinding retrieves the value of the SidLabelBinding field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetOrCreateSidLabelBinding() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding {
	if s.SidLabelBinding != nil {
		return s.SidLabelBinding
	}
	s.SidLabelBinding = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding{}
	return s.SidLabelBinding
}

// GetEroMetric returns the value of the EroMetric struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv. If the receiver or the field EroMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetEroMetric() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric {
	if s != nil && s.EroMetric != nil {
		return s.EroMetric
	}
	return nil
}

// GetEroPath returns the value of the EroPath struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv. If the receiver or the field EroPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetEroPath() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath {
	if s != nil && s.EroPath != nil {
		return s.EroPath
	}
	return nil
}

// GetSidLabelBinding returns the value of the SidLabelBinding struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv. If the receiver or the field SidLabelBinding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) GetSidLabelBinding() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding {
	if s != nil && s.SidLabelBinding != nil {
		return s.SidLabelBinding
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateIpv4Segment retrieves the value of the Ipv4Segment field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) GetOrCreateIpv4Segment() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment {
	if s.Ipv4Segment != nil {
		return s.Ipv4Segment
	}
	s.Ipv4Segment = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment{}
	return s.Ipv4Segment
}

// GetOrCreateUnnumberedHop retrieves the value of the UnnumberedHop field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) GetOrCreateUnnumberedHop() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop {
	if s.UnnumberedHop != nil {
		return s.UnnumberedHop
	}
	s.UnnumberedHop = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop{}
	return s.UnnumberedHop
}

// GetIpv4Segment returns the value of the Ipv4Segment struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment. If the receiver or the field Ipv4Segment is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) GetIpv4Segment() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment {
	if s != nil && s.Ipv4Segment != nil {
		return s.Ipv4Segment
	}
	return nil
}

// GetUnnumberedHop returns the value of the UnnumberedHop struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment. If the receiver or the field UnnumberedHop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) GetUnnumberedHop() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop {
	if s != nil && s.UnnumberedHop != nil {
		return s.UnnumberedHop
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_Ipv4Segment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_EroPath_Segment_UnnumberedHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_SidLabelBinding_Tlv_SidLabelBinding) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedPrefix_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv {
	if s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	s.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv{}
	return s.UnknownTlv
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv {
	if s != nil && s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_GraceLsa_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInformationalCapabilities retrieves the value of the InformationalCapabilities field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetOrCreateInformationalCapabilities() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities {
	if s.InformationalCapabilities != nil {
		return s.InformationalCapabilities
	}
	s.InformationalCapabilities = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities{}
	return s.InformationalCapabilities
}

// GetOrCreateNodeAdministrativeTags retrieves the value of the NodeAdministrativeTags field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetOrCreateNodeAdministrativeTags() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags {
	if s.NodeAdministrativeTags != nil {
		return s.NodeAdministrativeTags
	}
	s.NodeAdministrativeTags = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags{}
	return s.NodeAdministrativeTags
}

// GetOrCreateSegmentRoutingAlgorithm retrieves the value of the SegmentRoutingAlgorithm field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetOrCreateSegmentRoutingAlgorithm() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm {
	if s.SegmentRoutingAlgorithm != nil {
		return s.SegmentRoutingAlgorithm
	}
	s.SegmentRoutingAlgorithm = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm{}
	return s.SegmentRoutingAlgorithm
}

// GetOrCreateSegmentRoutingSidLabelRange retrieves the value of the SegmentRoutingSidLabelRange field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetOrCreateSegmentRoutingSidLabelRange() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange {
	if s.SegmentRoutingSidLabelRange != nil {
		return s.SegmentRoutingSidLabelRange
	}
	s.SegmentRoutingSidLabelRange = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange{}
	return s.SegmentRoutingSidLabelRange
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv {
	if s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	s.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv{}
	return s.UnknownTlv
}

// GetInformationalCapabilities returns the value of the InformationalCapabilities struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv. If the receiver or the field InformationalCapabilities is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetInformationalCapabilities() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities {
	if s != nil && s.InformationalCapabilities != nil {
		return s.InformationalCapabilities
	}
	return nil
}

// GetNodeAdministrativeTags returns the value of the NodeAdministrativeTags struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv. If the receiver or the field NodeAdministrativeTags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetNodeAdministrativeTags() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags {
	if s != nil && s.NodeAdministrativeTags != nil {
		return s.NodeAdministrativeTags
	}
	return nil
}

// GetSegmentRoutingAlgorithm returns the value of the SegmentRoutingAlgorithm struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv. If the receiver or the field SegmentRoutingAlgorithm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetSegmentRoutingAlgorithm() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm {
	if s != nil && s.SegmentRoutingAlgorithm != nil {
		return s.SegmentRoutingAlgorithm
	}
	return nil
}

// GetSegmentRoutingSidLabelRange returns the value of the SegmentRoutingSidLabelRange struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv. If the receiver or the field SegmentRoutingSidLabelRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetSegmentRoutingSidLabelRange() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange {
	if s != nil && s.SegmentRoutingSidLabelRange != nil {
		return s.SegmentRoutingSidLabelRange
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv {
	if s != nil && s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_InformationalCapabilities) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_NodeAdministrativeTags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingAlgorithm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateSidLabel retrieves the value of the SidLabel field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) GetOrCreateSidLabel() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel {
	if s.SidLabel != nil {
		return s.SidLabel
	}
	s.SidLabel = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel{}
	return s.SidLabel
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv {
	if s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	s.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv{}
	return s.UnknownTlv
}

// GetSidLabel returns the value of the SidLabel struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv. If the receiver or the field SidLabel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) GetSidLabel() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel {
	if s != nil && s.SidLabel != nil {
		return s.SidLabel
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv {
	if s != nil && s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_SidLabel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLink retrieves the value of the Link field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetOrCreateLink() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link {
	if s.Link != nil {
		return s.Link
	}
	s.Link = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link{}
	return s.Link
}

// GetOrCreateNodeAttribute retrieves the value of the NodeAttribute field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetOrCreateNodeAttribute() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute {
	if s.NodeAttribute != nil {
		return s.NodeAttribute
	}
	s.NodeAttribute = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute{}
	return s.NodeAttribute
}

// GetOrCreateRouterAddress retrieves the value of the RouterAddress field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetOrCreateRouterAddress() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress {
	if s.RouterAddress != nil {
		return s.RouterAddress
	}
	s.RouterAddress = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress{}
	return s.RouterAddress
}

// GetOrCreateUnknownTlv retrieves the value of the UnknownTlv field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetOrCreateUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv {
	if s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	s.UnknownTlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv{}
	return s.UnknownTlv
}

// GetLink returns the value of the Link struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv. If the receiver or the field Link is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetLink() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link {
	if s != nil && s.Link != nil {
		return s.Link
	}
	return nil
}

// GetNodeAttribute returns the value of the NodeAttribute struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv. If the receiver or the field NodeAttribute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetNodeAttribute() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute {
	if s != nil && s.NodeAttribute != nil {
		return s.NodeAttribute
	}
	return nil
}

// GetRouterAddress returns the value of the RouterAddress struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv. If the receiver or the field RouterAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetRouterAddress() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress {
	if s != nil && s.RouterAddress != nil {
		return s.RouterAddress
	}
	return nil
}

// GetUnknownTlv returns the value of the UnknownTlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv. If the receiver or the field UnknownTlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) GetUnknownTlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv {
	if s != nil && s.UnknownTlv != nil {
		return s.UnknownTlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewAdminGroup creates a new entry in the AdminGroup list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) NewAdminGroup(BitIndex uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup)
	}

	key := BitIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdminGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdminGroup", key)
	}

	t.AdminGroup[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup{
		BitIndex: &BitIndex,
	}

	return t.AdminGroup[key], nil
}

// RenameAdminGroup renames an entry in the list AdminGroup within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) RenameAdminGroup(oldK, newK uint8) error {
	if _, ok := t.AdminGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in AdminGroup", newK)
	}

	e, ok := t.AdminGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdminGroup", oldK)
	}
	e.BitIndex = &newK

	t.AdminGroup[newK] = e
	delete(t.AdminGroup, oldK)
	return nil
}

// GetOrCreateAdminGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetOrCreateAdminGroup(BitIndex uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup {

	key := BitIndex

	if v, ok := t.AdminGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdminGroup(BitIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdminGroup got unexpected error: %v", err))
	}
	return v
}

// GetAdminGroup retrieves the value with the specified key from
// the AdminGroup map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetAdminGroup(BitIndex uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup {

	if t == nil {
		return nil
	}

	key := BitIndex

	if lm, ok := t.AdminGroup[key]; ok {
		return lm
	}
	return nil
}

// AppendAdminGroup appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup struct to the
// list AdminGroup of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) AppendAdminGroup(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup) error {
	key := *v.BitIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup)
	}

	if _, ok := t.AdminGroup[key]; ok {
		return fmt.Errorf("duplicate key for list AdminGroup %v", key)
	}

	t.AdminGroup[key] = v
	return nil
}

// NewUnreservedBandwidth creates a new entry in the UnreservedBandwidth list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) NewUnreservedBandwidth(Priority uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnreservedBandwidth == nil {
		t.UnreservedBandwidth = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UnreservedBandwidth[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UnreservedBandwidth", key)
	}

	t.UnreservedBandwidth[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth{
		Priority: &Priority,
	}

	return t.UnreservedBandwidth[key], nil
}

// RenameUnreservedBandwidth renames an entry in the list UnreservedBandwidth within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) RenameUnreservedBandwidth(oldK, newK uint8) error {
	if _, ok := t.UnreservedBandwidth[newK]; ok {
		return fmt.Errorf("key %v already exists in UnreservedBandwidth", newK)
	}

	e, ok := t.UnreservedBandwidth[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UnreservedBandwidth", oldK)
	}
	e.Priority = &newK

	t.UnreservedBandwidth[newK] = e
	delete(t.UnreservedBandwidth, oldK)
	return nil
}

// GetOrCreateUnreservedBandwidth retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetOrCreateUnreservedBandwidth(Priority uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth {

	key := Priority

	if v, ok := t.UnreservedBandwidth[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUnreservedBandwidth(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUnreservedBandwidth got unexpected error: %v", err))
	}
	return v
}

// GetUnreservedBandwidth retrieves the value with the specified key from
// the UnreservedBandwidth map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetUnreservedBandwidth(Priority uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.UnreservedBandwidth[key]; ok {
		return lm
	}
	return nil
}

// AppendUnreservedBandwidth appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth struct to the
// list UnreservedBandwidth of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) AppendUnreservedBandwidth(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth) error {
	key := *v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnreservedBandwidth == nil {
		t.UnreservedBandwidth = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth)
	}

	if _, ok := t.UnreservedBandwidth[key]; ok {
		return fmt.Errorf("duplicate key for list UnreservedBandwidth %v", key)
	}

	t.UnreservedBandwidth[key] = v
	return nil
}

// GetOrCreateUnknownSubtlv retrieves the value of the UnknownSubtlv field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetOrCreateUnknownSubtlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv {
	if s.UnknownSubtlv != nil {
		return s.UnknownSubtlv
	}
	s.UnknownSubtlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv{}
	return s.UnknownSubtlv
}

// GetUnknownSubtlv returns the value of the UnknownSubtlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv. If the receiver or the field UnknownSubtlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) GetUnknownSubtlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv {
	if s != nil && s.UnknownSubtlv != nil {
		return s.UnknownSubtlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BitIndex == nil {
		return nil, fmt.Errorf("nil value for key BitIndex")
	}

	return map[string]interface{}{
		"bit-index": *t.BitIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnknownSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Priority == nil {
		return nil, fmt.Errorf("nil value for key Priority")
	}

	return map[string]interface{}{
		"priority": *t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_UnreservedBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateUnknownSubtlv retrieves the value of the UnknownSubtlv field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv) GetOrCreateUnknownSubtlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv {
	if s.UnknownSubtlv != nil {
		return s.UnknownSubtlv
	}
	s.UnknownSubtlv = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv{}
	return s.UnknownSubtlv
}

// GetUnknownSubtlv returns the value of the UnknownSubtlv struct pointer
// from NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv. If the receiver or the field UnknownSubtlv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv) GetUnknownSubtlv() *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv {
	if s != nil && s.UnknownSubtlv != nil {
		return s.UnknownSubtlv
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_UnknownSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_RouterAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_UnknownTlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTypeOfService creates a new entry in the TypeOfService list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) NewTypeOfService(Tos uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService)
	}

	key := Tos

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TypeOfService[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TypeOfService", key)
	}

	t.TypeOfService[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService{
		Tos: &Tos,
	}

	return t.TypeOfService[key], nil
}

// RenameTypeOfService renames an entry in the list TypeOfService within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) RenameTypeOfService(oldK, newK uint8) error {
	if _, ok := t.TypeOfService[newK]; ok {
		return fmt.Errorf("key %v already exists in TypeOfService", newK)
	}

	e, ok := t.TypeOfService[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TypeOfService", oldK)
	}
	e.Tos = &newK

	t.TypeOfService[newK] = e
	delete(t.TypeOfService, oldK)
	return nil
}

// GetOrCreateTypeOfService retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) GetOrCreateTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService {

	key := Tos

	if v, ok := t.TypeOfService[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTypeOfService(Tos)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTypeOfService got unexpected error: %v", err))
	}
	return v
}

// GetTypeOfService retrieves the value with the specified key from
// the TypeOfService map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) GetTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService {

	if t == nil {
		return nil
	}

	key := Tos

	if lm, ok := t.TypeOfService[key]; ok {
		return lm
	}
	return nil
}

// AppendTypeOfService appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService struct to the
// list TypeOfService of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) AppendTypeOfService(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService) error {
	key := *v.Tos

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService)
	}

	if _, ok := t.TypeOfService[key]; ok {
		return fmt.Errorf("duplicate key for list TypeOfService %v", key)
	}

	t.TypeOfService[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Tos == nil {
		return nil, fmt.Errorf("nil value for key Tos")
	}

	return map[string]interface{}{
		"tos": *t.Tos,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_TypeOfService) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewTypeOfService creates a new entry in the TypeOfService list of the
// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) NewTypeOfService(Tos uint8) (*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService)
	}

	key := Tos

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TypeOfService[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TypeOfService", key)
	}

	t.TypeOfService[key] = &NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService{
		Tos: &Tos,
	}

	return t.TypeOfService[key], nil
}

// RenameTypeOfService renames an entry in the list TypeOfService within
// the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) RenameTypeOfService(oldK, newK uint8) error {
	if _, ok := t.TypeOfService[newK]; ok {
		return fmt.Errorf("key %v already exists in TypeOfService", newK)
	}

	e, ok := t.TypeOfService[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TypeOfService", oldK)
	}
	e.Tos = &newK

	t.TypeOfService[newK] = e
	delete(t.TypeOfService, oldK)
	return nil
}

// GetOrCreateTypeOfService retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) GetOrCreateTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService {

	key := Tos

	if v, ok := t.TypeOfService[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTypeOfService(Tos)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTypeOfService got unexpected error: %v", err))
	}
	return v
}

// GetTypeOfService retrieves the value with the specified key from
// the TypeOfService map field of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) GetTypeOfService(Tos uint8) *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService {

	if t == nil {
		return nil
	}

	key := Tos

	if lm, ok := t.TypeOfService[key]; ok {
		return lm
	}
	return nil
}

// AppendTypeOfService appends the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService struct to the
// list TypeOfService of NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) AppendTypeOfService(v *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService) error {
	key := *v.Tos

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TypeOfService == nil {
		t.TypeOfService = make(map[uint8]*NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService)
	}

	if _, ok := t.TypeOfService[key]; ok {
		return fmt.Errorf("duplicate key for list TypeOfService %v", key)
	}

	t.TypeOfService[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Tos == nil {
		return nil, fmt.Errorf("nil value for key Tos")
	}

	return map[string]interface{}{
		"tos": *t.Tos,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_SummaryLsa_TypeOfService) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_Mpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Area_VirtualLink struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink) ΛListKeyMap() (map[string]interface{}, error) {
	if t.RemoteRouterId == nil {
		return nil, fmt.Errorf("nil value for key RemoteRouterId")
	}

	return map[string]interface{}{
		"remote-router-id": *t.RemoteRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Area_VirtualLink"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Area_VirtualLink) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterAreaPropagationPolicy creates a new entry in the InterAreaPropagationPolicy list of the
// NetworkInstance_Protocol_Ospfv2_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Ospfv2_Global) NewInterAreaPropagationPolicy(SrcArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union, DstArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) (*NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InterAreaPropagationPolicy == nil {
		t.InterAreaPropagationPolicy = make(map[NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key]*NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy)
	}

	key := NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key{
		SrcArea: SrcArea,
		DstArea: DstArea,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.InterAreaPropagationPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list InterAreaPropagationPolicy", key)
	}

	t.InterAreaPropagationPolicy[key] = &NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy{
		SrcArea: SrcArea,
		DstArea: DstArea,
	}

	return t.InterAreaPropagationPolicy[key], nil
}

// RenameInterAreaPropagationPolicy renames an entry in the list InterAreaPropagationPolicy within
// the NetworkInstance_Protocol_Ospfv2_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Ospfv2_Global) RenameInterAreaPropagationPolicy(oldK, newK NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key) error {
	if _, ok := t.InterAreaPropagationPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in InterAreaPropagationPolicy", newK)
	}

	e, ok := t.InterAreaPropagationPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in InterAreaPropagationPolicy", oldK)
	}
	e.SrcArea = newK.SrcArea
	e.DstArea = newK.DstArea

	t.InterAreaPropagationPolicy[newK] = e
	delete(t.InterAreaPropagationPolicy, oldK)
	return nil
}

// GetOrCreateInterAreaPropagationPolicy retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Ospfv2_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Ospfv2_Global) GetOrCreateInterAreaPropagationPolicy(SrcArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union, DstArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy {

	key := NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key{
		SrcArea: SrcArea,
		DstArea: DstArea,
	}

	if v, ok := t.InterAreaPropagationPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterAreaPropagationPolicy(SrcArea, DstArea)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterAreaPropagationPolicy got unexpected error: %v", err))
	}
	return v
}

// GetInterAreaPropagationPolicy retrieves the value with the specified key from
// the InterAreaPropagationPolicy map field of NetworkInstance_Protocol_Ospfv2_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Ospfv2_Global) GetInterAreaPropagationPolicy(SrcArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union, DstArea NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union) *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key{
		SrcArea: SrcArea,
		DstArea: DstArea,
	}

	if lm, ok := t.InterAreaPropagationPolicy[key]; ok {
		return lm
	}
	return nil
}

// AppendInterAreaPropagationPolicy appends the supplied NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy struct to the
// list InterAreaPropagationPolicy of NetworkInstance_Protocol_Ospfv2_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Ospfv2_Global) AppendInterAreaPropagationPolicy(v *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy) error {
	key := NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key{SrcArea: v.SrcArea, DstArea: v.DstArea}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InterAreaPropagationPolicy == nil {
		t.InterAreaPropagationPolicy = make(map[NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy_Key]*NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy)
	}

	if _, ok := t.InterAreaPropagationPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list InterAreaPropagationPolicy %v", key)
	}

	t.InterAreaPropagationPolicy[key] = v
	return nil
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Global) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart {
	if s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	s.GracefulRestart = &NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart{}
	return s.GracefulRestart
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Global) GetOrCreateMpls() *NetworkInstance_Protocol_Ospfv2_Global_Mpls {
	if s.Mpls != nil {
		return s.Mpls
	}
	s.Mpls = &NetworkInstance_Protocol_Ospfv2_Global_Mpls{}
	return s.Mpls
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Global) GetOrCreateTimers() *NetworkInstance_Protocol_Ospfv2_Global_Timers {
	if s.Timers != nil {
		return s.Timers
	}
	s.Timers = &NetworkInstance_Protocol_Ospfv2_Global_Timers{}
	return s.Timers
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Global) GetGracefulRestart() *NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart {
	if s != nil && s.GracefulRestart != nil {
		return s.GracefulRestart
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Global) GetMpls() *NetworkInstance_Protocol_Ospfv2_Global_Mpls {
	if s != nil && s.Mpls != nil {
		return s.Mpls
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Global) GetTimers() *NetworkInstance_Protocol_Ospfv2_Global_Timers {
	if s != nil && s.Timers != nil {
		return s.Timers
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"dst-area": t.DstArea,
		"src-area": t.SrcArea,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateIgpLdpSync retrieves the value of the IgpLdpSync field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Mpls) GetOrCreateIgpLdpSync() *NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync {
	if s.IgpLdpSync != nil {
		return s.IgpLdpSync
	}
	s.IgpLdpSync = &NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync{}
	return s.IgpLdpSync
}

// GetIgpLdpSync returns the value of the IgpLdpSync struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global_Mpls. If the receiver or the field IgpLdpSync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Mpls) GetIgpLdpSync() *NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync {
	if s != nil && s.IgpLdpSync != nil {
		return s.IgpLdpSync
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Mpls"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Mpls_IgpLdpSync) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateLsaGeneration retrieves the value of the LsaGeneration field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetOrCreateLsaGeneration() *NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration {
	if s.LsaGeneration != nil {
		return s.LsaGeneration
	}
	s.LsaGeneration = &NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration{}
	return s.LsaGeneration
}

// GetOrCreateMaxMetric retrieves the value of the MaxMetric field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetOrCreateMaxMetric() *NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric {
	if s.MaxMetric != nil {
		return s.MaxMetric
	}
	s.MaxMetric = &NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric{}
	return s.MaxMetric
}

// GetOrCreateSpf retrieves the value of the Spf field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetOrCreateSpf() *NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf {
	if s.Spf != nil {
		return s.Spf
	}
	s.Spf = &NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf{}
	return s.Spf
}

// GetLsaGeneration returns the value of the LsaGeneration struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global_Timers. If the receiver or the field LsaGeneration is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetLsaGeneration() *NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration {
	if s != nil && s.LsaGeneration != nil {
		return s.LsaGeneration
	}
	return nil
}

// GetMaxMetric returns the value of the MaxMetric struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global_Timers. If the receiver or the field MaxMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetMaxMetric() *NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric {
	if s != nil && s.MaxMetric != nil {
		return s.MaxMetric
	}
	return nil
}

// GetSpf returns the value of the Spf struct pointer
// from NetworkInstance_Protocol_Ospfv2_Global_Timers. If the receiver or the field Spf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Timers) GetSpf() *NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf {
	if s != nil && s.Spf != nil {
		return s.Spf
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Timers"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers_LsaGeneration) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers_MaxMetric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Ospfv2_Global_Timers_Spf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Protocol_Static struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Static) NewNextHop(Index string) (*NetworkInstance_Protocol_Static_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[string]*NetworkInstance_Protocol_Static_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Protocol_Static_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Protocol_Static struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Static) RenameNextHop(oldK, newK string) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Static. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Static) GetOrCreateNextHop(Index string) *NetworkInstance_Protocol_Static_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Protocol_Static. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Static) GetNextHop(Index string) *NetworkInstance_Protocol_Static_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// AppendNextHop appends the supplied NetworkInstance_Protocol_Static_NextHop struct to the
// list NextHop of NetworkInstance_Protocol_Static. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Static_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Static) AppendNextHop(v *NetworkInstance_Protocol_Static_NextHop) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[string]*NetworkInstance_Protocol_Static_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Static struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Static) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Static) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Static"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Static) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (s *NetworkInstance_Protocol_Static_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Protocol_Static_NextHop_InterfaceRef {
	if s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	s.InterfaceRef = &NetworkInstance_Protocol_Static_NextHop_InterfaceRef{}
	return s.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Protocol_Static_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *NetworkInstance_Protocol_Static_NextHop) GetInterfaceRef() *NetworkInstance_Protocol_Static_NextHop_InterfaceRef {
	if s != nil && s.InterfaceRef != nil {
		return s.InterfaceRef
	}
	return nil
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Static_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Static_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Static_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Static_NextHop"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Static_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Protocol_Static_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Static_NextHop_InterfaceRef"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Static_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSrgb creates a new entry in the Srgb list of the
// NetworkInstance_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_SegmentRouting) NewSrgb(LocalId string) (*NetworkInstance_SegmentRouting_Srgb, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srgb == nil {
		t.Srgb = make(map[string]*NetworkInstance_SegmentRouting_Srgb)
	}

	key := LocalId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Srgb[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Srgb", key)
	}

	t.Srgb[key] = &NetworkInstance_SegmentRouting_Srgb{
		LocalId: &LocalId,
	}

	return t.Srgb[key], nil
}

// RenameSrgb renames an entry in the list Srgb within
// the NetworkInstance_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_SegmentRouting) RenameSrgb(oldK, newK string) error {
	if _, ok := t.Srgb[newK]; ok {
		return fmt.Errorf("key %v already exists in Srgb", newK)
	}

	e, ok := t.Srgb[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Srgb", oldK)
	}
	e.LocalId = &newK

	t.Srgb[newK] = e
	delete(t.Srgb, oldK)
	return nil
}

// GetOrCreateSrgb retrieves the value with the specified keys from
// the receiver NetworkInstance_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_SegmentRouting) GetOrCreateSrgb(LocalId string) *NetworkInstance_SegmentRouting_Srgb {

	key := LocalId

	if v, ok := t.Srgb[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrgb(LocalId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrgb got unexpected error: %v", err))
	}
	return v
}

// GetSrgb retrieves the value with the specified key from
// the Srgb map field of NetworkInstance_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_SegmentRouting) GetSrgb(LocalId string) *NetworkInstance_SegmentRouting_Srgb {

	if t == nil {
		return nil
	}

	key := LocalId

	if lm, ok := t.Srgb[key]; ok {
		return lm
	}
	return nil
}

// AppendSrgb appends the supplied NetworkInstance_SegmentRouting_Srgb struct to the
// list Srgb of NetworkInstance_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_SegmentRouting_Srgb already exist in the list, an error is
// returned.
func (t *NetworkInstance_SegmentRouting) AppendSrgb(v *NetworkInstance_SegmentRouting_Srgb) error {
	key := *v.LocalId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srgb == nil {
		t.Srgb = make(map[string]*NetworkInstance_SegmentRouting_Srgb)
	}

	if _, ok := t.Srgb[key]; ok {
		return fmt.Errorf("duplicate key for list Srgb %v", key)
	}

	t.Srgb[key] = v
	return nil
}

// NewSrlb creates a new entry in the Srlb list of the
// NetworkInstance_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_SegmentRouting) NewSrlb(LocalId string) (*NetworkInstance_SegmentRouting_Srlb, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlb == nil {
		t.Srlb = make(map[string]*NetworkInstance_SegmentRouting_Srlb)
	}

	key := LocalId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Srlb[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Srlb", key)
	}

	t.Srlb[key] = &NetworkInstance_SegmentRouting_Srlb{
		LocalId: &LocalId,
	}

	return t.Srlb[key], nil
}

// RenameSrlb renames an entry in the list Srlb within
// the NetworkInstance_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_SegmentRouting) RenameSrlb(oldK, newK string) error {
	if _, ok := t.Srlb[newK]; ok {
		return fmt.Errorf("key %v already exists in Srlb", newK)
	}

	e, ok := t.Srlb[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Srlb", oldK)
	}
	e.LocalId = &newK

	t.Srlb[newK] = e
	delete(t.Srlb, oldK)
	return nil
}

// GetOrCreateSrlb retrieves the value with the specified keys from
// the receiver NetworkInstance_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_SegmentRouting) GetOrCreateSrlb(LocalId string) *NetworkInstance_SegmentRouting_Srlb {

	key := LocalId

	if v, ok := t.Srlb[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrlb(LocalId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrlb got unexpected error: %v", err))
	}
	return v
}

// GetSrlb retrieves the value with the specified key from
// the Srlb map field of NetworkInstance_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_SegmentRouting) GetSrlb(LocalId string) *NetworkInstance_SegmentRouting_Srlb {

	if t == nil {
		return nil
	}

	key := LocalId

	if lm, ok := t.Srlb[key]; ok {
		return lm
	}
	return nil
}

// AppendSrlb appends the supplied NetworkInstance_SegmentRouting_Srlb struct to the
// list Srlb of NetworkInstance_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_SegmentRouting_Srlb already exist in the list, an error is
// returned.
func (t *NetworkInstance_SegmentRouting) AppendSrlb(v *NetworkInstance_SegmentRouting_Srlb) error {
	key := *v.LocalId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlb == nil {
		t.Srlb = make(map[string]*NetworkInstance_SegmentRouting_Srlb)
	}

	if _, ok := t.Srlb[key]; ok {
		return fmt.Errorf("duplicate key for list Srlb %v", key)
	}

	t.Srlb[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_SegmentRouting"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the NetworkInstance_SegmentRouting_Srgb struct, which is a YANG list entry.
func (t *NetworkInstance_SegmentRouting_Srgb) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalId == nil {
		return nil, fmt.Errorf("nil value for key LocalId")
	}

	return map[string]interface{}{
		"local-id": *t.LocalId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_SegmentRouting_Srgb) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_SegmentRouting_Srgb"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_SegmentRouting_Srgb) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_SegmentRouting_Srlb struct, which is a YANG list entry.
func (t *NetworkInstance_SegmentRouting_Srlb) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalId == nil {
		return nil, fmt.Errorf("nil value for key LocalId")
	}

	return map[string]interface{}{
		"local-id": *t.LocalId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_SegmentRouting_Srlb) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_SegmentRouting_Srlb"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_SegmentRouting_Srlb) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Table struct, which is a YANG list entry.
func (t *NetworkInstance_Table) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"address-family": t.AddressFamily,
		"protocol":       t.Protocol,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Table) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Table"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Table) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the NetworkInstance_TableConnection struct, which is a YANG list entry.
func (t *NetworkInstance_TableConnection) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"address-family": t.AddressFamily,
		"dst-protocol":   t.DstProtocol,
		"src-protocol":   t.SrcProtocol,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_TableConnection) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_TableConnection"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_TableConnection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the NetworkInstance_Vlan struct, which is a YANG list entry.
func (t *NetworkInstance_Vlan) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VlanId == nil {
		return nil, fmt.Errorf("nil value for key VlanId")
	}

	return map[string]interface{}{
		"vlan-id": *t.VlanId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Vlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Vlan"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Vlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *NetworkInstance_Vlan_Member) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Vlan_Member"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Vlan_Member) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAmplifier creates a new entry in the Amplifier list of the
// OpticalAmplifier struct. The keys of the list are populated from the input
// arguments.
func (t *OpticalAmplifier) NewAmplifier(Name string) (*OpticalAmplifier_Amplifier, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Amplifier == nil {
		t.Amplifier = make(map[string]*OpticalAmplifier_Amplifier)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Amplifier[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Amplifier", key)
	}

	t.Amplifier[key] = &OpticalAmplifier_Amplifier{
		Name: &Name,
	}

	return t.Amplifier[key], nil
}

// RenameAmplifier renames an entry in the list Amplifier within
// the OpticalAmplifier struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *OpticalAmplifier) RenameAmplifier(oldK, newK string) error {
	if _, ok := t.Amplifier[newK]; ok {
		return fmt.Errorf("key %v already exists in Amplifier", newK)
	}

	e, ok := t.Amplifier[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Amplifier", oldK)
	}
	e.Name = &newK

	t.Amplifier[newK] = e
	delete(t.Amplifier, oldK)
	return nil
}

// GetOrCreateAmplifier retrieves the value with the specified keys from
// the receiver OpticalAmplifier. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *OpticalAmplifier) GetOrCreateAmplifier(Name string) *OpticalAmplifier_Amplifier {

	key := Name

	if v, ok := t.Amplifier[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAmplifier(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAmplifier got unexpected error: %v", err))
	}
	return v
}

// GetAmplifier retrieves the value with the specified key from
// the Amplifier map field of OpticalAmplifier. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *OpticalAmplifier) GetAmplifier(Name string) *OpticalAmplifier_Amplifier {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Amplifier[key]; ok {
		return lm
	}
	return nil
}

// AppendAmplifier appends the supplied OpticalAmplifier_Amplifier struct to the
// list Amplifier of OpticalAmplifier. If the key value(s) specified in
// the supplied OpticalAmplifier_Amplifier already exist in the list, an error is
// returned.
func (t *OpticalAmplifier) AppendAmplifier(v *OpticalAmplifier_Amplifier) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Amplifier == nil {
		t.Amplifier = make(map[string]*OpticalAmplifier_Amplifier)
	}

	if _, ok := t.Amplifier[key]; ok {
		return fmt.Errorf("duplicate key for list Amplifier %v", key)
	}

	t.Amplifier[key] = v
	return nil
}

// NewSupervisoryChannel creates a new entry in the SupervisoryChannel list of the
// OpticalAmplifier struct. The keys of the list are populated from the input
// arguments.
func (t *OpticalAmplifier) NewSupervisoryChannel(Interface string) (*OpticalAmplifier_SupervisoryChannel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SupervisoryChannel == nil {
		t.SupervisoryChannel = make(map[string]*OpticalAmplifier_SupervisoryChannel)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SupervisoryChannel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SupervisoryChannel", key)
	}

	t.SupervisoryChannel[key] = &OpticalAmplifier_SupervisoryChannel{
		Interface: &Interface,
	}

	return t.SupervisoryChannel[key], nil
}

// RenameSupervisoryChannel renames an entry in the list SupervisoryChannel within
// the OpticalAmplifier struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *OpticalAmplifier) RenameSupervisoryChannel(oldK, newK string) error {
	if _, ok := t.SupervisoryChannel[newK]; ok {
		return fmt.Errorf("key %v already exists in SupervisoryChannel", newK)
	}

	e, ok := t.SupervisoryChannel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SupervisoryChannel", oldK)
	}
	e.Interface = &newK

	t.SupervisoryChannel[newK] = e
	delete(t.SupervisoryChannel, oldK)
	return nil
}

// GetOrCreateSupervisoryChannel retrieves the value with the specified keys from
// the receiver OpticalAmplifier. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *OpticalAmplifier) GetOrCreateSupervisoryChannel(Interface string) *OpticalAmplifier_SupervisoryChannel {

	key := Interface

	if v, ok := t.SupervisoryChannel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSupervisoryChannel(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSupervisoryChannel got unexpected error: %v", err))
	}
	return v
}

// GetSupervisoryChannel retrieves the value with the specified key from
// the SupervisoryChannel map field of OpticalAmplifier. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *OpticalAmplifier) GetSupervisoryChannel(Interface string) *OpticalAmplifier_SupervisoryChannel {

	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.SupervisoryChannel[key]; ok {
		return lm
	}
	return nil
}

// AppendSupervisoryChannel appends the supplied OpticalAmplifier_SupervisoryChannel struct to the
// list SupervisoryChannel of OpticalAmplifier. If the key value(s) specified in
// the supplied OpticalAmplifier_SupervisoryChannel already exist in the list, an error is
// returned.
func (t *OpticalAmplifier) AppendSupervisoryChannel(v *OpticalAmplifier_SupervisoryChannel) error {
	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SupervisoryChannel == nil {
		t.SupervisoryChannel = make(map[string]*OpticalAmplifier_SupervisoryChannel)
	}

	if _, ok := t.SupervisoryChannel[key]; ok {
		return fmt.Errorf("duplicate key for list SupervisoryChannel %v", key)
	}

	t.SupervisoryChannel[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateActualGain retrieves the value of the ActualGain field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_Amplifier) GetOrCreateActualGain() *OpticalAmplifier_Amplifier_ActualGain {
	if s.ActualGain != nil {
		return s.ActualGain
	}
	s.ActualGain = &OpticalAmplifier_Amplifier_ActualGain{}
	return s.ActualGain
}

// GetOrCreateActualGainTilt retrieves the value of the ActualGainTilt field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_Amplifier) GetOrCreateActualGainTilt() *OpticalAmplifier_Amplifier_ActualGainTilt {
	if s.ActualGainTilt != nil {
		return s.ActualGainTilt
	}
	s.ActualGainTilt = &OpticalAmplifier_Amplifier_ActualGainTilt{}
	return s.ActualGainTilt
}

// GetOrCreateInputPowerCBand retrieves the value of the InputPowerCBand field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_Amplifier) GetOrCreateInputPowerCBand() *OpticalAmplifier_Amplifier_InputPowerCBand {
	if s.InputPowerCBand != nil {
		return s.InputPowerCBand
	}
	s.InputPowerCBand = &OpticalAmplifier_Amplifier_InputPowerCBand{}
	return s.InputPowerCBand
}

// GetOrCreateInputPowerLBand retrieves the value of the InputPowerLBand field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_Amplifier) GetOrCreateInputPowerLBand() *OpticalAmplifier_Amplifier_InputPowerLBand {
	if s.InputPowerLBand != nil {
		return s.InputPowerLBand
	}
	s.InputPowerLBand = &OpticalAmplifier_Amplifier_InputPowerLBand{}
	return s.InputPowerLBand
}

// GetOrCreateInputPowerTotal retrieves the value of the InputPowerTotal field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_Amplifier) GetOrCreateInputPowerTotal() *OpticalAmplifier_Amplifier_InputPowerTotal {
	if s.InputPowerTotal != nil {
		return s.InputPowerTotal
	}
	s.InputPowerTotal = &OpticalAmplifier_Amplifier_InputPowerTotal{}
	return s.InputPowerTotal
}

// GetOrCreateLaserBiasCurrent retrieves the value of the LaserBiasCurrent field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_Amplifier) GetOrCreateLaserBiasCurrent() *OpticalAmplifier_Amplifier_LaserBiasCurrent {
	if s.LaserBiasCurrent != nil {
		return s.LaserBiasCurrent
	}
	s.LaserBiasCurrent = &OpticalAmplifier_Amplifier_LaserBiasCurrent{}
	return s.LaserBiasCurrent
}

// GetOrCreateOpticalReturnLoss retrieves the value of the OpticalReturnLoss field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_Amplifier) GetOrCreateOpticalReturnLoss() *OpticalAmplifier_Amplifier_OpticalReturnLoss {
	if s.OpticalReturnLoss != nil {
		return s.OpticalReturnLoss
	}
	s.OpticalReturnLoss = &OpticalAmplifier_Amplifier_OpticalReturnLoss{}
	return s.OpticalReturnLoss
}

// GetOrCreateOutputPowerCBand retrieves the value of the OutputPowerCBand field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_Amplifier) GetOrCreateOutputPowerCBand() *OpticalAmplifier_Amplifier_OutputPowerCBand {
	if s.OutputPowerCBand != nil {
		return s.OutputPowerCBand
	}
	s.OutputPowerCBand = &OpticalAmplifier_Amplifier_OutputPowerCBand{}
	return s.OutputPowerCBand
}

// GetOrCreateOutputPowerLBand retrieves the value of the OutputPowerLBand field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_Amplifier) GetOrCreateOutputPowerLBand() *OpticalAmplifier_Amplifier_OutputPowerLBand {
	if s.OutputPowerLBand != nil {
		return s.OutputPowerLBand
	}
	s.OutputPowerLBand = &OpticalAmplifier_Amplifier_OutputPowerLBand{}
	return s.OutputPowerLBand
}

// GetOrCreateOutputPowerTotal retrieves the value of the OutputPowerTotal field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_Amplifier) GetOrCreateOutputPowerTotal() *OpticalAmplifier_Amplifier_OutputPowerTotal {
	if s.OutputPowerTotal != nil {
		return s.OutputPowerTotal
	}
	s.OutputPowerTotal = &OpticalAmplifier_Amplifier_OutputPowerTotal{}
	return s.OutputPowerTotal
}

// GetActualGain returns the value of the ActualGain struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field ActualGain is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_Amplifier) GetActualGain() *OpticalAmplifier_Amplifier_ActualGain {
	if s != nil && s.ActualGain != nil {
		return s.ActualGain
	}
	return nil
}

// GetActualGainTilt returns the value of the ActualGainTilt struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field ActualGainTilt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_Amplifier) GetActualGainTilt() *OpticalAmplifier_Amplifier_ActualGainTilt {
	if s != nil && s.ActualGainTilt != nil {
		return s.ActualGainTilt
	}
	return nil
}

// GetInputPowerCBand returns the value of the InputPowerCBand struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field InputPowerCBand is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_Amplifier) GetInputPowerCBand() *OpticalAmplifier_Amplifier_InputPowerCBand {
	if s != nil && s.InputPowerCBand != nil {
		return s.InputPowerCBand
	}
	return nil
}

// GetInputPowerLBand returns the value of the InputPowerLBand struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field InputPowerLBand is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_Amplifier) GetInputPowerLBand() *OpticalAmplifier_Amplifier_InputPowerLBand {
	if s != nil && s.InputPowerLBand != nil {
		return s.InputPowerLBand
	}
	return nil
}

// GetInputPowerTotal returns the value of the InputPowerTotal struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field InputPowerTotal is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_Amplifier) GetInputPowerTotal() *OpticalAmplifier_Amplifier_InputPowerTotal {
	if s != nil && s.InputPowerTotal != nil {
		return s.InputPowerTotal
	}
	return nil
}

// GetLaserBiasCurrent returns the value of the LaserBiasCurrent struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field LaserBiasCurrent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_Amplifier) GetLaserBiasCurrent() *OpticalAmplifier_Amplifier_LaserBiasCurrent {
	if s != nil && s.LaserBiasCurrent != nil {
		return s.LaserBiasCurrent
	}
	return nil
}

// GetOpticalReturnLoss returns the value of the OpticalReturnLoss struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field OpticalReturnLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_Amplifier) GetOpticalReturnLoss() *OpticalAmplifier_Amplifier_OpticalReturnLoss {
	if s != nil && s.OpticalReturnLoss != nil {
		return s.OpticalReturnLoss
	}
	return nil
}

// GetOutputPowerCBand returns the value of the OutputPowerCBand struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field OutputPowerCBand is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_Amplifier) GetOutputPowerCBand() *OpticalAmplifier_Amplifier_OutputPowerCBand {
	if s != nil && s.OutputPowerCBand != nil {
		return s.OutputPowerCBand
	}
	return nil
}

// GetOutputPowerLBand returns the value of the OutputPowerLBand struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field OutputPowerLBand is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_Amplifier) GetOutputPowerLBand() *OpticalAmplifier_Amplifier_OutputPowerLBand {
	if s != nil && s.OutputPowerLBand != nil {
		return s.OutputPowerLBand
	}
	return nil
}

// GetOutputPowerTotal returns the value of the OutputPowerTotal struct pointer
// from OpticalAmplifier_Amplifier. If the receiver or the field OutputPowerTotal is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_Amplifier) GetOutputPowerTotal() *OpticalAmplifier_Amplifier_OutputPowerTotal {
	if s != nil && s.OutputPowerTotal != nil {
		return s.OutputPowerTotal
	}
	return nil
}

// ΛListKeyMap returns the keys of the OpticalAmplifier_Amplifier struct, which is a YANG list entry.
func (t *OpticalAmplifier_Amplifier) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_Amplifier) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_Amplifier_ActualGain) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_ActualGain"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_ActualGain) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_Amplifier_ActualGainTilt) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_ActualGainTilt"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_ActualGainTilt) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_Amplifier_InputPowerCBand) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_InputPowerCBand"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_InputPowerCBand) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_Amplifier_InputPowerLBand) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_InputPowerLBand"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_InputPowerLBand) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_Amplifier_InputPowerTotal) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_InputPowerTotal"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_InputPowerTotal) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_Amplifier_LaserBiasCurrent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_LaserBiasCurrent"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_LaserBiasCurrent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_Amplifier_OpticalReturnLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_OpticalReturnLoss"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_OpticalReturnLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_Amplifier_OutputPowerCBand) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_OutputPowerCBand"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_OutputPowerCBand) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_Amplifier_OutputPowerLBand) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_OutputPowerLBand"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_OutputPowerLBand) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_Amplifier_OutputPowerTotal) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_Amplifier_OutputPowerTotal"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_Amplifier_OutputPowerTotal) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateInputPower retrieves the value of the InputPower field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_SupervisoryChannel) GetOrCreateInputPower() *OpticalAmplifier_SupervisoryChannel_InputPower {
	if s.InputPower != nil {
		return s.InputPower
	}
	s.InputPower = &OpticalAmplifier_SupervisoryChannel_InputPower{}
	return s.InputPower
}

// GetOrCreateLaserBiasCurrent retrieves the value of the LaserBiasCurrent field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_SupervisoryChannel) GetOrCreateLaserBiasCurrent() *OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent {
	if s.LaserBiasCurrent != nil {
		return s.LaserBiasCurrent
	}
	s.LaserBiasCurrent = &OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent{}
	return s.LaserBiasCurrent
}

// GetOrCreateOutputPower retrieves the value of the OutputPower field
// or returns the existing field if it already exists.
func (s *OpticalAmplifier_SupervisoryChannel) GetOrCreateOutputPower() *OpticalAmplifier_SupervisoryChannel_OutputPower {
	if s.OutputPower != nil {
		return s.OutputPower
	}
	s.OutputPower = &OpticalAmplifier_SupervisoryChannel_OutputPower{}
	return s.OutputPower
}

// GetInputPower returns the value of the InputPower struct pointer
// from OpticalAmplifier_SupervisoryChannel. If the receiver or the field InputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_SupervisoryChannel) GetInputPower() *OpticalAmplifier_SupervisoryChannel_InputPower {
	if s != nil && s.InputPower != nil {
		return s.InputPower
	}
	return nil
}

// GetLaserBiasCurrent returns the value of the LaserBiasCurrent struct pointer
// from OpticalAmplifier_SupervisoryChannel. If the receiver or the field LaserBiasCurrent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_SupervisoryChannel) GetLaserBiasCurrent() *OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent {
	if s != nil && s.LaserBiasCurrent != nil {
		return s.LaserBiasCurrent
	}
	return nil
}

// GetOutputPower returns the value of the OutputPower struct pointer
// from OpticalAmplifier_SupervisoryChannel. If the receiver or the field OutputPower is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *OpticalAmplifier_SupervisoryChannel) GetOutputPower() *OpticalAmplifier_SupervisoryChannel_OutputPower {
	if s != nil && s.OutputPower != nil {
		return s.OutputPower
	}
	return nil
}

// ΛListKeyMap returns the keys of the OpticalAmplifier_SupervisoryChannel struct, which is a YANG list entry.
func (t *OpticalAmplifier_SupervisoryChannel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_SupervisoryChannel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_SupervisoryChannel"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_SupervisoryChannel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_SupervisoryChannel_InputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_SupervisoryChannel_InputPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_SupervisoryChannel_InputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_SupervisoryChannel_LaserBiasCurrent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *OpticalAmplifier_SupervisoryChannel_OutputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpticalAmplifier_SupervisoryChannel_OutputPower"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpticalAmplifier_SupervisoryChannel_OutputPower) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPolicyDefinition creates a new entry in the PolicyDefinition list of the
// RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy) NewPolicyDefinition(Name string) (*RoutingPolicy_PolicyDefinition, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyDefinition == nil {
		t.PolicyDefinition = make(map[string]*RoutingPolicy_PolicyDefinition)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PolicyDefinition[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PolicyDefinition", key)
	}

	t.PolicyDefinition[key] = &RoutingPolicy_PolicyDefinition{
		Name: &Name,
	}

	return t.PolicyDefinition[key], nil
}

// RenamePolicyDefinition renames an entry in the list PolicyDefinition within
// the RoutingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy) RenamePolicyDefinition(oldK, newK string) error {
	if _, ok := t.PolicyDefinition[newK]; ok {
		return fmt.Errorf("key %v already exists in PolicyDefinition", newK)
	}

	e, ok := t.PolicyDefinition[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PolicyDefinition", oldK)
	}
	e.Name = &newK

	t.PolicyDefinition[newK] = e
	delete(t.PolicyDefinition, oldK)
	return nil
}

// GetOrCreatePolicyDefinition retrieves the value with the specified keys from
// the receiver RoutingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy) GetOrCreatePolicyDefinition(Name string) *RoutingPolicy_PolicyDefinition {

	key := Name

	if v, ok := t.PolicyDefinition[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicyDefinition(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicyDefinition got unexpected error: %v", err))
	}
	return v
}

// GetPolicyDefinition retrieves the value with the specified key from
// the PolicyDefinition map field of RoutingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy) GetPolicyDefinition(Name string) *RoutingPolicy_PolicyDefinition {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.PolicyDefinition[key]; ok {
		return lm
	}
	return nil
}

// AppendPolicyDefinition appends the supplied RoutingPolicy_PolicyDefinition struct to the
// list PolicyDefinition of RoutingPolicy. If the key value(s) specified in
// the supplied RoutingPolicy_PolicyDefinition already exist in the list, an error is
// returned.
func (t *RoutingPolicy) AppendPolicyDefinition(v *RoutingPolicy_PolicyDefinition) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyDefinition == nil {
		t.PolicyDefinition = make(map[string]*RoutingPolicy_PolicyDefinition)
	}

	if _, ok := t.PolicyDefinition[key]; ok {
		return fmt.Errorf("duplicate key for list PolicyDefinition %v", key)
	}

	t.PolicyDefinition[key] = v
	return nil
}

// GetOrCreateDefinedSets retrieves the value of the DefinedSets field
// or returns the existing field if it already exists.
func (s *RoutingPolicy) GetOrCreateDefinedSets() *RoutingPolicy_DefinedSets {
	if s.DefinedSets != nil {
		return s.DefinedSets
	}
	s.DefinedSets = &RoutingPolicy_DefinedSets{}
	return s.DefinedSets
}

// GetDefinedSets returns the value of the DefinedSets struct pointer
// from RoutingPolicy. If the receiver or the field DefinedSets is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *RoutingPolicy) GetDefinedSets() *RoutingPolicy_DefinedSets {
	if s != nil && s.DefinedSets != nil {
		return s.DefinedSets
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNeighborSet creates a new entry in the NeighborSet list of the
// RoutingPolicy_DefinedSets struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy_DefinedSets) NewNeighborSet(Name string) (*RoutingPolicy_DefinedSets_NeighborSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NeighborSet == nil {
		t.NeighborSet = make(map[string]*RoutingPolicy_DefinedSets_NeighborSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NeighborSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NeighborSet", key)
	}

	t.NeighborSet[key] = &RoutingPolicy_DefinedSets_NeighborSet{
		Name: &Name,
	}

	return t.NeighborSet[key], nil
}

// RenameNeighborSet renames an entry in the list NeighborSet within
// the RoutingPolicy_DefinedSets struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy_DefinedSets) RenameNeighborSet(oldK, newK string) error {
	if _, ok := t.NeighborSet[newK]; ok {
		return fmt.Errorf("key %v already exists in NeighborSet", newK)
	}

	e, ok := t.NeighborSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NeighborSet", oldK)
	}
	e.Name = &newK

	t.NeighborSet[newK] = e
	delete(t.NeighborSet, oldK)
	return nil
}

// GetOrCreateNeighborSet retrieves the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy_DefinedSets) GetOrCreateNeighborSet(Name string) *RoutingPolicy_DefinedSets_NeighborSet {

	key := Name

	if v, ok := t.NeighborSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighborSet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighborSet got unexpected error: %v", err))
	}
	return v
}

// GetNeighborSet retrieves the value with the specified key from
// the NeighborSet map field of RoutingPolicy_DefinedSets. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy_DefinedSets) GetNeighborSet(Name string) *RoutingPolicy_DefinedSets_NeighborSet {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NeighborSet[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighborSet appends the supplied RoutingPolicy_DefinedSets_NeighborSet struct to the
// list NeighborSet of RoutingPolicy_DefinedSets. If the key value(s) specified in
// the supplied RoutingPolicy_DefinedSets_NeighborSet already exist in the list, an error is
// returned.
func (t *RoutingPolicy_DefinedSets) AppendNeighborSet(v *RoutingPolicy_DefinedSets_NeighborSet) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NeighborSet == nil {
		t.NeighborSet = make(map[string]*RoutingPolicy_DefinedSets_NeighborSet)
	}

	if _, ok := t.NeighborSet[key]; ok {
		return fmt.Errorf("duplicate key for list NeighborSet %v", key)
	}

	t.NeighborSet[key] = v
	return nil
}

// NewPrefixSet creates a new entry in the PrefixSet list of the
// RoutingPolicy_DefinedSets struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy_DefinedSets) NewPrefixSet(Name string) (*RoutingPolicy_DefinedSets_PrefixSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSet == nil {
		t.PrefixSet = make(map[string]*RoutingPolicy_DefinedSets_PrefixSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSet", key)
	}

	t.PrefixSet[key] = &RoutingPolicy_DefinedSets_PrefixSet{
		Name: &Name,
	}

	return t.PrefixSet[key], nil
}

// RenamePrefixSet renames an entry in the list PrefixSet within
// the RoutingPolicy_DefinedSets struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy_DefinedSets) RenamePrefixSet(oldK, newK string) error {
	if _, ok := t.PrefixSet[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSet", newK)
	}

	e, ok := t.PrefixSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSet", oldK)
	}
	e.Name = &newK

	t.PrefixSet[newK] = e
	delete(t.PrefixSet, oldK)
	return nil
}

// GetOrCreatePrefixSet retrieves the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy_DefinedSets) GetOrCreatePrefixSet(Name string) *RoutingPolicy_DefinedSets_PrefixSet {

	key := Name

	if v, ok := t.PrefixSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSet got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSet retrieves the value with the specified key from
// the PrefixSet map field of RoutingPolicy_DefinedSets. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy_DefinedSets) GetPrefixSet(Name string) *RoutingPolicy_DefinedSets_PrefixSet {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.PrefixSet[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefixSet appends the supplied RoutingPolicy_DefinedSets_PrefixSet struct to the
// list PrefixSet of RoutingPolicy_DefinedSets. If the key value(s) specified in
// the supplied RoutingPolicy_DefinedSets_PrefixSet already exist in the list, an error is
// returned.
func (t *RoutingPolicy_DefinedSets) AppendPrefixSet(v *RoutingPolicy_DefinedSets_PrefixSet) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSet == nil {
		t.PrefixSet = make(map[string]*RoutingPolicy_DefinedSets_PrefixSet)
	}

	if _, ok := t.PrefixSet[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSet %v", key)
	}

	t.PrefixSet[key] = v
	return nil
}

// NewTagSet creates a new entry in the TagSet list of the
// RoutingPolicy_DefinedSets struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy_DefinedSets) NewTagSet(Name string) (*RoutingPolicy_DefinedSets_TagSet, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TagSet == nil {
		t.TagSet = make(map[string]*RoutingPolicy_DefinedSets_TagSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TagSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TagSet", key)
	}

	t.TagSet[key] = &RoutingPolicy_DefinedSets_TagSet{
		Name: &Name,
	}

	return t.TagSet[key], nil
}

// RenameTagSet renames an entry in the list TagSet within
// the RoutingPolicy_DefinedSets struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy_DefinedSets) RenameTagSet(oldK, newK string) error {
	if _, ok := t.TagSet[newK]; ok {
		return fmt.Errorf("key %v already exists in TagSet", newK)
	}

	e, ok := t.TagSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TagSet", oldK)
	}
	e.Name = &newK

	t.TagSet[newK] = e
	delete(t.TagSet, oldK)
	return nil
}

// GetOrCreateTagSet retrieves the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy_DefinedSets) GetOrCreateTagSet(Name string) *RoutingPolicy_DefinedSets_TagSet {

	key := Name

	if v, ok := t.TagSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTagSet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTagSet got unexpected error: %v", err))
	}
	return v
}

// GetTagSet retrieves the value with the specified key from
// the TagSet map field of RoutingPolicy_DefinedSets. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy_DefinedSets) GetTagSet(Name string) *RoutingPolicy_DefinedSets_TagSet {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.TagSet[key]; ok {
		return lm
	}
	return nil
}

// AppendTagSet appends the supplied RoutingPolicy_DefinedSets_TagSet struct to the
// list TagSet of RoutingPolicy_DefinedSets. If the key value(s) specified in
// the supplied RoutingPolicy_DefinedSets_TagSet already exist in the list, an error is
// returned.
func (t *RoutingPolicy_DefinedSets) AppendTagSet(v *RoutingPolicy_DefinedSets_TagSet) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TagSet == nil {
		t.TagSet = make(map[string]*RoutingPolicy_DefinedSets_TagSet)
	}

	if _, ok := t.TagSet[key]; ok {
		return fmt.Errorf("duplicate key for list TagSet %v", key)
	}

	t.TagSet[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_DefinedSets) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_DefinedSets"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_DefinedSets) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the RoutingPolicy_DefinedSets_NeighborSet struct, which is a YANG list entry.
func (t *RoutingPolicy_DefinedSets_NeighborSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_DefinedSets_NeighborSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_DefinedSets_NeighborSet"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_DefinedSets_NeighborSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewPrefix creates a new entry in the Prefix list of the
// RoutingPolicy_DefinedSets_PrefixSet struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy_DefinedSets_PrefixSet) NewPrefix(IpPrefix string, MasklengthRange string) (*RoutingPolicy_DefinedSets_PrefixSet_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key]*RoutingPolicy_DefinedSets_PrefixSet_Prefix)
	}

	key := RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key{
		IpPrefix:        IpPrefix,
		MasklengthRange: MasklengthRange,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &RoutingPolicy_DefinedSets_PrefixSet_Prefix{
		IpPrefix:        &IpPrefix,
		MasklengthRange: &MasklengthRange,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the RoutingPolicy_DefinedSets_PrefixSet struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy_DefinedSets_PrefixSet) RenamePrefix(oldK, newK RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.IpPrefix = &newK.IpPrefix
	e.MasklengthRange = &newK.MasklengthRange

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver RoutingPolicy_DefinedSets_PrefixSet. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy_DefinedSets_PrefixSet) GetOrCreatePrefix(IpPrefix string, MasklengthRange string) *RoutingPolicy_DefinedSets_PrefixSet_Prefix {

	key := RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key{
		IpPrefix:        IpPrefix,
		MasklengthRange: MasklengthRange,
	}

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(IpPrefix, MasklengthRange)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of RoutingPolicy_DefinedSets_PrefixSet. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy_DefinedSets_PrefixSet) GetPrefix(IpPrefix string, MasklengthRange string) *RoutingPolicy_DefinedSets_PrefixSet_Prefix {

	if t == nil {
		return nil
	}

	key := RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key{
		IpPrefix:        IpPrefix,
		MasklengthRange: MasklengthRange,
	}

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// AppendPrefix appends the supplied RoutingPolicy_DefinedSets_PrefixSet_Prefix struct to the
// list Prefix of RoutingPolicy_DefinedSets_PrefixSet. If the key value(s) specified in
// the supplied RoutingPolicy_DefinedSets_PrefixSet_Prefix already exist in the list, an error is
// returned.
func (t *RoutingPolicy_DefinedSets_PrefixSet) AppendPrefix(v *RoutingPolicy_DefinedSets_PrefixSet_Prefix) error {
	key := RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key{IpPrefix: *v.IpPrefix, MasklengthRange: *v.MasklengthRange}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[RoutingPolicy_DefinedSets_PrefixSet_Prefix_Key]*RoutingPolicy_DefinedSets_PrefixSet_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the RoutingPolicy_DefinedSets_PrefixSet struct, which is a YANG list entry.
func (t *RoutingPolicy_DefinedSets_PrefixSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_DefinedSets_PrefixSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_DefinedSets_PrefixSet"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_DefinedSets_PrefixSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the RoutingPolicy_DefinedSets_PrefixSet_Prefix struct, which is a YANG list entry.
func (t *RoutingPolicy_DefinedSets_PrefixSet_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.MasklengthRange == nil {
		return nil, fmt.Errorf("nil value for key MasklengthRange")
	}

	return map[string]interface{}{
		"ip-prefix":        *t.IpPrefix,
		"masklength-range": *t.MasklengthRange,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_DefinedSets_PrefixSet_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_DefinedSets_PrefixSet_Prefix"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_DefinedSets_PrefixSet_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the RoutingPolicy_DefinedSets_TagSet struct, which is a YANG list entry.
func (t *RoutingPolicy_DefinedSets_TagSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_DefinedSets_TagSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_DefinedSets_TagSet"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_DefinedSets_TagSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewStatement creates a new entry in the Statement list of the
// RoutingPolicy_PolicyDefinition struct. The keys of the list are populated from the input
// arguments.
func (t *RoutingPolicy_PolicyDefinition) NewStatement(Name string) (*RoutingPolicy_PolicyDefinition_Statement, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Statement == nil {
		t.Statement = make(map[string]*RoutingPolicy_PolicyDefinition_Statement)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Statement[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Statement", key)
	}

	t.Statement[key] = &RoutingPolicy_PolicyDefinition_Statement{
		Name: &Name,
	}

	return t.Statement[key], nil
}

// RenameStatement renames an entry in the list Statement within
// the RoutingPolicy_PolicyDefinition struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *RoutingPolicy_PolicyDefinition) RenameStatement(oldK, newK string) error {
	if _, ok := t.Statement[newK]; ok {
		return fmt.Errorf("key %v already exists in Statement", newK)
	}

	e, ok := t.Statement[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Statement", oldK)
	}
	e.Name = &newK

	t.Statement[newK] = e
	delete(t.Statement, oldK)
	return nil
}

// GetOrCreateStatement retrieves the value with the specified keys from
// the receiver RoutingPolicy_PolicyDefinition. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *RoutingPolicy_PolicyDefinition) GetOrCreateStatement(Name string) *RoutingPolicy_PolicyDefinition_Statement {

	key := Name

	if v, ok := t.Statement[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStatement(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStatement got unexpected error: %v", err))
	}
	return v
}

// GetStatement retrieves the value with the specified key from
// the Statement map field of RoutingPolicy_PolicyDefinition. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *RoutingPolicy_PolicyDefinition) GetStatement(Name string) *RoutingPolicy_PolicyDefinition_Statement {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Statement[key]; ok {
		return lm
	}
	return nil
}

// AppendStatement appends the supplied RoutingPolicy_PolicyDefinition_Statement struct to the
// list Statement of RoutingPolicy_PolicyDefinition. If the key value(s) specified in
// the supplied RoutingPolicy_PolicyDefinition_Statement already exist in the list, an error is
// returned.
func (t *RoutingPolicy_PolicyDefinition) AppendStatement(v *RoutingPolicy_PolicyDefinition_Statement) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Statement == nil {
		t.Statement = make(map[string]*RoutingPolicy_PolicyDefinition_Statement)
	}

	if _, ok := t.Statement[key]; ok {
		return fmt.Errorf("duplicate key for list Statement %v", key)
	}

	t.Statement[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the RoutingPolicy_PolicyDefinition struct, which is a YANG list entry.
func (t *RoutingPolicy_PolicyDefinition) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_PolicyDefinition) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateActions retrieves the value of the Actions field
// or returns the existing field if it already exists.
func (s *RoutingPolicy_PolicyDefinition_Statement) GetOrCreateActions() *RoutingPolicy_PolicyDefinition_Statement_Actions {
	if s.Actions != nil {
		return s.Actions
	}
	s.Actions = &RoutingPolicy_PolicyDefinition_Statement_Actions{}
	return s.Actions
}

// GetOrCreateConditions retrieves the value of the Conditions field
// or returns the existing field if it already exists.
func (s *RoutingPolicy_PolicyDefinition_Statement) GetOrCreateConditions() *RoutingPolicy_PolicyDefinition_Statement_Conditions {
	if s.Conditions != nil {
		return s.Conditions
	}
	s.Conditions = &RoutingPolicy_PolicyDefinition_Statement_Conditions{}
	return s.Conditions
}

// GetActions returns the value of the Actions struct pointer
// from RoutingPolicy_PolicyDefinition_Statement. If the receiver or the field Actions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *RoutingPolicy_PolicyDefinition_Statement) GetActions() *RoutingPolicy_PolicyDefinition_Statement_Actions {
	if s != nil && s.Actions != nil {
		return s.Actions
	}
	return nil
}

// GetConditions returns the value of the Conditions struct pointer
// from RoutingPolicy_PolicyDefinition_Statement. If the receiver or the field Conditions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *RoutingPolicy_PolicyDefinition_Statement) GetConditions() *RoutingPolicy_PolicyDefinition_Statement_Conditions {
	if s != nil && s.Conditions != nil {
		return s.Conditions
	}
	return nil
}

// ΛListKeyMap returns the keys of the RoutingPolicy_PolicyDefinition_Statement struct, which is a YANG list entry.
func (t *RoutingPolicy_PolicyDefinition_Statement) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_PolicyDefinition_Statement) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_PolicyDefinition_Statement_Actions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Actions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Actions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// GetOrCreateMatchInterface retrieves the value of the MatchInterface field
// or returns the existing field if it already exists.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetOrCreateMatchInterface() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface {
	if s.MatchInterface != nil {
		return s.MatchInterface
	}
	s.MatchInterface = &RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface{}
	return s.MatchInterface
}

// GetOrCreateMatchNeighborSet retrieves the value of the MatchNeighborSet field
// or returns the existing field if it already exists.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetOrCreateMatchNeighborSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet {
	if s.MatchNeighborSet != nil {
		return s.MatchNeighborSet
	}
	s.MatchNeighborSet = &RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet{}
	return s.MatchNeighborSet
}

// GetOrCreateMatchPrefixSet retrieves the value of the MatchPrefixSet field
// or returns the existing field if it already exists.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetOrCreateMatchPrefixSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet {
	if s.MatchPrefixSet != nil {
		return s.MatchPrefixSet
	}
	s.MatchPrefixSet = &RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet{}
	return s.MatchPrefixSet
}

// GetOrCreateMatchTagSet retrieves the value of the MatchTagSet field
// or returns the existing field if it already exists.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetOrCreateMatchTagSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet {
	if s.MatchTagSet != nil {
		return s.MatchTagSet
	}
	s.MatchTagSet = &RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet{}
	return s.MatchTagSet
}

// GetMatchInterface returns the value of the MatchInterface struct pointer
// from RoutingPolicy_PolicyDefinition_Statement_Conditions. If the receiver or the field MatchInterface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetMatchInterface() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface {
	if s != nil && s.MatchInterface != nil {
		return s.MatchInterface
	}
	return nil
}

// GetMatchNeighborSet returns the value of the MatchNeighborSet struct pointer
// from RoutingPolicy_PolicyDefinition_Statement_Conditions. If the receiver or the field MatchNeighborSet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetMatchNeighborSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet {
	if s != nil && s.MatchNeighborSet != nil {
		return s.MatchNeighborSet
	}
	return nil
}

// GetMatchPrefixSet returns the value of the MatchPrefixSet struct pointer
// from RoutingPolicy_PolicyDefinition_Statement_Conditions. If the receiver or the field MatchPrefixSet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetMatchPrefixSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet {
	if s != nil && s.MatchPrefixSet != nil {
		return s.MatchPrefixSet
	}
	return nil
}

// GetMatchTagSet returns the value of the MatchTagSet struct pointer
// from RoutingPolicy_PolicyDefinition_Statement_Conditions. If the receiver or the field MatchTagSet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions) GetMatchTagSet() *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet {
	if s != nil && s.MatchTagSet != nil {
		return s.MatchTagSet
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Conditions"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchNeighborSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchPrefixSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *RoutingPolicy_PolicyDefinition_Statement_Conditions_MatchTagSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// Stp struct. The keys of the list are populated from the input
// arguments.
func (t *Stp) NewInterface(Name string) (*Stp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Stp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Stp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Stp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp) GetOrCreateInterface(Name string) *Stp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Stp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp) GetInterface(Name string) *Stp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Stp_Interface struct to the
// list Interface of Stp. If the key value(s) specified in
// the supplied Stp_Interface already exist in the list, an error is
// returned.
func (t *Stp) AppendInterface(v *Stp_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewVlan creates a new entry in the Vlan list of the
// Stp struct. The keys of the list are populated from the input
// arguments.
func (t *Stp) NewVlan(VlanId uint16) (*Stp_Vlan, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*Stp_Vlan)
	}

	key := VlanId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vlan[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vlan", key)
	}

	t.Vlan[key] = &Stp_Vlan{
		VlanId: &VlanId,
	}

	return t.Vlan[key], nil
}

// RenameVlan renames an entry in the list Vlan within
// the Stp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp) RenameVlan(oldK, newK uint16) error {
	if _, ok := t.Vlan[newK]; ok {
		return fmt.Errorf("key %v already exists in Vlan", newK)
	}

	e, ok := t.Vlan[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vlan", oldK)
	}
	e.VlanId = &newK

	t.Vlan[newK] = e
	delete(t.Vlan, oldK)
	return nil
}

// GetOrCreateVlan retrieves the value with the specified keys from
// the receiver Stp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp) GetOrCreateVlan(VlanId uint16) *Stp_Vlan {

	key := VlanId

	if v, ok := t.Vlan[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVlan(VlanId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVlan got unexpected error: %v", err))
	}
	return v
}

// GetVlan retrieves the value with the specified key from
// the Vlan map field of Stp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp) GetVlan(VlanId uint16) *Stp_Vlan {

	if t == nil {
		return nil
	}

	key := VlanId

	if lm, ok := t.Vlan[key]; ok {
		return lm
	}
	return nil
}

// AppendVlan appends the supplied Stp_Vlan struct to the
// list Vlan of Stp. If the key value(s) specified in
// the supplied Stp_Vlan already exist in the list, an error is
// returned.
func (t *Stp) AppendVlan(v *Stp_Vlan) error {
	key := *v.VlanId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*Stp_Vlan)
	}

	if _, ok := t.Vlan[key]; ok {
		return fmt.Errorf("duplicate key for list Vlan %v", key)
	}

	t.Vlan[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (s *Stp) GetOrCreateGlobal() *Stp_Global {
	if s.Global != nil {
		return s.Global
	}
	s.Global = &Stp_Global{}
	return s.Global
}

// GetOrCreateMstp retrieves the value of the Mstp field
// or returns the existing field if it already exists.
func (s *Stp) GetOrCreateMstp() *Stp_Mstp {
	if s.Mstp != nil {
		return s.Mstp
	}
	s.Mstp = &Stp_Mstp{}
	return s.Mstp
}

// GetOrCreateRstp retrieves the value of the Rstp field
// or returns the existing field if it already exists.
func (s *Stp) GetOrCreateRstp() *Stp_Rstp {
	if s.Rstp != nil {
		return s.Rstp
	}
	s.Rstp = &Stp_Rstp{}
	return s.Rstp
}

// GetGlobal returns the value of the Global struct pointer
// from Stp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Stp) GetGlobal() *Stp_Global {
	if s != nil && s.Global != nil {
		return s.Global
	}
	return nil
}

// GetMstp returns the value of the Mstp struct pointer
// from Stp. If the receiver or the field Mstp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Stp) GetMstp() *Stp_Mstp {
	if s != nil && s.Mstp != nil {
		return s.Mstp
	}
	return nil
}

// GetRstp returns the value of the Rstp struct pointer
// from Stp. If the receiver or the field Rstp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Stp) GetRstp() *Stp_Rstp {
	if s != nil && s.Rstp != nil {
		return s.Rstp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Global"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the Stp_Interface struct, which is a YANG list entry.
func (t *Stp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewMstInstance creates a new entry in the MstInstance list of the
// Stp_Mstp struct. The keys of the list are populated from the input
// arguments.
func (t *Stp_Mstp) NewMstInstance(MstId uint16) (*Stp_Mstp_MstInstance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MstInstance == nil {
		t.MstInstance = make(map[uint16]*Stp_Mstp_MstInstance)
	}

	key := MstId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MstInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MstInstance", key)
	}

	t.MstInstance[key] = &Stp_Mstp_MstInstance{
		MstId: &MstId,
	}

	return t.MstInstance[key], nil
}

// RenameMstInstance renames an entry in the list MstInstance within
// the Stp_Mstp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp_Mstp) RenameMstInstance(oldK, newK uint16) error {
	if _, ok := t.MstInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in MstInstance", newK)
	}

	e, ok := t.MstInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MstInstance", oldK)
	}
	e.MstId = &newK

	t.MstInstance[newK] = e
	delete(t.MstInstance, oldK)
	return nil
}

// GetOrCreateMstInstance retrieves the value with the specified keys from
// the receiver Stp_Mstp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp_Mstp) GetOrCreateMstInstance(MstId uint16) *Stp_Mstp_MstInstance {

	key := MstId

	if v, ok := t.MstInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMstInstance(MstId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMstInstance got unexpected error: %v", err))
	}
	return v
}

// GetMstInstance retrieves the value with the specified key from
// the MstInstance map field of Stp_Mstp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp_Mstp) GetMstInstance(MstId uint16) *Stp_Mstp_MstInstance {

	if t == nil {
		return nil
	}

	key := MstId

	if lm, ok := t.MstInstance[key]; ok {
		return lm
	}
	return nil
}

// AppendMstInstance appends the supplied Stp_Mstp_MstInstance struct to the
// list MstInstance of Stp_Mstp. If the key value(s) specified in
// the supplied Stp_Mstp_MstInstance already exist in the list, an error is
// returned.
func (t *Stp_Mstp) AppendMstInstance(v *Stp_Mstp_MstInstance) error {
	key := *v.MstId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MstInstance == nil {
		t.MstInstance = make(map[uint16]*Stp_Mstp_MstInstance)
	}

	if _, ok := t.MstInstance[key]; ok {
		return fmt.Errorf("duplicate key for list MstInstance %v", key)
	}

	t.MstInstance[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Mstp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Mstp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Mstp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// Stp_Mstp_MstInstance struct. The keys of the list are populated from the input
// arguments.
func (t *Stp_Mstp_MstInstance) NewInterface(Name string) (*Stp_Mstp_MstInstance_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Mstp_MstInstance_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Stp_Mstp_MstInstance_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Stp_Mstp_MstInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp_Mstp_MstInstance) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Stp_Mstp_MstInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp_Mstp_MstInstance) GetOrCreateInterface(Name string) *Stp_Mstp_MstInstance_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Stp_Mstp_MstInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp_Mstp_MstInstance) GetInterface(Name string) *Stp_Mstp_MstInstance_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Stp_Mstp_MstInstance_Interface struct to the
// list Interface of Stp_Mstp_MstInstance. If the key value(s) specified in
// the supplied Stp_Mstp_MstInstance_Interface already exist in the list, an error is
// returned.
func (t *Stp_Mstp_MstInstance) AppendInterface(v *Stp_Mstp_MstInstance_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Mstp_MstInstance_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Stp_Mstp_MstInstance struct, which is a YANG list entry.
func (t *Stp_Mstp_MstInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MstId == nil {
		return nil, fmt.Errorf("nil value for key MstId")
	}

	return map[string]interface{}{
		"mst-id": *t.MstId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Mstp_MstInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Mstp_MstInstance"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Mstp_MstInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Stp_Mstp_MstInstance_Interface) GetOrCreateCounters() *Stp_Mstp_MstInstance_Interface_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Stp_Mstp_MstInstance_Interface_Counters{}
	return s.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Stp_Mstp_MstInstance_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Stp_Mstp_MstInstance_Interface) GetCounters() *Stp_Mstp_MstInstance_Interface_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Stp_Mstp_MstInstance_Interface struct, which is a YANG list entry.
func (t *Stp_Mstp_MstInstance_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Mstp_MstInstance_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Mstp_MstInstance_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Mstp_MstInstance_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Mstp_MstInstance_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Mstp_MstInstance_Interface_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Mstp_MstInstance_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewInterface creates a new entry in the Interface list of the
// Stp_Rstp struct. The keys of the list are populated from the input
// arguments.
func (t *Stp_Rstp) NewInterface(Name string) (*Stp_Rstp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Rstp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Stp_Rstp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Stp_Rstp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp_Rstp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Stp_Rstp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp_Rstp) GetOrCreateInterface(Name string) *Stp_Rstp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Stp_Rstp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp_Rstp) GetInterface(Name string) *Stp_Rstp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Stp_Rstp_Interface struct to the
// list Interface of Stp_Rstp. If the key value(s) specified in
// the supplied Stp_Rstp_Interface already exist in the list, an error is
// returned.
func (t *Stp_Rstp) AppendInterface(v *Stp_Rstp_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Rstp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Rstp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Rstp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Rstp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Stp_Rstp_Interface) GetOrCreateCounters() *Stp_Rstp_Interface_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Stp_Rstp_Interface_Counters{}
	return s.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Stp_Rstp_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Stp_Rstp_Interface) GetCounters() *Stp_Rstp_Interface_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Stp_Rstp_Interface struct, which is a YANG list entry.
func (t *Stp_Rstp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Rstp_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Rstp_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Rstp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Rstp_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Rstp_Interface_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Rstp_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewInterface creates a new entry in the Interface list of the
// Stp_Vlan struct. The keys of the list are populated from the input
// arguments.
func (t *Stp_Vlan) NewInterface(Name string) (*Stp_Vlan_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Vlan_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Stp_Vlan_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Stp_Vlan struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Stp_Vlan) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Stp_Vlan. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Stp_Vlan) GetOrCreateInterface(Name string) *Stp_Vlan_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Stp_Vlan. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Stp_Vlan) GetInterface(Name string) *Stp_Vlan_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Stp_Vlan_Interface struct to the
// list Interface of Stp_Vlan. If the key value(s) specified in
// the supplied Stp_Vlan_Interface already exist in the list, an error is
// returned.
func (t *Stp_Vlan) AppendInterface(v *Stp_Vlan_Interface) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Stp_Vlan_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the Stp_Vlan struct, which is a YANG list entry.
func (t *Stp_Vlan) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VlanId == nil {
		return nil, fmt.Errorf("nil value for key VlanId")
	}

	return map[string]interface{}{
		"vlan-id": *t.VlanId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Vlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Vlan"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Vlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *Stp_Vlan_Interface) GetOrCreateCounters() *Stp_Vlan_Interface_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &Stp_Vlan_Interface_Counters{}
	return s.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Stp_Vlan_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *Stp_Vlan_Interface) GetCounters() *Stp_Vlan_Interface_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Stp_Vlan_Interface struct, which is a YANG list entry.
func (t *Stp_Vlan_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Vlan_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Vlan_Interface"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Vlan_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *Stp_Vlan_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Stp_Vlan_Interface_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Stp_Vlan_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAlarm creates a new entry in the Alarm list of the
// System struct. The keys of the list are populated from the input
// arguments.
func (t *System) NewAlarm(Id string) (*System_Alarm, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Alarm == nil {
		t.Alarm = make(map[string]*System_Alarm)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Alarm[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Alarm", key)
	}

	t.Alarm[key] = &System_Alarm{
		Id: &Id,
	}

	return t.Alarm[key], nil
}

// RenameAlarm renames an entry in the list Alarm within
// the System struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System) RenameAlarm(oldK, newK string) error {
	if _, ok := t.Alarm[newK]; ok {
		return fmt.Errorf("key %v already exists in Alarm", newK)
	}

	e, ok := t.Alarm[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Alarm", oldK)
	}
	e.Id = &newK

	t.Alarm[newK] = e
	delete(t.Alarm, oldK)
	return nil
}

// GetOrCreateAlarm retrieves the value with the specified keys from
// the receiver System. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System) GetOrCreateAlarm(Id string) *System_Alarm {

	key := Id

	if v, ok := t.Alarm[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAlarm(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAlarm got unexpected error: %v", err))
	}
	return v
}

// GetAlarm retrieves the value with the specified key from
// the Alarm map field of System. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System) GetAlarm(Id string) *System_Alarm {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Alarm[key]; ok {
		return lm
	}
	return nil
}

// AppendAlarm appends the supplied System_Alarm struct to the
// list Alarm of System. If the key value(s) specified in
// the supplied System_Alarm already exist in the list, an error is
// returned.
func (t *System) AppendAlarm(v *System_Alarm) error {
	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Alarm == nil {
		t.Alarm = make(map[string]*System_Alarm)
	}

	if _, ok := t.Alarm[key]; ok {
		return fmt.Errorf("duplicate key for list Alarm %v", key)
	}

	t.Alarm[key] = v
	return nil
}

// NewCpu creates a new entry in the Cpu list of the
// System struct. The keys of the list are populated from the input
// arguments.
func (t *System) NewCpu(Index System_Cpu_Index_Union) (*System_Cpu, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Cpu == nil {
		t.Cpu = make(map[System_Cpu_Index_Union]*System_Cpu)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Cpu[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Cpu", key)
	}

	t.Cpu[key] = &System_Cpu{
		Index: Index,
	}

	return t.Cpu[key], nil
}

// RenameCpu renames an entry in the list Cpu within
// the System struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System) RenameCpu(oldK, newK System_Cpu_Index_Union) error {
	if _, ok := t.Cpu[newK]; ok {
		return fmt.Errorf("key %v already exists in Cpu", newK)
	}

	e, ok := t.Cpu[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Cpu", oldK)
	}
	e.Index = newK

	t.Cpu[newK] = e
	delete(t.Cpu, oldK)
	return nil
}

// GetOrCreateCpu retrieves the value with the specified keys from
// the receiver System. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System) GetOrCreateCpu(Index System_Cpu_Index_Union) *System_Cpu {

	key := Index

	if v, ok := t.Cpu[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCpu(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCpu got unexpected error: %v", err))
	}
	return v
}

// GetCpu retrieves the value with the specified key from
// the Cpu map field of System. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System) GetCpu(Index System_Cpu_Index_Union) *System_Cpu {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Cpu[key]; ok {
		return lm
	}
	return nil
}

// AppendCpu appends the supplied System_Cpu struct to the
// list Cpu of System. If the key value(s) specified in
// the supplied System_Cpu already exist in the list, an error is
// returned.
func (t *System) AppendCpu(v *System_Cpu) error {
	key := v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Cpu == nil {
		t.Cpu = make(map[System_Cpu_Index_Union]*System_Cpu)
	}

	if _, ok := t.Cpu[key]; ok {
		return fmt.Errorf("duplicate key for list Cpu %v", key)
	}

	t.Cpu[key] = v
	return nil
}

// NewProcess creates a new entry in the Process list of the
// System struct. The keys of the list are populated from the input
// arguments.
func (t *System) NewProcess(Pid uint64) (*System_Process, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Process == nil {
		t.Process = make(map[uint64]*System_Process)
	}

	key := Pid

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Process[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Process", key)
	}

	t.Process[key] = &System_Process{
		Pid: &Pid,
	}

	return t.Process[key], nil
}

// RenameProcess renames an entry in the list Process within
// the System struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System) RenameProcess(oldK, newK uint64) error {
	if _, ok := t.Process[newK]; ok {
		return fmt.Errorf("key %v already exists in Process", newK)
	}

	e, ok := t.Process[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Process", oldK)
	}
	e.Pid = &newK

	t.Process[newK] = e
	delete(t.Process, oldK)
	return nil
}

// GetOrCreateProcess retrieves the value with the specified keys from
// the receiver System. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System) GetOrCreateProcess(Pid uint64) *System_Process {

	key := Pid

	if v, ok := t.Process[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProcess(Pid)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProcess got unexpected error: %v", err))
	}
	return v
}

// GetProcess retrieves the value with the specified key from
// the Process map field of System. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System) GetProcess(Pid uint64) *System_Process {

	if t == nil {
		return nil
	}

	key := Pid

	if lm, ok := t.Process[key]; ok {
		return lm
	}
	return nil
}

// AppendProcess appends the supplied System_Process struct to the
// list Process of System. If the key value(s) specified in
// the supplied System_Process already exist in the list, an error is
// returned.
func (t *System) AppendProcess(v *System_Process) error {
	key := *v.Pid

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Process == nil {
		t.Process = make(map[uint64]*System_Process)
	}

	if _, ok := t.Process[key]; ok {
		return fmt.Errorf("duplicate key for list Process %v", key)
	}

	t.Process[key] = v
	return nil
}

// GetOrCreateAaa retrieves the value of the Aaa field
// or returns the existing field if it already exists.
func (s *System) GetOrCreateAaa() *System_Aaa {
	if s.Aaa != nil {
		return s.Aaa
	}
	s.Aaa = &System_Aaa{}
	return s.Aaa
}

// GetOrCreateClock retrieves the value of the Clock field
// or returns the existing field if it already exists.
func (s *System) GetOrCreateClock() *System_Clock {
	if s.Clock != nil {
		return s.Clock
	}
	s.Clock = &System_Clock{}
	return s.Clock
}

// GetOrCreateDns retrieves the value of the Dns field
// or returns the existing field if it already exists.
func (s *System) GetOrCreateDns() *System_Dns {
	if s.Dns != nil {
		return s.Dns
	}
	s.Dns = &System_Dns{}
	return s.Dns
}

// GetOrCreateLogging retrieves the value of the Logging field
// or returns the existing field if it already exists.
func (s *System) GetOrCreateLogging() *System_Logging {
	if s.Logging != nil {
		return s.Logging
	}
	s.Logging = &System_Logging{}
	return s.Logging
}

// GetOrCreateMemory retrieves the value of the Memory field
// or returns the existing field if it already exists.
func (s *System) GetOrCreateMemory() *System_Memory {
	if s.Memory != nil {
		return s.Memory
	}
	s.Memory = &System_Memory{}
	return s.Memory
}

// GetOrCreateNtp retrieves the value of the Ntp field
// or returns the existing field if it already exists.
func (s *System) GetOrCreateNtp() *System_Ntp {
	if s.Ntp != nil {
		return s.Ntp
	}
	s.Ntp = &System_Ntp{}
	return s.Ntp
}

// GetOrCreateSshServer retrieves the value of the SshServer field
// or returns the existing field if it already exists.
func (s *System) GetOrCreateSshServer() *System_SshServer {
	if s.SshServer != nil {
		return s.SshServer
	}
	s.SshServer = &System_SshServer{}
	return s.SshServer
}

// GetOrCreateTelnetServer retrieves the value of the TelnetServer field
// or returns the existing field if it already exists.
func (s *System) GetOrCreateTelnetServer() *System_TelnetServer {
	if s.TelnetServer != nil {
		return s.TelnetServer
	}
	s.TelnetServer = &System_TelnetServer{}
	return s.TelnetServer
}

// GetAaa returns the value of the Aaa struct pointer
// from System. If the receiver or the field Aaa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System) GetAaa() *System_Aaa {
	if s != nil && s.Aaa != nil {
		return s.Aaa
	}
	return nil
}

// GetClock returns the value of the Clock struct pointer
// from System. If the receiver or the field Clock is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System) GetClock() *System_Clock {
	if s != nil && s.Clock != nil {
		return s.Clock
	}
	return nil
}

// GetDns returns the value of the Dns struct pointer
// from System. If the receiver or the field Dns is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System) GetDns() *System_Dns {
	if s != nil && s.Dns != nil {
		return s.Dns
	}
	return nil
}

// GetLogging returns the value of the Logging struct pointer
// from System. If the receiver or the field Logging is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System) GetLogging() *System_Logging {
	if s != nil && s.Logging != nil {
		return s.Logging
	}
	return nil
}

// GetMemory returns the value of the Memory struct pointer
// from System. If the receiver or the field Memory is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System) GetMemory() *System_Memory {
	if s != nil && s.Memory != nil {
		return s.Memory
	}
	return nil
}

// GetNtp returns the value of the Ntp struct pointer
// from System. If the receiver or the field Ntp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System) GetNtp() *System_Ntp {
	if s != nil && s.Ntp != nil {
		return s.Ntp
	}
	return nil
}

// GetSshServer returns the value of the SshServer struct pointer
// from System. If the receiver or the field SshServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System) GetSshServer() *System_SshServer {
	if s != nil && s.SshServer != nil {
		return s.SshServer
	}
	return nil
}

// GetTelnetServer returns the value of the TelnetServer struct pointer
// from System. If the receiver or the field TelnetServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System) GetTelnetServer() *System_TelnetServer {
	if s != nil && s.TelnetServer != nil {
		return s.TelnetServer
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewServerGroup creates a new entry in the ServerGroup list of the
// System_Aaa struct. The keys of the list are populated from the input
// arguments.
func (t *System_Aaa) NewServerGroup(Name string) (*System_Aaa_ServerGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerGroup == nil {
		t.ServerGroup = make(map[string]*System_Aaa_ServerGroup)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ServerGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ServerGroup", key)
	}

	t.ServerGroup[key] = &System_Aaa_ServerGroup{
		Name: &Name,
	}

	return t.ServerGroup[key], nil
}

// RenameServerGroup renames an entry in the list ServerGroup within
// the System_Aaa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Aaa) RenameServerGroup(oldK, newK string) error {
	if _, ok := t.ServerGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in ServerGroup", newK)
	}

	e, ok := t.ServerGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ServerGroup", oldK)
	}
	e.Name = &newK

	t.ServerGroup[newK] = e
	delete(t.ServerGroup, oldK)
	return nil
}

// GetOrCreateServerGroup retrieves the value with the specified keys from
// the receiver System_Aaa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Aaa) GetOrCreateServerGroup(Name string) *System_Aaa_ServerGroup {

	key := Name

	if v, ok := t.ServerGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServerGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServerGroup got unexpected error: %v", err))
	}
	return v
}

// GetServerGroup retrieves the value with the specified key from
// the ServerGroup map field of System_Aaa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Aaa) GetServerGroup(Name string) *System_Aaa_ServerGroup {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ServerGroup[key]; ok {
		return lm
	}
	return nil
}

// AppendServerGroup appends the supplied System_Aaa_ServerGroup struct to the
// list ServerGroup of System_Aaa. If the key value(s) specified in
// the supplied System_Aaa_ServerGroup already exist in the list, an error is
// returned.
func (t *System_Aaa) AppendServerGroup(v *System_Aaa_ServerGroup) error {
	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerGroup == nil {
		t.ServerGroup = make(map[string]*System_Aaa_ServerGroup)
	}

	if _, ok := t.ServerGroup[key]; ok {
		return fmt.Errorf("duplicate key for list ServerGroup %v", key)
	}

	t.ServerGroup[key] = v
	return nil
}

// GetOrCreateAccounting retrieves the value of the Accounting field
// or returns the existing field if it already exists.
func (s *System_Aaa) GetOrCreateAccounting() *System_Aaa_Accounting {
	if s.Accounting != nil {
		return s.Accounting
	}
	s.Accounting = &System_Aaa_Accounting{}
	return s.Accounting
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (s *System_Aaa) GetOrCreateAuthentication() *System_Aaa_Authentication {
	if s.Authentication != nil {
		return s.Authentication
	}
	s.Authentication = &System_Aaa_Authentication{}
	return s.Authentication
}

// GetOrCreateAuthorization retrieves the value of the Authorization field
// or returns the existing field if it already exists.
func (s *System_Aaa) GetOrCreateAuthorization() *System_Aaa_Authorization {
	if s.Authorization != nil {
		return s.Authorization
	}
	s.Authorization = &System_Aaa_Authorization{}
	return s.Authorization
}

// GetAccounting returns the value of the Accounting struct pointer
// from System_Aaa. If the receiver or the field Accounting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Aaa) GetAccounting() *System_Aaa_Accounting {
	if s != nil && s.Accounting != nil {
		return s.Accounting
	}
	return nil
}

// GetAuthentication returns the value of the Authentication struct pointer
// from System_Aaa. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Aaa) GetAuthentication() *System_Aaa_Authentication {
	if s != nil && s.Authentication != nil {
		return s.Authentication
	}
	return nil
}

// GetAuthorization returns the value of the Authorization struct pointer
// from System_Aaa. If the receiver or the field Authorization is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Aaa) GetAuthorization() *System_Aaa_Authorization {
	if s != nil && s.Authorization != nil {
		return s.Authorization
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewEvent creates a new entry in the Event list of the
// System_Aaa_Accounting struct. The keys of the list are populated from the input
// arguments.
func (t *System_Aaa_Accounting) NewEvent(EventType E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE) (*System_Aaa_Accounting_Event, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Event == nil {
		t.Event = make(map[E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE]*System_Aaa_Accounting_Event)
	}

	key := EventType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Event[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Event", key)
	}

	t.Event[key] = &System_Aaa_Accounting_Event{
		EventType: EventType,
	}

	return t.Event[key], nil
}

// RenameEvent renames an entry in the list Event within
// the System_Aaa_Accounting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Aaa_Accounting) RenameEvent(oldK, newK E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE) error {
	if _, ok := t.Event[newK]; ok {
		return fmt.Errorf("key %v already exists in Event", newK)
	}

	e, ok := t.Event[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Event", oldK)
	}
	e.EventType = newK

	t.Event[newK] = e
	delete(t.Event, oldK)
	return nil
}

// GetOrCreateEvent retrieves the value with the specified keys from
// the receiver System_Aaa_Accounting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Aaa_Accounting) GetOrCreateEvent(EventType E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE) *System_Aaa_Accounting_Event {

	key := EventType

	if v, ok := t.Event[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEvent(EventType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEvent got unexpected error: %v", err))
	}
	return v
}

// GetEvent retrieves the value with the specified key from
// the Event map field of System_Aaa_Accounting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Aaa_Accounting) GetEvent(EventType E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE) *System_Aaa_Accounting_Event {

	if t == nil {
		return nil
	}

	key := EventType

	if lm, ok := t.Event[key]; ok {
		return lm
	}
	return nil
}

// AppendEvent appends the supplied System_Aaa_Accounting_Event struct to the
// list Event of System_Aaa_Accounting. If the key value(s) specified in
// the supplied System_Aaa_Accounting_Event already exist in the list, an error is
// returned.
func (t *System_Aaa_Accounting) AppendEvent(v *System_Aaa_Accounting_Event) error {
	key := v.EventType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Event == nil {
		t.Event = make(map[E_OpenconfigAaaTypes_AAA_ACCOUNTING_EVENT_TYPE]*System_Aaa_Accounting_Event)
	}

	if _, ok := t.Event[key]; ok {
		return fmt.Errorf("duplicate key for list Event %v", key)
	}

	t.Event[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_Accounting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Accounting"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Accounting) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Aaa_Accounting_Event struct, which is a YANG list entry.
func (t *System_Aaa_Accounting_Event) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event-type": t.EventType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_Accounting_Event) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Accounting_Event"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Accounting_Event) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewUser creates a new entry in the User list of the
// System_Aaa_Authentication struct. The keys of the list are populated from the input
// arguments.
func (t *System_Aaa_Authentication) NewUser(Username string) (*System_Aaa_Authentication_User, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*System_Aaa_Authentication_User)
	}

	key := Username

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.User[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list User", key)
	}

	t.User[key] = &System_Aaa_Authentication_User{
		Username: &Username,
	}

	return t.User[key], nil
}

// RenameUser renames an entry in the list User within
// the System_Aaa_Authentication struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Aaa_Authentication) RenameUser(oldK, newK string) error {
	if _, ok := t.User[newK]; ok {
		return fmt.Errorf("key %v already exists in User", newK)
	}

	e, ok := t.User[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in User", oldK)
	}
	e.Username = &newK

	t.User[newK] = e
	delete(t.User, oldK)
	return nil
}

// GetOrCreateUser retrieves the value with the specified keys from
// the receiver System_Aaa_Authentication. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Aaa_Authentication) GetOrCreateUser(Username string) *System_Aaa_Authentication_User {

	key := Username

	if v, ok := t.User[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUser(Username)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUser got unexpected error: %v", err))
	}
	return v
}

// GetUser retrieves the value with the specified key from
// the User map field of System_Aaa_Authentication. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Aaa_Authentication) GetUser(Username string) *System_Aaa_Authentication_User {

	if t == nil {
		return nil
	}

	key := Username

	if lm, ok := t.User[key]; ok {
		return lm
	}
	return nil
}

// AppendUser appends the supplied System_Aaa_Authentication_User struct to the
// list User of System_Aaa_Authentication. If the key value(s) specified in
// the supplied System_Aaa_Authentication_User already exist in the list, an error is
// returned.
func (t *System_Aaa_Authentication) AppendUser(v *System_Aaa_Authentication_User) error {
	key := *v.Username

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*System_Aaa_Authentication_User)
	}

	if _, ok := t.User[key]; ok {
		return fmt.Errorf("duplicate key for list User %v", key)
	}

	t.User[key] = v
	return nil
}

// GetOrCreateAdminUser retrieves the value of the AdminUser field
// or returns the existing field if it already exists.
func (s *System_Aaa_Authentication) GetOrCreateAdminUser() *System_Aaa_Authentication_AdminUser {
	if s.AdminUser != nil {
		return s.AdminUser
	}
	s.AdminUser = &System_Aaa_Authentication_AdminUser{}
	return s.AdminUser
}

// GetAdminUser returns the value of the AdminUser struct pointer
// from System_Aaa_Authentication. If the receiver or the field AdminUser is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Aaa_Authentication) GetAdminUser() *System_Aaa_Authentication_AdminUser {
	if s != nil && s.AdminUser != nil {
		return s.AdminUser
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Authentication"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Authentication) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_Authentication_AdminUser) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Authentication_AdminUser"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Authentication_AdminUser) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the System_Aaa_Authentication_User struct, which is a YANG list entry.
func (t *System_Aaa_Authentication_User) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Username == nil {
		return nil, fmt.Errorf("nil value for key Username")
	}

	return map[string]interface{}{
		"username": *t.Username,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_Authentication_User) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Authentication_User"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Authentication_User) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewEvent creates a new entry in the Event list of the
// System_Aaa_Authorization struct. The keys of the list are populated from the input
// arguments.
func (t *System_Aaa_Authorization) NewEvent(EventType E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE) (*System_Aaa_Authorization_Event, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Event == nil {
		t.Event = make(map[E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE]*System_Aaa_Authorization_Event)
	}

	key := EventType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Event[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Event", key)
	}

	t.Event[key] = &System_Aaa_Authorization_Event{
		EventType: EventType,
	}

	return t.Event[key], nil
}

// RenameEvent renames an entry in the list Event within
// the System_Aaa_Authorization struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Aaa_Authorization) RenameEvent(oldK, newK E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE) error {
	if _, ok := t.Event[newK]; ok {
		return fmt.Errorf("key %v already exists in Event", newK)
	}

	e, ok := t.Event[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Event", oldK)
	}
	e.EventType = newK

	t.Event[newK] = e
	delete(t.Event, oldK)
	return nil
}

// GetOrCreateEvent retrieves the value with the specified keys from
// the receiver System_Aaa_Authorization. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Aaa_Authorization) GetOrCreateEvent(EventType E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE) *System_Aaa_Authorization_Event {

	key := EventType

	if v, ok := t.Event[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEvent(EventType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEvent got unexpected error: %v", err))
	}
	return v
}

// GetEvent retrieves the value with the specified key from
// the Event map field of System_Aaa_Authorization. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Aaa_Authorization) GetEvent(EventType E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE) *System_Aaa_Authorization_Event {

	if t == nil {
		return nil
	}

	key := EventType

	if lm, ok := t.Event[key]; ok {
		return lm
	}
	return nil
}

// AppendEvent appends the supplied System_Aaa_Authorization_Event struct to the
// list Event of System_Aaa_Authorization. If the key value(s) specified in
// the supplied System_Aaa_Authorization_Event already exist in the list, an error is
// returned.
func (t *System_Aaa_Authorization) AppendEvent(v *System_Aaa_Authorization_Event) error {
	key := v.EventType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Event == nil {
		t.Event = make(map[E_OpenconfigAaaTypes_AAA_AUTHORIZATION_EVENT_TYPE]*System_Aaa_Authorization_Event)
	}

	if _, ok := t.Event[key]; ok {
		return fmt.Errorf("duplicate key for list Event %v", key)
	}

	t.Event[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_Authorization) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Authorization"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Authorization) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Aaa_Authorization_Event struct, which is a YANG list entry.
func (t *System_Aaa_Authorization_Event) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event-type": t.EventType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_Authorization_Event) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_Authorization_Event"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_Authorization_Event) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewServer creates a new entry in the Server list of the
// System_Aaa_ServerGroup struct. The keys of the list are populated from the input
// arguments.
func (t *System_Aaa_ServerGroup) NewServer(Address string) (*System_Aaa_ServerGroup_Server, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Aaa_ServerGroup_Server)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &System_Aaa_ServerGroup_Server{
		Address: &Address,
	}

	return t.Server[key], nil
}

// RenameServer renames an entry in the list Server within
// the System_Aaa_ServerGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Aaa_ServerGroup) RenameServer(oldK, newK string) error {
	if _, ok := t.Server[newK]; ok {
		return fmt.Errorf("key %v already exists in Server", newK)
	}

	e, ok := t.Server[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Server", oldK)
	}
	e.Address = &newK

	t.Server[newK] = e
	delete(t.Server, oldK)
	return nil
}

// GetOrCreateServer retrieves the value with the specified keys from
// the receiver System_Aaa_ServerGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Aaa_ServerGroup) GetOrCreateServer(Address string) *System_Aaa_ServerGroup_Server {

	key := Address

	if v, ok := t.Server[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServer(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServer got unexpected error: %v", err))
	}
	return v
}

// GetServer retrieves the value with the specified key from
// the Server map field of System_Aaa_ServerGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Aaa_ServerGroup) GetServer(Address string) *System_Aaa_ServerGroup_Server {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Server[key]; ok {
		return lm
	}
	return nil
}

// AppendServer appends the supplied System_Aaa_ServerGroup_Server struct to the
// list Server of System_Aaa_ServerGroup. If the key value(s) specified in
// the supplied System_Aaa_ServerGroup_Server already exist in the list, an error is
// returned.
func (t *System_Aaa_ServerGroup) AppendServer(v *System_Aaa_ServerGroup_Server) error {
	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Aaa_ServerGroup_Server)
	}

	if _, ok := t.Server[key]; ok {
		return fmt.Errorf("duplicate key for list Server %v", key)
	}

	t.Server[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the System_Aaa_ServerGroup struct, which is a YANG list entry.
func (t *System_Aaa_ServerGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_ServerGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_ServerGroup"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_ServerGroup) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateRadius retrieves the value of the Radius field
// or returns the existing field if it already exists.
func (s *System_Aaa_ServerGroup_Server) GetOrCreateRadius() *System_Aaa_ServerGroup_Server_Radius {
	if s.Radius != nil {
		return s.Radius
	}
	s.Radius = &System_Aaa_ServerGroup_Server_Radius{}
	return s.Radius
}

// GetOrCreateTacacs retrieves the value of the Tacacs field
// or returns the existing field if it already exists.
func (s *System_Aaa_ServerGroup_Server) GetOrCreateTacacs() *System_Aaa_ServerGroup_Server_Tacacs {
	if s.Tacacs != nil {
		return s.Tacacs
	}
	s.Tacacs = &System_Aaa_ServerGroup_Server_Tacacs{}
	return s.Tacacs
}

// GetRadius returns the value of the Radius struct pointer
// from System_Aaa_ServerGroup_Server. If the receiver or the field Radius is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Aaa_ServerGroup_Server) GetRadius() *System_Aaa_ServerGroup_Server_Radius {
	if s != nil && s.Radius != nil {
		return s.Radius
	}
	return nil
}

// GetTacacs returns the value of the Tacacs struct pointer
// from System_Aaa_ServerGroup_Server. If the receiver or the field Tacacs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Aaa_ServerGroup_Server) GetTacacs() *System_Aaa_ServerGroup_Server_Tacacs {
	if s != nil && s.Tacacs != nil {
		return s.Tacacs
	}
	return nil
}

// ΛListKeyMap returns the keys of the System_Aaa_ServerGroup_Server struct, which is a YANG list entry.
func (t *System_Aaa_ServerGroup_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_ServerGroup_Server) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_ServerGroup_Server"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_ServerGroup_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (s *System_Aaa_ServerGroup_Server_Radius) GetOrCreateCounters() *System_Aaa_ServerGroup_Server_Radius_Counters {
	if s.Counters != nil {
		return s.Counters
	}
	s.Counters = &System_Aaa_ServerGroup_Server_Radius_Counters{}
	return s.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from System_Aaa_ServerGroup_Server_Radius. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Aaa_ServerGroup_Server_Radius) GetCounters() *System_Aaa_ServerGroup_Server_Radius_Counters {
	if s != nil && s.Counters != nil {
		return s.Counters
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_ServerGroup_Server_Radius) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_ServerGroup_Server_Radius"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_ServerGroup_Server_Radius) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_ServerGroup_Server_Radius_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_ServerGroup_Server_Radius_Counters"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_ServerGroup_Server_Radius_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Aaa_ServerGroup_Server_Tacacs) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Aaa_ServerGroup_Server_Tacacs"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Aaa_ServerGroup_Server_Tacacs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the System_Alarm struct, which is a YANG list entry.
func (t *System_Alarm) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Alarm) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Alarm"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Alarm) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Clock) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Clock"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Clock) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateHardwareInterrupt retrieves the value of the HardwareInterrupt field
// or returns the existing field if it already exists.
func (s *System_Cpu) GetOrCreateHardwareInterrupt() *System_Cpu_HardwareInterrupt {
	if s.HardwareInterrupt != nil {
		return s.HardwareInterrupt
	}
	s.HardwareInterrupt = &System_Cpu_HardwareInterrupt{}
	return s.HardwareInterrupt
}

// GetOrCreateIdle retrieves the value of the Idle field
// or returns the existing field if it already exists.
func (s *System_Cpu) GetOrCreateIdle() *System_Cpu_Idle {
	if s.Idle != nil {
		return s.Idle
	}
	s.Idle = &System_Cpu_Idle{}
	return s.Idle
}

// GetOrCreateKernel retrieves the value of the Kernel field
// or returns the existing field if it already exists.
func (s *System_Cpu) GetOrCreateKernel() *System_Cpu_Kernel {
	if s.Kernel != nil {
		return s.Kernel
	}
	s.Kernel = &System_Cpu_Kernel{}
	return s.Kernel
}

// GetOrCreateNice retrieves the value of the Nice field
// or returns the existing field if it already exists.
func (s *System_Cpu) GetOrCreateNice() *System_Cpu_Nice {
	if s.Nice != nil {
		return s.Nice
	}
	s.Nice = &System_Cpu_Nice{}
	return s.Nice
}

// GetOrCreateSoftwareInterrupt retrieves the value of the SoftwareInterrupt field
// or returns the existing field if it already exists.
func (s *System_Cpu) GetOrCreateSoftwareInterrupt() *System_Cpu_SoftwareInterrupt {
	if s.SoftwareInterrupt != nil {
		return s.SoftwareInterrupt
	}
	s.SoftwareInterrupt = &System_Cpu_SoftwareInterrupt{}
	return s.SoftwareInterrupt
}

// GetOrCreateTotal retrieves the value of the Total field
// or returns the existing field if it already exists.
func (s *System_Cpu) GetOrCreateTotal() *System_Cpu_Total {
	if s.Total != nil {
		return s.Total
	}
	s.Total = &System_Cpu_Total{}
	return s.Total
}

// GetOrCreateUser retrieves the value of the User field
// or returns the existing field if it already exists.
func (s *System_Cpu) GetOrCreateUser() *System_Cpu_User {
	if s.User != nil {
		return s.User
	}
	s.User = &System_Cpu_User{}
	return s.User
}

// GetOrCreateWait retrieves the value of the Wait field
// or returns the existing field if it already exists.
func (s *System_Cpu) GetOrCreateWait() *System_Cpu_Wait {
	if s.Wait != nil {
		return s.Wait
	}
	s.Wait = &System_Cpu_Wait{}
	return s.Wait
}

// GetHardwareInterrupt returns the value of the HardwareInterrupt struct pointer
// from System_Cpu. If the receiver or the field HardwareInterrupt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Cpu) GetHardwareInterrupt() *System_Cpu_HardwareInterrupt {
	if s != nil && s.HardwareInterrupt != nil {
		return s.HardwareInterrupt
	}
	return nil
}

// GetIdle returns the value of the Idle struct pointer
// from System_Cpu. If the receiver or the field Idle is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Cpu) GetIdle() *System_Cpu_Idle {
	if s != nil && s.Idle != nil {
		return s.Idle
	}
	return nil
}

// GetKernel returns the value of the Kernel struct pointer
// from System_Cpu. If the receiver or the field Kernel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Cpu) GetKernel() *System_Cpu_Kernel {
	if s != nil && s.Kernel != nil {
		return s.Kernel
	}
	return nil
}

// GetNice returns the value of the Nice struct pointer
// from System_Cpu. If the receiver or the field Nice is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Cpu) GetNice() *System_Cpu_Nice {
	if s != nil && s.Nice != nil {
		return s.Nice
	}
	return nil
}

// GetSoftwareInterrupt returns the value of the SoftwareInterrupt struct pointer
// from System_Cpu. If the receiver or the field SoftwareInterrupt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Cpu) GetSoftwareInterrupt() *System_Cpu_SoftwareInterrupt {
	if s != nil && s.SoftwareInterrupt != nil {
		return s.SoftwareInterrupt
	}
	return nil
}

// GetTotal returns the value of the Total struct pointer
// from System_Cpu. If the receiver or the field Total is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Cpu) GetTotal() *System_Cpu_Total {
	if s != nil && s.Total != nil {
		return s.Total
	}
	return nil
}

// GetUser returns the value of the User struct pointer
// from System_Cpu. If the receiver or the field User is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Cpu) GetUser() *System_Cpu_User {
	if s != nil && s.User != nil {
		return s.User
	}
	return nil
}

// GetWait returns the value of the Wait struct pointer
// from System_Cpu. If the receiver or the field Wait is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Cpu) GetWait() *System_Cpu_Wait {
	if s != nil && s.Wait != nil {
		return s.Wait
	}
	return nil
}

// ΛListKeyMap returns the keys of the System_Cpu struct, which is a YANG list entry.
func (t *System_Cpu) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"index": t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Cpu) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Cpu_HardwareInterrupt) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_HardwareInterrupt"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_HardwareInterrupt) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Cpu_Idle) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_Idle"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_Idle) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Cpu_Kernel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_Kernel"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_Kernel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Cpu_Nice) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_Nice"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_Nice) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Cpu_SoftwareInterrupt) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_SoftwareInterrupt"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_SoftwareInterrupt) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Cpu_Total) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_Total"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_Total) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Cpu_User) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_User"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_User) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Cpu_Wait) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Cpu_Wait"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Cpu_Wait) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewHostEntry creates a new entry in the HostEntry list of the
// System_Dns struct. The keys of the list are populated from the input
// arguments.
func (t *System_Dns) NewHostEntry(Hostname string) (*System_Dns_HostEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HostEntry == nil {
		t.HostEntry = make(map[string]*System_Dns_HostEntry)
	}

	key := Hostname

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.HostEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list HostEntry", key)
	}

	t.HostEntry[key] = &System_Dns_HostEntry{
		Hostname: &Hostname,
	}

	return t.HostEntry[key], nil
}

// RenameHostEntry renames an entry in the list HostEntry within
// the System_Dns struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Dns) RenameHostEntry(oldK, newK string) error {
	if _, ok := t.HostEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in HostEntry", newK)
	}

	e, ok := t.HostEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in HostEntry", oldK)
	}
	e.Hostname = &newK

	t.HostEntry[newK] = e
	delete(t.HostEntry, oldK)
	return nil
}

// GetOrCreateHostEntry retrieves the value with the specified keys from
// the receiver System_Dns. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Dns) GetOrCreateHostEntry(Hostname string) *System_Dns_HostEntry {

	key := Hostname

	if v, ok := t.HostEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHostEntry(Hostname)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHostEntry got unexpected error: %v", err))
	}
	return v
}

// GetHostEntry retrieves the value with the specified key from
// the HostEntry map field of System_Dns. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Dns) GetHostEntry(Hostname string) *System_Dns_HostEntry {

	if t == nil {
		return nil
	}

	key := Hostname

	if lm, ok := t.HostEntry[key]; ok {
		return lm
	}
	return nil
}

// AppendHostEntry appends the supplied System_Dns_HostEntry struct to the
// list HostEntry of System_Dns. If the key value(s) specified in
// the supplied System_Dns_HostEntry already exist in the list, an error is
// returned.
func (t *System_Dns) AppendHostEntry(v *System_Dns_HostEntry) error {
	key := *v.Hostname

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HostEntry == nil {
		t.HostEntry = make(map[string]*System_Dns_HostEntry)
	}

	if _, ok := t.HostEntry[key]; ok {
		return fmt.Errorf("duplicate key for list HostEntry %v", key)
	}

	t.HostEntry[key] = v
	return nil
}

// NewServer creates a new entry in the Server list of the
// System_Dns struct. The keys of the list are populated from the input
// arguments.
func (t *System_Dns) NewServer(Address string) (*System_Dns_Server, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Dns_Server)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &System_Dns_Server{
		Address: &Address,
	}

	return t.Server[key], nil
}

// RenameServer renames an entry in the list Server within
// the System_Dns struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Dns) RenameServer(oldK, newK string) error {
	if _, ok := t.Server[newK]; ok {
		return fmt.Errorf("key %v already exists in Server", newK)
	}

	e, ok := t.Server[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Server", oldK)
	}
	e.Address = &newK

	t.Server[newK] = e
	delete(t.Server, oldK)
	return nil
}

// GetOrCreateServer retrieves the value with the specified keys from
// the receiver System_Dns. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Dns) GetOrCreateServer(Address string) *System_Dns_Server {

	key := Address

	if v, ok := t.Server[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServer(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServer got unexpected error: %v", err))
	}
	return v
}

// GetServer retrieves the value with the specified key from
// the Server map field of System_Dns. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Dns) GetServer(Address string) *System_Dns_Server {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Server[key]; ok {
		return lm
	}
	return nil
}

// AppendServer appends the supplied System_Dns_Server struct to the
// list Server of System_Dns. If the key value(s) specified in
// the supplied System_Dns_Server already exist in the list, an error is
// returned.
func (t *System_Dns) AppendServer(v *System_Dns_Server) error {
	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Dns_Server)
	}

	if _, ok := t.Server[key]; ok {
		return fmt.Errorf("duplicate key for list Server %v", key)
	}

	t.Server[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Dns) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Dns"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Dns) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Dns_HostEntry struct, which is a YANG list entry.
func (t *System_Dns_HostEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Hostname == nil {
		return nil, fmt.Errorf("nil value for key Hostname")
	}

	return map[string]interface{}{
		"hostname": *t.Hostname,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Dns_HostEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Dns_HostEntry"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Dns_HostEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Dns_Server struct, which is a YANG list entry.
func (t *System_Dns_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Dns_Server) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Dns_Server"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Dns_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewRemoteServer creates a new entry in the RemoteServer list of the
// System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *System_Logging) NewRemoteServer(Host string) (*System_Logging_RemoteServer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RemoteServer == nil {
		t.RemoteServer = make(map[string]*System_Logging_RemoteServer)
	}

	key := Host

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RemoteServer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RemoteServer", key)
	}

	t.RemoteServer[key] = &System_Logging_RemoteServer{
		Host: &Host,
	}

	return t.RemoteServer[key], nil
}

// RenameRemoteServer renames an entry in the list RemoteServer within
// the System_Logging struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Logging) RenameRemoteServer(oldK, newK string) error {
	if _, ok := t.RemoteServer[newK]; ok {
		return fmt.Errorf("key %v already exists in RemoteServer", newK)
	}

	e, ok := t.RemoteServer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RemoteServer", oldK)
	}
	e.Host = &newK

	t.RemoteServer[newK] = e
	delete(t.RemoteServer, oldK)
	return nil
}

// GetOrCreateRemoteServer retrieves the value with the specified keys from
// the receiver System_Logging. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Logging) GetOrCreateRemoteServer(Host string) *System_Logging_RemoteServer {

	key := Host

	if v, ok := t.RemoteServer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRemoteServer(Host)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRemoteServer got unexpected error: %v", err))
	}
	return v
}

// GetRemoteServer retrieves the value with the specified key from
// the RemoteServer map field of System_Logging. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Logging) GetRemoteServer(Host string) *System_Logging_RemoteServer {

	if t == nil {
		return nil
	}

	key := Host

	if lm, ok := t.RemoteServer[key]; ok {
		return lm
	}
	return nil
}

// AppendRemoteServer appends the supplied System_Logging_RemoteServer struct to the
// list RemoteServer of System_Logging. If the key value(s) specified in
// the supplied System_Logging_RemoteServer already exist in the list, an error is
// returned.
func (t *System_Logging) AppendRemoteServer(v *System_Logging_RemoteServer) error {
	key := *v.Host

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RemoteServer == nil {
		t.RemoteServer = make(map[string]*System_Logging_RemoteServer)
	}

	if _, ok := t.RemoteServer[key]; ok {
		return fmt.Errorf("duplicate key for list RemoteServer %v", key)
	}

	t.RemoteServer[key] = v
	return nil
}

// GetOrCreateConsole retrieves the value of the Console field
// or returns the existing field if it already exists.
func (s *System_Logging) GetOrCreateConsole() *System_Logging_Console {
	if s.Console != nil {
		return s.Console
	}
	s.Console = &System_Logging_Console{}
	return s.Console
}

// GetConsole returns the value of the Console struct pointer
// from System_Logging. If the receiver or the field Console is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *System_Logging) GetConsole() *System_Logging_Console {
	if s != nil && s.Console != nil {
		return s.Console
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Logging) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Logging"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Logging) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewSelector creates a new entry in the Selector list of the
// System_Logging_Console struct. The keys of the list are populated from the input
// arguments.
func (t *System_Logging_Console) NewSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) (*System_Logging_Console_Selector, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Selector == nil {
		t.Selector = make(map[System_Logging_Console_Selector_Key]*System_Logging_Console_Selector)
	}

	key := System_Logging_Console_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Selector[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Selector", key)
	}

	t.Selector[key] = &System_Logging_Console_Selector{
		Facility: Facility,
		Severity: Severity,
	}

	return t.Selector[key], nil
}

// RenameSelector renames an entry in the list Selector within
// the System_Logging_Console struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Logging_Console) RenameSelector(oldK, newK System_Logging_Console_Selector_Key) error {
	if _, ok := t.Selector[newK]; ok {
		return fmt.Errorf("key %v already exists in Selector", newK)
	}

	e, ok := t.Selector[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Selector", oldK)
	}
	e.Facility = newK.Facility
	e.Severity = newK.Severity

	t.Selector[newK] = e
	delete(t.Selector, oldK)
	return nil
}

// GetOrCreateSelector retrieves the value with the specified keys from
// the receiver System_Logging_Console. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Logging_Console) GetOrCreateSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) *System_Logging_Console_Selector {

	key := System_Logging_Console_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	if v, ok := t.Selector[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSelector(Facility, Severity)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSelector got unexpected error: %v", err))
	}
	return v
}

// GetSelector retrieves the value with the specified key from
// the Selector map field of System_Logging_Console. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Logging_Console) GetSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) *System_Logging_Console_Selector {

	if t == nil {
		return nil
	}

	key := System_Logging_Console_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	if lm, ok := t.Selector[key]; ok {
		return lm
	}
	return nil
}

// AppendSelector appends the supplied System_Logging_Console_Selector struct to the
// list Selector of System_Logging_Console. If the key value(s) specified in
// the supplied System_Logging_Console_Selector already exist in the list, an error is
// returned.
func (t *System_Logging_Console) AppendSelector(v *System_Logging_Console_Selector) error {
	key := System_Logging_Console_Selector_Key{Facility: v.Facility, Severity: v.Severity}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Selector == nil {
		t.Selector = make(map[System_Logging_Console_Selector_Key]*System_Logging_Console_Selector)
	}

	if _, ok := t.Selector[key]; ok {
		return fmt.Errorf("duplicate key for list Selector %v", key)
	}

	t.Selector[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Logging_Console) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Logging_Console"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Logging_Console) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Logging_Console_Selector struct, which is a YANG list entry.
func (t *System_Logging_Console_Selector) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"facility": t.Facility,
		"severity": t.Severity,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Logging_Console_Selector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Logging_Console_Selector"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Logging_Console_Selector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NewSelector creates a new entry in the Selector list of the
// System_Logging_RemoteServer struct. The keys of the list are populated from the input
// arguments.
func (t *System_Logging_RemoteServer) NewSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) (*System_Logging_RemoteServer_Selector, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Selector == nil {
		t.Selector = make(map[System_Logging_RemoteServer_Selector_Key]*System_Logging_RemoteServer_Selector)
	}

	key := System_Logging_RemoteServer_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Selector[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Selector", key)
	}

	t.Selector[key] = &System_Logging_RemoteServer_Selector{
		Facility: Facility,
		Severity: Severity,
	}

	return t.Selector[key], nil
}

// RenameSelector renames an entry in the list Selector within
// the System_Logging_RemoteServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Logging_RemoteServer) RenameSelector(oldK, newK System_Logging_RemoteServer_Selector_Key) error {
	if _, ok := t.Selector[newK]; ok {
		return fmt.Errorf("key %v already exists in Selector", newK)
	}

	e, ok := t.Selector[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Selector", oldK)
	}
	e.Facility = newK.Facility
	e.Severity = newK.Severity

	t.Selector[newK] = e
	delete(t.Selector, oldK)
	return nil
}

// GetOrCreateSelector retrieves the value with the specified keys from
// the receiver System_Logging_RemoteServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Logging_RemoteServer) GetOrCreateSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) *System_Logging_RemoteServer_Selector {

	key := System_Logging_RemoteServer_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	if v, ok := t.Selector[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSelector(Facility, Severity)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSelector got unexpected error: %v", err))
	}
	return v
}

// GetSelector retrieves the value with the specified key from
// the Selector map field of System_Logging_RemoteServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Logging_RemoteServer) GetSelector(Facility E_OpenconfigSystemLogging_SYSLOG_FACILITY, Severity E_OpenconfigSystemLogging_SyslogSeverity) *System_Logging_RemoteServer_Selector {

	if t == nil {
		return nil
	}

	key := System_Logging_RemoteServer_Selector_Key{
		Facility: Facility,
		Severity: Severity,
	}

	if lm, ok := t.Selector[key]; ok {
		return lm
	}
	return nil
}

// AppendSelector appends the supplied System_Logging_RemoteServer_Selector struct to the
// list Selector of System_Logging_RemoteServer. If the key value(s) specified in
// the supplied System_Logging_RemoteServer_Selector already exist in the list, an error is
// returned.
func (t *System_Logging_RemoteServer) AppendSelector(v *System_Logging_RemoteServer_Selector) error {
	key := System_Logging_RemoteServer_Selector_Key{Facility: v.Facility, Severity: v.Severity}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Selector == nil {
		t.Selector = make(map[System_Logging_RemoteServer_Selector_Key]*System_Logging_RemoteServer_Selector)
	}

	if _, ok := t.Selector[key]; ok {
		return fmt.Errorf("duplicate key for list Selector %v", key)
	}

	t.Selector[key] = v
	return nil
}

// ΛListKeyMap returns the keys of the System_Logging_RemoteServer struct, which is a YANG list entry.
func (t *System_Logging_RemoteServer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Host == nil {
		return nil, fmt.Errorf("nil value for key Host")
	}

	return map[string]interface{}{
		"host": *t.Host,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Logging_RemoteServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Logging_RemoteServer"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Logging_RemoteServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Logging_RemoteServer_Selector struct, which is a YANG list entry.
func (t *System_Logging_RemoteServer_Selector) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"facility": t.Facility,
		"severity": t.Severity,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Logging_RemoteServer_Selector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Logging_RemoteServer_Selector"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Logging_RemoteServer_Selector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Memory) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Memory"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Memory) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewNtpKey creates a new entry in the NtpKey list of the
// System_Ntp struct. The keys of the list are populated from the input
// arguments.
func (t *System_Ntp) NewNtpKey(KeyId uint16) (*System_Ntp_NtpKey, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NtpKey == nil {
		t.NtpKey = make(map[uint16]*System_Ntp_NtpKey)
	}

	key := KeyId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NtpKey[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NtpKey", key)
	}

	t.NtpKey[key] = &System_Ntp_NtpKey{
		KeyId: &KeyId,
	}

	return t.NtpKey[key], nil
}

// RenameNtpKey renames an entry in the list NtpKey within
// the System_Ntp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Ntp) RenameNtpKey(oldK, newK uint16) error {
	if _, ok := t.NtpKey[newK]; ok {
		return fmt.Errorf("key %v already exists in NtpKey", newK)
	}

	e, ok := t.NtpKey[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NtpKey", oldK)
	}
	e.KeyId = &newK

	t.NtpKey[newK] = e
	delete(t.NtpKey, oldK)
	return nil
}

// GetOrCreateNtpKey retrieves the value with the specified keys from
// the receiver System_Ntp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Ntp) GetOrCreateNtpKey(KeyId uint16) *System_Ntp_NtpKey {

	key := KeyId

	if v, ok := t.NtpKey[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNtpKey(KeyId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNtpKey got unexpected error: %v", err))
	}
	return v
}

// GetNtpKey retrieves the value with the specified key from
// the NtpKey map field of System_Ntp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Ntp) GetNtpKey(KeyId uint16) *System_Ntp_NtpKey {

	if t == nil {
		return nil
	}

	key := KeyId

	if lm, ok := t.NtpKey[key]; ok {
		return lm
	}
	return nil
}

// AppendNtpKey appends the supplied System_Ntp_NtpKey struct to the
// list NtpKey of System_Ntp. If the key value(s) specified in
// the supplied System_Ntp_NtpKey already exist in the list, an error is
// returned.
func (t *System_Ntp) AppendNtpKey(v *System_Ntp_NtpKey) error {
	key := *v.KeyId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NtpKey == nil {
		t.NtpKey = make(map[uint16]*System_Ntp_NtpKey)
	}

	if _, ok := t.NtpKey[key]; ok {
		return fmt.Errorf("duplicate key for list NtpKey %v", key)
	}

	t.NtpKey[key] = v
	return nil
}

// NewServer creates a new entry in the Server list of the
// System_Ntp struct. The keys of the list are populated from the input
// arguments.
func (t *System_Ntp) NewServer(Address string) (*System_Ntp_Server, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Ntp_Server)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &System_Ntp_Server{
		Address: &Address,
	}

	return t.Server[key], nil
}

// RenameServer renames an entry in the list Server within
// the System_Ntp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *System_Ntp) RenameServer(oldK, newK string) error {
	if _, ok := t.Server[newK]; ok {
		return fmt.Errorf("key %v already exists in Server", newK)
	}

	e, ok := t.Server[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Server", oldK)
	}
	e.Address = &newK

	t.Server[newK] = e
	delete(t.Server, oldK)
	return nil
}

// GetOrCreateServer retrieves the value with the specified keys from
// the receiver System_Ntp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *System_Ntp) GetOrCreateServer(Address string) *System_Ntp_Server {

	key := Address

	if v, ok := t.Server[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServer(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServer got unexpected error: %v", err))
	}
	return v
}

// GetServer retrieves the value with the specified key from
// the Server map field of System_Ntp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *System_Ntp) GetServer(Address string) *System_Ntp_Server {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Server[key]; ok {
		return lm
	}
	return nil
}

// AppendServer appends the supplied System_Ntp_Server struct to the
// list Server of System_Ntp. If the key value(s) specified in
// the supplied System_Ntp_Server already exist in the list, an error is
// returned.
func (t *System_Ntp) AppendServer(v *System_Ntp_Server) error {
	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*System_Ntp_Server)
	}

	if _, ok := t.Server[key]; ok {
		return fmt.Errorf("duplicate key for list Server %v", key)
	}

	t.Server[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Ntp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Ntp"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Ntp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Ntp_NtpKey struct, which is a YANG list entry.
func (t *System_Ntp_NtpKey) ΛListKeyMap() (map[string]interface{}, error) {
	if t.KeyId == nil {
		return nil, fmt.Errorf("nil value for key KeyId")
	}

	return map[string]interface{}{
		"key-id": *t.KeyId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Ntp_NtpKey) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Ntp_NtpKey"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Ntp_NtpKey) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Ntp_Server struct, which is a YANG list entry.
func (t *System_Ntp_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Ntp_Server) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Ntp_Server"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Ntp_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the System_Process struct, which is a YANG list entry.
func (t *System_Process) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Pid == nil {
		return nil, fmt.Errorf("nil value for key Pid")
	}

	return map[string]interface{}{
		"pid": *t.Pid,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_Process) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_Process"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_Process) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_SshServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_SshServer"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_SshServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *System_TelnetServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["System_TelnetServer"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *System_TelnetServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewChannel creates a new entry in the Channel list of the
// TerminalDevice struct. The keys of the list are populated from the input
// arguments.
func (t *TerminalDevice) NewChannel(Index uint32) (*TerminalDevice_Channel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Channel == nil {
		t.Channel = make(map[uint32]*TerminalDevice_Channel)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Channel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Channel", key)
	}

	t.Channel[key] = &TerminalDevice_Channel{
		Index: &Index,
	}

	return t.Channel[key], nil
}

// RenameChannel renames an entry in the list Channel within
// the TerminalDevice struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *TerminalDevice) RenameChannel(oldK, newK uint32) error {
	if _, ok := t.Channel[newK]; ok {
		return fmt.Errorf("key %v already exists in Channel", newK)
	}

	e, ok := t.Channel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Channel", oldK)
	}
	e.Index = &newK

	t.Channel[newK] = e
	delete(t.Channel, oldK)
	return nil
}

// GetOrCreateChannel retrieves the value with the specified keys from
// the receiver TerminalDevice. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *TerminalDevice) GetOrCreateChannel(Index uint32) *TerminalDevice_Channel {

	key := Index

	if v, ok := t.Channel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewChannel(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateChannel got unexpected error: %v", err))
	}
	return v
}

// GetChannel retrieves the value with the specified key from
// the Channel map field of TerminalDevice. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *TerminalDevice) GetChannel(Index uint32) *TerminalDevice_Channel {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Channel[key]; ok {
		return lm
	}
	return nil
}

// AppendChannel appends the supplied TerminalDevice_Channel struct to the
// list Channel of TerminalDevice. If the key value(s) specified in
// the supplied TerminalDevice_Channel already exist in the list, an error is
// returned.
func (t *TerminalDevice) AppendChannel(v *TerminalDevice_Channel) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Channel == nil {
		t.Channel = make(map[uint32]*TerminalDevice_Channel)
	}

	if _, ok := t.Channel[key]; ok {
		return fmt.Errorf("duplicate key for list Channel %v", key)
	}

	t.Channel[key] = v
	return nil
}

// NewMode creates a new entry in the Mode list of the
// TerminalDevice struct. The keys of the list are populated from the input
// arguments.
func (t *TerminalDevice) NewMode(ModeId uint16) (*TerminalDevice_Mode, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mode == nil {
		t.Mode = make(map[uint16]*TerminalDevice_Mode)
	}

	key := ModeId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mode[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mode", key)
	}

	t.Mode[key] = &TerminalDevice_Mode{
		ModeId: &ModeId,
	}

	return t.Mode[key], nil
}

// RenameMode renames an entry in the list Mode within
// the TerminalDevice struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *TerminalDevice) RenameMode(oldK, newK uint16) error {
	if _, ok := t.Mode[newK]; ok {
		return fmt.Errorf("key %v already exists in Mode", newK)
	}

	e, ok := t.Mode[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mode", oldK)
	}
	e.ModeId = &newK

	t.Mode[newK] = e
	delete(t.Mode, oldK)
	return nil
}

// GetOrCreateMode retrieves the value with the specified keys from
// the receiver TerminalDevice. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *TerminalDevice) GetOrCreateMode(ModeId uint16) *TerminalDevice_Mode {

	key := ModeId

	if v, ok := t.Mode[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMode(ModeId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMode got unexpected error: %v", err))
	}
	return v
}

// GetMode retrieves the value with the specified key from
// the Mode map field of TerminalDevice. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *TerminalDevice) GetMode(ModeId uint16) *TerminalDevice_Mode {

	if t == nil {
		return nil
	}

	key := ModeId

	if lm, ok := t.Mode[key]; ok {
		return lm
	}
	return nil
}

// AppendMode appends the supplied TerminalDevice_Mode struct to the
// list Mode of TerminalDevice. If the key value(s) specified in
// the supplied TerminalDevice_Mode already exist in the list, an error is
// returned.
func (t *TerminalDevice) AppendMode(v *TerminalDevice_Mode) error {
	key := *v.ModeId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mode == nil {
		t.Mode = make(map[uint16]*TerminalDevice_Mode)
	}

	if _, ok := t.Mode[key]; ok {
		return fmt.Errorf("duplicate key for list Mode %v", key)
	}

	t.Mode[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *TerminalDevice) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NewAssignment creates a new entry in the Assignment list of the
// TerminalDevice_Channel struct. The keys of the list are populated from the input
// arguments.
func (t *TerminalDevice_Channel) NewAssignment(Index uint32) (*TerminalDevice_Channel_Assignment, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Assignment == nil {
		t.Assignment = make(map[uint32]*TerminalDevice_Channel_Assignment)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Assignment[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Assignment", key)
	}

	t.Assignment[key] = &TerminalDevice_Channel_Assignment{
		Index: &Index,
	}

	return t.Assignment[key], nil
}

// RenameAssignment renames an entry in the list Assignment within
// the TerminalDevice_Channel struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *TerminalDevice_Channel) RenameAssignment(oldK, newK uint32) error {
	if _, ok := t.Assignment[newK]; ok {
		return fmt.Errorf("key %v already exists in Assignment", newK)
	}

	e, ok := t.Assignment[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Assignment", oldK)
	}
	e.Index = &newK

	t.Assignment[newK] = e
	delete(t.Assignment, oldK)
	return nil
}

// GetOrCreateAssignment retrieves the value with the specified keys from
// the receiver TerminalDevice_Channel. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *TerminalDevice_Channel) GetOrCreateAssignment(Index uint32) *TerminalDevice_Channel_Assignment {

	key := Index

	if v, ok := t.Assignment[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAssignment(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAssignment got unexpected error: %v", err))
	}
	return v
}

// GetAssignment retrieves the value with the specified key from
// the Assignment map field of TerminalDevice_Channel. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *TerminalDevice_Channel) GetAssignment(Index uint32) *TerminalDevice_Channel_Assignment {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Assignment[key]; ok {
		return lm
	}
	return nil
}

// AppendAssignment appends the supplied TerminalDevice_Channel_Assignment struct to the
// list Assignment of TerminalDevice_Channel. If the key value(s) specified in
// the supplied TerminalDevice_Channel_Assignment already exist in the list, an error is
// returned.
func (t *TerminalDevice_Channel) AppendAssignment(v *TerminalDevice_Channel_Assignment) error {
	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Assignment == nil {
		t.Assignment = make(map[uint32]*TerminalDevice_Channel_Assignment)
	}

	if _, ok := t.Assignment[key]; ok {
		return fmt.Errorf("duplicate key for list Assignment %v", key)
	}

	t.Assignment[key] = v
	return nil
}

// GetOrCreateEthernet retrieves the value of the Ethernet field
// or returns the existing field if it already exists.
func (s *TerminalDevice_Channel) GetOrCreateEthernet() *TerminalDevice_Channel_Ethernet {
	if s.Ethernet != nil {
		return s.Ethernet
	}
	s.Ethernet = &TerminalDevice_Channel_Ethernet{}
	return s.Ethernet
}

// GetOrCreateIngress retrieves the value of the Ingress field
// or returns the existing field if it already exists.
func (s *TerminalDevice_Channel) GetOrCreateIngress() *TerminalDevice_Channel_Ingress {
	if s.Ingress != nil {
		return s.Ingress
	}
	s.Ingress = &TerminalDevice_Channel_Ingress{}
	return s.Ingress
}

// GetOrCreateOtn retrieves the value of the Otn field
// or returns the existing field if it already exists.
func (s *TerminalDevice_Channel) GetOrCreateOtn() *TerminalDevice_Channel_Otn {
	if s.Otn != nil {
		return s.Otn
	}
	s.Otn = &TerminalDevice_Channel_Otn{}
	return s.Otn
}

// GetEthernet returns the value of the Ethernet struct pointer
// from TerminalDevice_Channel. If the receiver or the field Ethernet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *TerminalDevice_Channel) GetEthernet() *TerminalDevice_Channel_Ethernet {
	if s != nil && s.Ethernet != nil {
		return s.Ethernet
	}
	return nil
}

// GetIngress returns the value of the Ingress struct pointer
// from TerminalDevice_Channel. If the receiver or the field Ingress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *TerminalDevice_Channel) GetIngress() *TerminalDevice_Channel_Ingress {
	if s != nil && s.Ingress != nil {
		return s.Ingress
	}
	return nil
}

// GetOtn returns the value of the Otn struct pointer
// from TerminalDevice_Channel. If the receiver or the field Otn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *TerminalDevice_Channel) GetOtn() *TerminalDevice_Channel_Otn {
	if s != nil && s.Otn != nil {
		return s.Otn
	}
	return nil
}

// ΛListKeyMap returns the keys of the TerminalDevice_Channel struct, which is a YANG list entry.
func (t *TerminalDevice_Channel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *TerminalDevice_Channel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛListKeyMap returns the keys of the TerminalDevice_Channel_Assignment struct, which is a YANG list entry.
func (t *TerminalDevice_Channel_Assignment) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *TerminalDevice_Channel_Assignment) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Assignment"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Assignment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *TerminalDevice_Channel_Ethernet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Ethernet"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Ethernet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *TerminalDevice_Channel_Ingress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Ingress"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Ingress) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// GetOrCreateEsnr retrieves the value of the Esnr field
// or returns the existing field if it already exists.
func (s *TerminalDevice_Channel_Otn) GetOrCreateEsnr() *TerminalDevice_Channel_Otn_Esnr {
	if s.Esnr != nil {
		return s.Esnr
	}
	s.Esnr = &TerminalDevice_Channel_Otn_Esnr{}
	return s.Esnr
}

// GetOrCreatePostFecBer retrieves the value of the PostFecBer field
// or returns the existing field if it already exists.
func (s *TerminalDevice_Channel_Otn) GetOrCreatePostFecBer() *TerminalDevice_Channel_Otn_PostFecBer {
	if s.PostFecBer != nil {
		return s.PostFecBer
	}
	s.PostFecBer = &TerminalDevice_Channel_Otn_PostFecBer{}
	return s.PostFecBer
}

// GetOrCreatePreFecBer retrieves the value of the PreFecBer field
// or returns the existing field if it already exists.
func (s *TerminalDevice_Channel_Otn) GetOrCreatePreFecBer() *TerminalDevice_Channel_Otn_PreFecBer {
	if s.PreFecBer != nil {
		return s.PreFecBer
	}
	s.PreFecBer = &TerminalDevice_Channel_Otn_PreFecBer{}
	return s.PreFecBer
}

// GetOrCreateQValue retrieves the value of the QValue field
// or returns the existing field if it already exists.
func (s *TerminalDevice_Channel_Otn) GetOrCreateQValue() *TerminalDevice_Channel_Otn_QValue {
	if s.QValue != nil {
		return s.QValue
	}
	s.QValue = &TerminalDevice_Channel_Otn_QValue{}
	return s.QValue
}

// GetEsnr returns the value of the Esnr struct pointer
// from TerminalDevice_Channel_Otn. If the receiver or the field Esnr is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *TerminalDevice_Channel_Otn) GetEsnr() *TerminalDevice_Channel_Otn_Esnr {
	if s != nil && s.Esnr != nil {
		return s.Esnr
	}
	return nil
}

// GetPostFecBer returns the value of the PostFecBer struct pointer
// from TerminalDevice_Channel_Otn. If the receiver or the field PostFecBer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *TerminalDevice_Channel_Otn) GetPostFecBer() *TerminalDevice_Channel_Otn_PostFecBer {
	if s != nil && s.PostFecBer != nil {
		return s.PostFecBer
	}
	return nil
}

// GetPreFecBer returns the value of the PreFecBer struct pointer
// from TerminalDevice_Channel_Otn. If the receiver or the field PreFecBer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *TerminalDevice_Channel_Otn) GetPreFecBer() *TerminalDevice_Channel_Otn_PreFecBer {
	if s != nil && s.PreFecBer != nil {
		return s.PreFecBer
	}
	return nil
}

// GetQValue returns the value of the QValue struct pointer
// from TerminalDevice_Channel_Otn. If the receiver or the field QValue is nil, nil
// is returned such that the Get* methods can be safely chained.
func (s *TerminalDevice_Channel_Otn) GetQValue() *TerminalDevice_Channel_Otn_QValue {
	if s != nil && s.QValue != nil {
		return s.QValue
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *TerminalDevice_Channel_Otn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Otn"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Otn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Validate validates s against the YANG schema corresponding to its type.
func (s *TerminalDevice_Channel_Otn_Esnr) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Otn_Esnr"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Otn_Esnr) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *TerminalDevice_Channel_Otn_PostFecBer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Otn_PostFecBer"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Otn_PostFecBer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *TerminalDevice_Channel_Otn_PreFecBer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Otn_PreFecBer"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Otn_PreFecBer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *TerminalDevice_Channel_Otn_QValue) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Channel_Otn_QValue"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Channel_Otn_QValue) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛListKeyMap returns the keys of the TerminalDevice_Mode struct, which is a YANG list entry.
func (t *TerminalDevice_Mode) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ModeId == nil {
		return nil, fmt.Errorf("nil value for key ModeId")
	}

	return map[string]interface{}{
		"mode-id": *t.ModeId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (s *TerminalDevice_Mode) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["TerminalDevice_Mode"], s, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *TerminalDevice_Mode) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }
